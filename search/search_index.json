{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TiTiler","text":"<p> <p>A modern dynamic tile server built on top of FastAPI and Rasterio/GDAL.</p> </p> <p> </p> <p>Documentation: devseed.com/titiler/</p> <p>Source Code: developmentseed/titiler</p> <p><code>Titiler</code>, pronounced tee-tiler (ti is the diminutive version of the french petit which means small), is a set of python modules that focus on creating FastAPI application for dynamic tiling.</p> <p>Note: This project is the descendant of <code>cogeo-tiler</code> and <code>cogeo-mosaic-tiler</code>.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Built on top of FastAPI</li> <li>Cloud Optimized GeoTIFF support</li> <li>SpatioTemporal Asset Catalog support</li> <li>Multiple projections support (see TileMatrixSets) via <code>morecantile</code>.</li> <li>JPEG / JP2 / PNG / WEBP / GTIFF / NumpyTile output format support</li> <li>OGC WMTS support</li> <li>Automatic OpenAPI documentation (FastAPI builtin)</li> <li>Virtual mosaic support (via MosaicJSON)</li> <li>Example of AWS Lambda / ECS deployment (via CDK)</li> </ul>"},{"location":"#packages","title":"Packages","text":"<p>Starting with version <code>0.3.0</code>, the <code>TiTiler</code> python module has been split into a set of python namespace packages: <code>titiler.{package}</code>.</p> Package Version Description titiler.core The <code>Core</code> package contains libraries to help create a  dynamic tiler for COG and STAC titiler.extensions TiTiler's extensions package. Contains extensions for Tiler Factories. titiler.mosaic The <code>mosaic</code> package contains libraries to help create a dynamic tiler for MosaicJSON (adds <code>cogeo-mosaic</code> requirement) titiler.application TiTiler's <code>demo</code> package. Contains a FastAPI application with full support of COG, STAC and MosaicJSON"},{"location":"#installation","title":"Installation","text":"<p>To install from PyPI and run:</p> <pre><code># Make sure you have pip up to date\npython -m pip install -U pip\n\npython -m pip  install titiler.{package}\n# e.g.,\n# python -m pip  install titiler.core\n# python -m pip  install titiler.extensions\n# python -m pip  install titiler.mosaic\n# python -m pip  install titiler.application (also installs core, extensions and mosaic)\n\n# Install uvicorn to run the FastAPI application locally\npython -m pip install uvicorn\n\n# Launch application locally\nuvicorn titiler.application.main:app\n</code></pre> <p>To install from sources and run for development:</p> <pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\n\npython -m pip install -U pip\npython -m pip install -e src/titiler/core -e src/titiler/extensions -e src/titiler/mosaic -e src/titiler/application\npython -m pip install uvicorn\n\nuvicorn titiler.application.main:app --reload\n</code></pre>"},{"location":"#docker","title":"Docker","text":"<p>Ready to use/deploy images can be found on Github registry.</p> <ul> <li>github.com/developmentseed/titiler/pkgs/container/titiler</li> </ul> <pre><code>docker run --name titiler \\\n    -p 8000:8000 \\\n    --env PORT=8000 \\\n    --env WORKERS_PER_CORE=1 \\\n    --rm -it ghcr.io/developmentseed/titiler:latest\n</code></pre> <ul> <li>Built the docker locally <pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\n\ndocker compose up --build titiler  # or titiler-uvicorn\n</code></pre></li> </ul> <p>Some options can be set via environment variables, see: tiangolo/uvicorn-gunicorn-docker#advanced-usage</p>"},{"location":"#project-structure","title":"Project structure","text":"<pre><code>src/titiler/                     - titiler modules.\n \u251c\u2500\u2500 application/                - Titiler's `Application` package\n \u251c\u2500\u2500 extensions/                 - Titiler's `Extensions` package\n \u251c\u2500\u2500 core/                       - Titiler's `Core` package\n \u2514\u2500\u2500 mosaic/                     - Titiler's `Mosaic` package\n</code></pre>"},{"location":"#contribution-development","title":"Contribution &amp; Development","text":"<p>See CONTRIBUTING.md</p>"},{"location":"#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"#authors","title":"Authors","text":"<p>Created by Development Seed</p> <p>See contributors for a listing of individual contributors.</p>"},{"location":"#changes","title":"Changes","text":"<p>See CHANGES.md.</p>"},{"location":"contributing/","title":"Development - Contributing","text":"<p>Issues and pull requests are more than welcome: github.com/developmentseed/titiler/issues</p> <p>dev install</p> <pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\n\npython -m pip install \\\n   pre-commit \\\n   -e src/titiler/core[\"test\"] \\\n   -e src/titiler/extensions[\"test,cogeo,stac\"] \\\n   -e src/titiler/mosaic[\"test\"] \\\n   -e src/titiler/application[\"test\"]\n</code></pre> <p>pre-commit</p> <p>This repo is set to use <code>pre-commit</code> to run isort, flake8, pydocstring, black (\"uncompromising Python code formatter\") and mypy when committing new code.</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#run-tests","title":"Run tests","text":"<p>Each <code>titiler</code>'s modules has its own test suite which can be ran independently</p> <pre><code># titiler.core\npython -m pytest src/titiler/core --cov=titiler.core --cov-report=xml --cov-append --cov-report=term-missing\n\n# titiler.extensions\npython -m pytest src/titiler/extensions --cov=titiler.extensions --cov-report=xml --cov-append --cov-report=term-missing\n\n# titiler.mosaic\npython -m pytest src/titiler/mosaic --cov=titiler.mosaic --cov-report=xml --cov-append --cov-report=term-missing\n\n# titiler.application\npython -m pytest src/titiler/application --cov=titiler.application --cov-report=xml --cov-append --cov-report=term-missing\n</code></pre>"},{"location":"contributing/#docs","title":"Docs","text":"<pre><code>git clone https://github.com/developmentseed/titiler.git\ncd titiler\npython -m pip install -r requirements/requirements-docs.txt\n</code></pre> <p>Hot-reloading docs:</p> <pre><code>mkdocs serve -f docs/mkdocs.yml\n</code></pre> <p>To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.):</p> <pre><code>mkdocs gh-deploy -f docs/mkdocs.yml\n</code></pre>"},{"location":"dynamic_tiling/","title":"Dynamic Tiling","text":"<p>TiTiler's first goal is to create a lightweight but performant dynamic tile server... but what do we mean by this?</p> <p>When you zoom/pan on a web map, you are visualizing either vector or raster data that is loaded by your web client (e.g Chrome). Vector Tiles are rendered On the Fly, meaning the map library (e.g MapboxGL) will apply styling on the vector it receives to create a visual representation on the map. This is possible because vector data can be encoded and compressed very efficiently and result in each tile being only couple of kilo octets.</p> <p>On the other side, raster data is a really dense format, a <code>256 x 256 x 3</code> tile (True color image) needs to encode <code>196 608</code> values, and depending on the data type (Integer, Float, Complex), a raster tile can be really heavy. Depending on the dataset data type, some operations might be needed in order to obtain a visual representation (e.g. rescaling, colormap, ... ). Map library will almost only accept Uint8 RGB(A) tile encoded as PNG, JPEG or Webp.</p>"},{"location":"dynamic_tiling/#static-tiling","title":"Static tiling","text":"<p><code>Static</code> tiling is referring to <code>static</code> tiles (file on storage) that are pre-rendered from input dataset. Here are the steps needed to create those tiles:</p> <ul> <li>rescale the data to integer (0 -&gt; 255), if datatype in not Uint8</li> <li>reproject the data to Web Mercator (or the projection of the web map application)</li> <li>split the data in tiles (256x256 or 512x512) and create different zoom levels (ref: gdal.org/programs/gdal2tiles.html)</li> </ul> <p>When the tiles are available on a storage, you can either put a web server (e.g. tilecache, mapserver) or maybe directly put a CDN, which will allow map client to <code>fetch</code> the tiles.</p>"},{"location":"dynamic_tiling/#pro","title":"Pro","text":"<ul> <li>Fast</li> <li>Relatively simple to create the tiles (<code>gdal2tiles.py</code>)</li> </ul>"},{"location":"dynamic_tiling/#cons","title":"Cons","text":"<ul> <li>You have to manage a lot of tiny files</li> <li>Choices are made for the user (projection, rescaling, ...)</li> <li>Some tiles might never been loaded</li> </ul>"},{"location":"dynamic_tiling/#dynamic-tiling","title":"Dynamic tiling","text":"<p>The goal of the <code>Dynamic Tiling</code> process is to get rid of all the pre-processing steps, by creating a tile server which can access the raw data (COG) and apply operations (rescaling, reprojection, image encoding) to create the visual tiles on the fly.</p> <ul> <li>Open the file and get internal metadata (stored in the header of the file)</li> <li>Read internal parts needed to construct the output tile</li> <li>Apply data rescaling (if needed)</li> <li>Apply colormap (if needed)</li> <li>Encode the data into a visual image format (JPEG, PNG, WEBP)</li> </ul>"},{"location":"dynamic_tiling/#pro_1","title":"Pro","text":"<ul> <li>Access the raw data</li> <li>Multiple projection support</li> <li>User defined rescaling (when working with non-byte data)</li> <li>User defined Colormap</li> <li>Selection of bands/bands combination/bands math</li> <li>Apply custom processing on the tile data</li> <li>Dynamic mosaic with multiple datasets (user defined image order and pixel selection methods)</li> </ul>"},{"location":"dynamic_tiling/#cons_1","title":"Cons","text":"<ul> <li>Latency. Creating a tile from a COG means at least 2 GET requests (if web optimized).</li> <li>Dynamic tile server are more complex than Static tile server (which just serve files from a storage)</li> <li>No easy update (you need to re-write the whole COG)</li> <li>Tile server like TiTiler might present too many options (this is because titiler aim to support all COG types)</li> </ul>"},{"location":"dynamic_tiling/#summary","title":"Summary","text":"<p>With <code>Static</code> tile generation you are often limited because you are visualizing data that is fixed and stored somewhere on a disk. With <code>Dynamic tiling</code>, users have the possibility to apply their own choice of processing (e.g rescaling, masking) before creating the <code>image</code>.</p> <p>Static tiling will always be faster than dynamic tiling, but a cache layer can be set up in front of the dynamic tiler, but using a dynamic tiler often means that same tile won't be serve twice (because users can set multiple options).</p>"},{"location":"dynamic_tiling/#links","title":"Links","text":"<p>https://medium.com/devseed/cog-talk-part-1-whats-new-941facbcd3d1</p> <p>https://kylebarron.dev/blog/cog-mosaic/overview</p> <p>https://mapdataservices.wordpress.com/2014/05/05/digital-mappings-dynamic-makeover/</p> <p>https://medium.com/indigoag-eng/more-and-better-satellite-imagery-through-dynamic-tiling-60dcd7ce66ce</p> <p>https://sparkgeo.com/blog/terradactile-generate-cogs-from-aws-terrain-tiles/</p> <p>https://www.azavea.com/blog/2019/04/23/using-cloud-optimized-geotiffs-cogs/</p> <p>https://hi.stamen.com/stamen-aws-lambda-tiler-blog-post-76fc1138a145</p>"},{"location":"external_links/","title":"External links","text":"<p>Tip</p> <p>If you have an article, project, tool, or anything related to TiTiler that is not yet listed here, create a Pull Request adding it.</p>"},{"location":"external_links/#mentions","title":"Mentions","text":"<ul> <li> <p>Sparkgeo's Terradactile</p> </li> <li> <p>Chris Holmes Cloud Native Geospatial Sprint Awards &amp; Bounties</p> </li> <li> <p>Tobin Bradley awesome video about COGs Youtube</p> </li> <li> <p>David McCracken's Blog on Plotly Dash Interactive Mapping - Dash Leaflet &amp; TiTiler</p> </li> </ul>"},{"location":"external_links/#titiler-extensionsplugins","title":"TiTiler extensions/plugins","text":"<ul> <li> <p>stac-utils/titiler-pgstac: TiTiler extension which connects to a PgSTAC database to create dynamic mosaics based on search queries.</p> </li> <li> <p>developmentseed/titiler-xarray: TiTiler extension for xarray</p> </li> <li> <p>developmentseed/titiler-images: TiTiler demo application for Sentinel-2 Digital Twin dataset</p> </li> </ul>"},{"location":"external_links/#projects-demo-using-titiler","title":"Projects / Demo using TiTiler","text":"<ul> <li> <p>ESA Charter Mapper geobrowser</p> </li> <li> <p>developmentseed/titiler-digitaltwin: TiTiler demo application for Sentinel-2 Digital Twin dataset</p> </li> <li> <p>developmentseed/titiler-mvt: TiTiler demo application to create Mapbox Vector Tiles from COG</p> </li> <li> <p>developmentseed/titiler-pds: TiTiler demo application for Sentinel-2 and Landsat-8 AWS Public Datasets</p> </li> <li> <p>stac-utils/stac-fastapi: STAC API implementation with FastAPI.</p> </li> <li> <p>c-core-labs/stac-api: STAC compliant API implementation (built from stac-fastapi)</p> </li> <li> <p>developmentseed/titiler-lambda-layer: TiTiler Lambda layers for easy deployment on AWS</p> </li> <li> <p>Terradue/Stars: Spatio Temporal Asset Runtime Services</p> </li> <li> <p>developmentseed/rio-viz: Visualize Cloud Optimized GeoTIFF in browser</p> </li> <li> <p>developmentseed/pearl-backend: PEARL (Planetary Computer Land Cover Mapping) Platform API and Infrastructure</p> </li> <li> <p>microsoft/planetary-computer-apis: Microsoft Planetary Computer APIs</p> </li> </ul>"},{"location":"external_links/#conferences-presentations-videos","title":"Conferences / presentations / videos","text":"<ul> <li>FOSS4G 2022 TiTiler_not_just_a_tile_server.pdf</li> <li>Cloud Native Outreach 2022 Youtube + TiTiler.pdf</li> <li>Jeff Albrecht and Vincent Sarago talk about COG's and STAC with Titiler &amp; Arturo-STAC-API Youtube</li> </ul>"},{"location":"intro/","title":"Intro","text":"<p><code>TiTiler</code> is a set of python modules whose goal are to help users in creating a dynamic tile server. To learn more about <code>dynamic tiling</code> please refer to the docs.</p> <p>Users can choose to extend or use <code>TiTiler</code> as it is.</p>"},{"location":"intro/#default-application","title":"Default Application","text":"<p><code>TiTiler</code> comes with a default (complete) application with support for COG, STAC, and MosaicJSON. You can install and start the application locally by doing:</p> <pre><code># Update pip\npython -m pip install -U pip\n\n# Install titiler packages\npython -m pip install uvicorn titiler.application\n\n# Start application using uvicorn\nuvicorn titiler.application.main:app\n\n&gt; INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre> <p>See default endpoints documentation pages:</p> <ul> <li><code>/cog</code> - Cloud Optimized GeoTIFF</li> <li><code>/mosaicjson</code> - MosaicJSON</li> <li><code>/stac</code> - Spatio Temporal Asset Catalog</li> <li><code>/tileMatrixSets</code> - Tiling Schemes</li> <li><code>/algorithms</code> - Algorithms</li> <li><code>/colorMaps</code> - ColorMaps</li> </ul>"},{"location":"intro/#settings","title":"Settings","text":"<p>The default application can be customized using environment variables defined in <code>titiler.application.settings.ApiSettings</code> class. Each variable needs to be prefixed with <code>TITILER_API_</code>.</p> <ul> <li><code>NAME</code> (str): name of the application. Defaults to <code>titiler</code>.</li> <li><code>CORS_ORIGINS</code> (str, <code>,</code> delimited origins): allowed CORS origin. Defaults to <code>*</code>.</li> <li><code>CORS_ALLOW_METHODS</code> (str, <code>,</code> delimited methods): allowed CORS methods. Defaults to <code>GET</code>.</li> <li><code>CACHECONTROL</code> (str): Cache control header to add to responses. Defaults to <code>\"public, max-age=3600\"</code>.</li> <li><code>ROOT_PATH</code> (str): path behind proxy.</li> <li><code>DEBUG</code> (str): adds <code>LoggerMiddleware</code> and <code>TotalTimeMiddleware</code> in the middleware stack.</li> <li><code>DISABLE_COG</code> (bool): disable <code>/cog</code> endpoints.</li> <li><code>DISABLE_STAC</code> (bool): disable <code>/stac</code> endpoints.</li> <li><code>DISABLE_MOSAIC</code> (bool): disable <code>/mosaic</code> endpoints.</li> <li><code>LOWER_CASE_QUERY_PARAMETERS</code> (bool): transform all query-parameters to lower case (see developmentseed/titiler!321).</li> <li><code>GLOBAL_ACCESS_TOKEN</code> (str | None): a string which is required in the <code>?access_token=</code> query param with every request.</li> </ul>"},{"location":"intro/#customized-minimal-app","title":"Customized, minimal app","text":"<p><code>TiTiler</code> has been developed so users can build their own application with only the endpoints they need. Using Factories, users can create a fully customized application with only a defined set of endpoints.</p> <p>When building a custom application, you may wish to only install the <code>core</code> and/or <code>mosaic</code> modules. To install these from PyPI:</p> <pre><code># Update pip\npython -m pip install -U pip\n\n# Install titiler.core and uvicorn packages\npython -m pip install titiler.core uvicorn\n</code></pre> <p>These can then be used like:</p> <pre><code># app.py\nimport uvicorn\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\ncog = TilerFactory()\napp.include_router(cog.router)\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\nif __name__ == '__main__':\n    uvicorn.run(app=app, host=\"127.0.0.1\", port=8080, log_level=\"info\")\n</code></pre> <p></p>"},{"location":"intro/#extending-titilers-app","title":"Extending TiTiler's app","text":"<p>If you want to include all of Titiler's built-in endpoints, but also include customized endpoints, you can import and extend the app directly.</p> <pre><code>python -m pip install titiler.application uvicorn # also installs titiler.core and titiler.mosaic\n</code></pre> <p>These can then be used like:</p> <pre><code># Add private COG endpoints requiring token validation\nfrom fastapi import APIRouter, Depends, HTTPException, Security\nfrom fastapi.security.api_key import APIKeyQuery\n\nfrom titiler.application.main import app\nfrom titiler.core.factory import TilerFactory\n\nimport uvicorn\n\napi_key_query = APIKeyQuery(name=\"access_token\", auto_error=False)\n\n\ndef token_validation(access_token: str = Security(api_key_query)):\n    \"\"\"stupid token validation.\"\"\"\n    if not access_token:\n        raise HTTPException(status_code=401, detail=\"Missing `access_token`\")\n\n    # if access_token == `token` then OK\n    if not access_token == \"token\":\n        raise HTTPException(status_code=401, detail=\"Invalid `access_token`\")\n\n    return True\n\n\n# Custom router with token dependency\nrouter = APIRouter(dependencies=[Depends(token_validation)])\ntiler = TilerFactory(router_prefix=\"private/cog\", router=router)\n\napp.include_router(tiler.router, prefix=\"/private/cog\", tags=[\"Private\"])\n\n\nif __name__ == '__main__':\n    uvicorn.run(app=app, host=\"127.0.0.1\", port=8080, log_level=\"info\")\n</code></pre> <p>More on customization</p>"},{"location":"mosaics/","title":"Mosaics","text":"<p>[Work in Progress]</p> <p></p> <p><code>Titiler</code> has native support for reading and creating web map tiles from MosaicJSON.</p> <p>MosaicJSON is an open standard for representing metadata about a mosaic of Cloud-Optimized GeoTIFF (COG) files.</p> <p>Ref: developmentseed/mosaicjson-spec</p>"},{"location":"mosaics/#links","title":"Links","text":"<ul> <li>medium.com/devseed/cog-talk-part-2-mosaics-bbbf474e66df</li> <li>developmentseed/cogeo-mosaic</li> </ul>"},{"location":"output_format/","title":"Output data format","text":"<p><code>TiTiler</code> supports the common output format for map tiles: JPEG, PNG and WEBP.</p> <p>While some formats (e.g PNG) are able to encode Uint16 or Float datatypes, most web browsers only supports 8 bit data (meaning that it has to be between 0 and 255). It's on the user to know what datatype is the input source (COG), and what kind of <code>post processing</code> there is to do to create a valid web map tile.</p> <p><code>TiTiler</code> also has support for more complex output data formats, such as JPEG2000 or GeoTIFF. While it might not be useful for FrontEnd display (most browsers can't decode GeoTIFF natively), some users could want to transmit the data as <code>raw</code> values to some applications (non-web display).</p> <p>Default output types/extensions are:</p> <ul> <li><code>.tif</code>: image/tiff; application=geotiff</li> <li><code>.jp2</code>: image/jp2</li> <li><code>.png</code>: image/png</li> <li><code>.pngraw</code>: image/png</li> <li><code>.jpeg</code>: image/jpeg</li> <li><code>.jpg</code>: image/jpg</li> <li><code>.webp</code>: image/webp</li> <li><code>.npy</code>: application/x-binary</li> </ul>"},{"location":"output_format/#numpytile","title":"NumpyTile","text":"<p>While <code>.tif</code> could be interesting, decoding the <code>GeoTIFF</code> format requires non-native/default libraries. Recently, in collaboration with Planet, we started exploring the use of a <code>Numpy-native format</code> to encode the data array.</p> <p>planetlabs/numpytiles-spec</p> <p>This specification attempts to create a standard for representing uncompressed, full bit-depth, raster imagery that can be easily communicated between a server and a client.</p> <p>Example:</p> <pre><code>import numpy\nimport requests\nfrom io import BytesIO\n\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n\nr = requests.get(\"http://127.0.0.1:8000/cog/tiles/14/10818/9146.npy\",\n    params = {\n        \"url\": url,\n    }\n)\ndata = numpy.load(BytesIO(r.content))\nprint(data.shape)\n&gt;&gt;&gt; (4, 256, 256)\n\n# By default titiler will return a concatenated data,mask array.\ndata, mask = data[0:-1], data[-1]\n</code></pre> <p>Notebook: Working_with_NumpyTile</p>"},{"location":"output_format/#jsonresponse","title":"JSONResponse","text":"<p>Sometimes rio-tiler's responses can contain <code>NaN</code>, <code>Infinity</code> or <code>-Infinity</code> values (e.g for Nodata). Sadly there is no proper ways to encode those values in JSON or at least not all web client supports it.</p> <p>In  order to allow TiTiler to return valid responses we added a custom <code>JSONResponse</code> in <code>v0.3.10</code> which will automatically translate <code>float('nan')</code>, <code>float('inf')</code> and <code>float('-inf')</code> to <code>null</code> and thus avoid in valid JSON response.</p> <pre><code>from fastapi import FastAPI\nfrom titiler.core.resources.responses import JSONResponse\n\napp = FastAPI(default_response_class=JSONResponse,)\n\n@app.get(\"/something\")\ndef return_something():\n    return float('nan')\n</code></pre> <p>This <code>JSONResponse</code> is used by default in <code>titiler</code> Tiler Factories where <code>NaN</code> are expected (<code>info</code>, <code>statistics</code> and <code>point</code> endpoints).</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#0190-tbd","title":"0.19.0 (TBD)","text":""},{"location":"release-notes/#misc","title":"Misc","text":"<ul> <li> <p>Removed default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code> and <code>/WMTSCapabilities.xml</code> endpoints breaking change</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>Use <code>@attrs.define</code> instead of dataclass for factories breaking change</p> </li> <li>Use <code>@attrs.define</code> instead of dataclass for factory extensions breaking change</li> </ul>"},{"location":"release-notes/#titilercore","title":"titiler.core","text":"<ul> <li> <p>Improve XSS security for HTML templates (author @jcary741, developmentseed/titiler!953)</p> </li> <li> <p>Remove all default values to the dependencies breaking change</p> <ul> <li><code>DatasetParams.unscale</code>: <code>False</code> -&gt; <code>None</code> (default to <code>False</code> in rio-tiler)</li> <li><code>DatasetParams.resampling_method</code>: <code>nearest</code> -&gt; <code>None</code> (default to <code>nearest</code> in rio-tiler)</li> <li><code>DatasetParams.reproject_method</code>: <code>nearest</code> -&gt; <code>None</code> (default to <code>nearest</code> in rio-tiler)</li> <li><code>ImageRenderingParams.add_mask</code>: <code>True</code> -&gt; <code>None</code> (default to <code>True</code> in rio-tiler)</li> <li><code>StatisticsParams.categorical</code>: <code>False</code> -&gt; <code>None</code> (default to <code>False</code> in rio-tiler)</li> </ul> </li> <li> <p>Add <code>as_dict(exclude_none=True/False)</code> method to the <code>DefaultDependency</code> class.</p> <pre><code>from typing import Optional\nfrom titiler.core.dependencies import DefaultDependency\nfrom dataclasses import dataclass\n\n@dataclass\nclass Deps(DefaultDependency):\n    value: Optional[int] = None\n\nprint({**Deps().__dict__.items()})\n&gt;&gt; {'value': None}\n\nDeps().as_dict()  # `exclude_none` defaults to True\n&gt;&gt; {}\n\nDeps(value=1).as_dict()\n&gt;&gt; {'value': 1}\n</code></pre> </li> <li> <p>fix Hillshade algorithm (bad <code>azimuth</code> angle)</p> </li> <li> <p>set default <code>azimuth</code> and <code>altitude</code> angles to 45\u00ba for the Hillshade algorithm breaking change</p> </li> <li> <p>Use <code>.as_dict()</code> method when passing option to rio-tiler Reader's methods to avoid parameter conflicts when using custom Readers.</p> </li> <li> <p>Renamed <code>BaseTilerFactory</code> to <code>BaseFactory</code> breaking change</p> </li> <li> <p>Removed useless attribute in <code>BaseFactory</code> (and moved them to <code>TilerFactory</code>) breaking change</p> </li> </ul>"},{"location":"release-notes/#titilermosaic","title":"titiler.mosaic","text":"<ul> <li>Renamed <code>reader</code> attribute to <code>backend</code> in <code>MosaicTilerFactory</code> breaking change</li> </ul>"},{"location":"release-notes/#titilerextensions","title":"titiler.extensions","text":"<ul> <li> <p>Encode URL for cog_viewer and stac_viewer (author @guillemc23, developmentseed/titiler!961)</p> </li> <li> <p>Add links for render parameters and <code>/map</code> link to viewer dashboard (author @hrodmn, developmentseed/titiler!987)</p> </li> </ul>"},{"location":"release-notes/#0189-2024-09-23","title":"0.18.9 (2024-09-23)","text":"<ul> <li>fix release 0.18.8</li> </ul>"},{"location":"release-notes/#0188-2024-09-23","title":"0.18.8 (2024-09-23)","text":""},{"location":"release-notes/#titilerextensions_1","title":"titiler.extensions","text":"<ul> <li>Add links for render parameters and /map link to viewer dashboard (author @hrodmn, developmentseed/titiler!987)</li> </ul>"},{"location":"release-notes/#0187-2024-09-19","title":"0.18.7 (2024-09-19)","text":"<ul> <li>fix Hillshade algorithm (bad <code>azimuth</code> angle) (developmentseed/titiler!985) [Backported]</li> <li>Encode URL for cog_viewer and stac_viewer (author @guillemc23, developmentseed/titiler!961) [Backported]</li> <li>Improve XSS security for HTML templates (author @jcary741, developmentseed/titiler!953) [Backported]</li> </ul>"},{"location":"release-notes/#0186-2024-08-27","title":"0.18.6 (2024-08-27)","text":"<ul> <li>Switch back to <code>fastapi</code> instead of <code>fastapi-slim</code> and use <code>&gt;=0.109.0</code> version</li> </ul>"},{"location":"release-notes/#0185-2024-07-03","title":"0.18.5 (2024-07-03)","text":"<ul> <li>Set version requirement for FastAPI to <code>&gt;=0.111.0</code></li> </ul>"},{"location":"release-notes/#0184-2024-06-26","title":"0.18.4 (2024-06-26)","text":"<ul> <li>fix Tiles URL encoding for WMTSCapabilities XML document</li> </ul>"},{"location":"release-notes/#0183-2024-05-20","title":"0.18.3 (2024-05-20)","text":"<ul> <li>fix <code>WMTSCapabilities.xml</code> response for ArcMap compatibility<ul> <li>replace <code>Cloud Optimized GeoTIFF</code> with dataset URL or <code>TiTiler</code> for the ows:ServiceIdentification title</li> <li>replace <code>cogeo</code> with <code>Dataset</code> for the <code>layer</code> ows:Identifier</li> </ul> </li> </ul>"},{"location":"release-notes/#0182-2024-05-07","title":"0.18.2 (2024-05-07)","text":"<ul> <li>move to <code>fastapi-slim</code> to avoid unwanted dependencies (author @n8sty, developmentseed/titiler!815)</li> </ul>"},{"location":"release-notes/#0181-2024-04-12","title":"0.18.1 (2024-04-12)","text":""},{"location":"release-notes/#titilercore_1","title":"titiler.core","text":"<ul> <li>fix <code>TerrainRGB</code> algorithm name (author @JinIgarashi, developmentseed/titiler!804)</li> <li>add more tests for <code>RescalingParams</code> and <code>HistogramParams</code> dependencies</li> <li>make sure to return empty content for <code>204</code> Error code</li> </ul>"},{"location":"release-notes/#0180-2024-03-22","title":"0.18.0 (2024-03-22)","text":""},{"location":"release-notes/#titilercore_2","title":"titiler.core","text":"<ul> <li>Add <code>ColorMapFactory</code> to create colorMap metadata endpoints (developmentseed/titiler!796)</li> <li> <p>Deprecation remove default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code> and <code>/WMTSCapabilities.xml</code> endpoints (developmentseed/titiler!802)</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>Deprecation <code>default_tms</code> attribute in <code>BaseTilerFactory</code> (because <code>tileMatrixSetId</code> is now required in endpoints).</p> </li> </ul>"},{"location":"release-notes/#titilermosaic_1","title":"titiler.mosaic","text":"<ul> <li> <p>Deprecation remove default <code>WebMercatorQuad</code> tile matrix set in <code>/tiles</code>, <code>/tilesjson.json</code>, <code>/map</code> and <code>/WMTSCapabilities.xml</code> endpoints (developmentseed/titiler!802)</p> <pre><code># Before\n/tiles/{z}/{x}/{y}\n/tilejson.json\n/map\n/WMTSCapabilities.xml\n\n# Now\n/tiles/WebMercatorQuad/{z}/{x}/{y}\n/WebMercatorQuad/tilejson.json\n/WebMercatorQuad/map\n/WebMercatorQuad/WMTSCapabilities.xml\n</code></pre> </li> <li> <p>Deprecation <code>default_tms</code> attribute in <code>MosaicTilerFactory</code> (because <code>tileMatrixSetId</code> is now required in endpoints).</p> </li> </ul>"},{"location":"release-notes/#misc_1","title":"Misc","text":"<ul> <li>add <code>request</code> as first argument in <code>TemplateResponse</code> to adapt with latest starlette version</li> </ul>"},{"location":"release-notes/#0173-2024-03-21","title":"0.17.3 (2024-03-21)","text":""},{"location":"release-notes/#titilerapplication","title":"titiler.application","text":"<ul> <li>Add <code>extra=\"ignore\"</code> option <code>ApiSettings</code> to fix pydantic issue when using <code>.env</code> file (author @imanshafiei540, developmentseed/titiler!800)</li> </ul>"},{"location":"release-notes/#0172-2024-03-15","title":"0.17.2 (2024-03-15)","text":""},{"location":"release-notes/#titilercore_3","title":"titiler.core","text":"<ul> <li>fix OpenAPI metadata for algorithm (author @JinIgarashi, developmentseed/titiler!797)</li> </ul>"},{"location":"release-notes/#0171-2024-03-13","title":"0.17.1 (2024-03-13)","text":"<ul> <li>add python 3.12 support</li> </ul>"},{"location":"release-notes/#titilercore_4","title":"titiler.core","text":"<ul> <li>Add <code>use_epsg</code> parameter to WMTS endpoint to resolve ArcMAP issues and fix XML formating (author @gadomski, developmentseed/titiler!782)</li> <li>Add more OpenAPI metadata for algorithm (author @JinIgarashi, developmentseed/titiler!783)</li> </ul>"},{"location":"release-notes/#titilerapplication_1","title":"titiler.application","text":"<ul> <li>fix invalid url parsing in HTML responses</li> </ul>"},{"location":"release-notes/#0170-2024-01-17","title":"0.17.0 (2024-01-17)","text":""},{"location":"release-notes/#titilercore_5","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler</code> version to <code>&gt;6.3.0</code></li> <li>use new <code>align_bounds_with_dataset=True</code> rio-tiler option in GeoJSON statistics methods for more precise calculation</li> </ul>"},{"location":"release-notes/#0162-2024-01-17","title":"0.16.2 (2024-01-17)","text":""},{"location":"release-notes/#titilercore_6","title":"titiler.core","text":"<ul> <li>fix leafletjs template maxZoom to great than 18 for <code>/map</code> endpoint (author @Firefishy, developmentseed/titiler!749)</li> </ul>"},{"location":"release-notes/#0161-2024-01-08","title":"0.16.1 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_7","title":"titiler.core","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method</li> </ul>"},{"location":"release-notes/#titilermosaic_2","title":"titiler.mosaic","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method</li> </ul>"},{"location":"release-notes/#0160-2024-01-08","title":"0.16.0 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_8","title":"titiler.core","text":"<ul> <li>update FastAPI version lower limit to <code>&gt;=0.107.0</code></li> <li>fix template loading for starlette &gt;= 0.28 by using <code>jinja2.Environment</code> argument (author @jasongi, developmentseed/titiler!744)</li> </ul>"},{"location":"release-notes/#titilerextensions_2","title":"titiler.extensions","text":"<ul> <li>fix template loading for starlette &gt;= 0.28 by using <code>jinja2.Environment</code> argument (author @jasongi, developmentseed/titiler!744)</li> </ul>"},{"location":"release-notes/#titilerapplication_2","title":"titiler.application","text":"<ul> <li>fix template loading for starlette &gt;= 0.28 by using <code>jinja2.Environment</code> argument (author @jasongi, developmentseed/titiler!744)</li> </ul>"},{"location":"release-notes/#0158-2024-01-08","title":"0.15.8 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_9","title":"titiler.core","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method [backported from 0.16.1]</li> </ul>"},{"location":"release-notes/#titilermosaic_3","title":"titiler.mosaic","text":"<ul> <li>use morecantile <code>TileMatrixSet.cellSize</code> property instead of deprecated/private <code>TileMatrixSet._resolution</code> method [backported from 0.16.1]</li> </ul>"},{"location":"release-notes/#0157-2024-01-08","title":"0.15.7 (2024-01-08)","text":""},{"location":"release-notes/#titilercore_10","title":"titiler.core","text":"<ul> <li>update FastAPI version upper limit to <code>&lt;0.107.0</code> to avoid starlette breaking change (<code>0.28</code>)</li> </ul>"},{"location":"release-notes/#titilerapplication_3","title":"titiler.application","text":"<ul> <li>add simple auth (optional) based on <code>global_access_token</code> string, set with <code>TITILER_API_GLOBAL_ACCESS_TOKEN</code> environment variable (author @DeflateAwning, developmentseed/titiler!735)</li> </ul>"},{"location":"release-notes/#0156-2023-11-16","title":"0.15.6 (2023-11-16)","text":""},{"location":"release-notes/#titilercore_11","title":"titiler.core","text":"<ul> <li>in <code>/map</code> HTML response, add Lat/Lon buffer to AOI to avoid creating wrong AOI (when data covers the whole world).</li> </ul>"},{"location":"release-notes/#0155-2023-11-09","title":"0.15.5 (2023-11-09)","text":""},{"location":"release-notes/#titilercore_12","title":"titiler.core","text":"<ul> <li> <p>add <code>algorithm</code> options for <code>/statistics</code> endpoints</p> </li> <li> <p>switch from <code>BaseReader.statistics()</code> method to a combination of <code>BaseReader.preview()</code> and <code>ImageData.statistics()</code> methods to get the statistics</p> </li> </ul>"},{"location":"release-notes/#0154-2023-11-06","title":"0.15.4 (2023-11-06)","text":""},{"location":"release-notes/#titilercore_13","title":"titiler.core","text":"<ul> <li> <p>update <code>rio-tiler</code> requirement to <code>&gt;=6.2.5,&lt;7.0</code></p> </li> <li> <p>allow <code>bidx</code> option in <code>titiler.core.dependencies.AssetsBidxExprParams</code> and <code>titiler.core.dependencies.AssetsBidxParams</code></p> <pre><code># merge band 1 form asset1 and asset2\n# before\nhttpx.get(\n    \"/stac/preview\",\n    params=(\n        (\"url\", \"stac.json\"),\n        (\"assets\", \"asset1\"),\n        (\"assets\", \"asset2\"),\n        (\"asset_bidx\", \"asset1|1\"),\n        (\"asset_bidx\", \"asset2|1\"),\n    )\n)\n\n# now\nhttpx.get(\n    \"/stac/preview\",\n    params=(\n        (\"url\", \"stac.json\"),\n        (\"assets\", \"asset1\"),\n        (\"assets\", \"asset2\"),\n        (\"bidx\", 1),\n    )\n)\n</code></pre> </li> <li> <p>fix openapi examples</p> </li> </ul>"},{"location":"release-notes/#0153-2023-11-02","title":"0.15.3 (2023-11-02)","text":"<ul> <li>add <code>dst_crs</code> options in <code>/statistics [POST]</code> and <code>/feature [POST]</code> endpoints</li> </ul>"},{"location":"release-notes/#0152-2023-10-23","title":"0.15.2 (2023-10-23)","text":""},{"location":"release-notes/#titilercore_14","title":"titiler.core","text":"<ul> <li>add <code>dependencies.TileParams</code> dependency with <code>buffer</code> and <code>padding</code> options</li> <li>add <code>tile_dependency</code> attribute in <code>TilerFactory</code> class (defaults to <code>TileParams</code>)</li> <li>add <code>reproject</code> (alias to <code>reproject_method</code>) option in <code>DatasetParams</code> dependency</li> </ul>"},{"location":"release-notes/#titilermosaic_4","title":"titiler.mosaic","text":"<ul> <li>Change <code>HTTP_404_NOT_FOUND</code> to <code>HTTP_204_NO_CONTENT</code> when no asset is found or tile is empty (author @simouel, developmentseed/titiler!713)</li> <li>add <code>tile_dependency</code> attribute in <code>MosaicTilerFactory</code> class (defaults to <code>TileParams</code>)</li> </ul>"},{"location":"release-notes/#cdk-application","title":"cdk application","text":"<ul> <li>Support non-root paths in AWS API Gateway Lambda handler (author @DanSchoppe, developmentseed/titiler!716)</li> </ul>"},{"location":"release-notes/#0151-2023-10-17","title":"0.15.1 (2023-10-17)","text":"<ul> <li>Allow a default <code>color_formula</code> parameter to be set via a dependency (author @samn, developmentseed/titiler!707)</li> <li>add <code>titiler.core.dependencies.create_colormap_dependency</code> to create ColorMapParams dependency from <code>rio_tiler.colormap.ColorMaps</code> object</li> <li>add <code>py.typed</code> files in titiler submodules (peps.python.org/pep-0561)</li> </ul>"},{"location":"release-notes/#0150-2023-09-28","title":"0.15.0 (2023-09-28)","text":""},{"location":"release-notes/#titilercore_15","title":"titiler.core","text":"<ul> <li>added <code>PartFeatureParams</code> dependency</li> </ul> <p>breaking changes</p> <ul> <li> <p><code>max_size</code> is now set to <code>None</code> for <code>/statistics [POST]</code>, <code>/bbox</code> and <code>/feature</code> endpoints, meaning the tiler will create image from the highest resolution.</p> </li> <li> <p>renamed <code>titiler.core.dependencies.ImageParams</code> to <code>PreviewParams</code></p> </li> <li> <p>split TileFactory <code>img_dependency</code> attribute in two:</p> </li> <li> <p><code>img_preview_dependency</code>: used in <code>/preview</code> and <code>/statistics [GET]</code>, default to <code>PreviewParams</code> (with <code>max_size=1024</code>)</p> </li> <li> <p><code>img_part_dependency</code>: used in <code>/bbox</code>, <code>/feature</code> and <code>/statistics [POST]</code>, default to <code>PartFeatureParams</code> (with <code>max_size=None</code>)</p> </li> <li> <p>renamed <code>/crop</code> endpoints to <code>/bbox/...</code> or <code>/feature/...</code></p> </li> <li> <p><code>/crop/{minx},{miny},{maxx},{maxy}.{format}</code> -&gt; <code>/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> </li> <li> <p><code>/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code> -&gt; <code>/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> </li> <li> <p><code>/crop [POST]</code> -&gt; <code>/feature [POST]</code></p> </li> <li> <p><code>/crop.{format} [POST]</code> -&gt; <code>/feature.{format} [POST]</code></p> </li> <li> <p><code>/crop/{width}x{height}.{format}  [POST]</code> -&gt; <code>/feature/{width}x{height}.{format} [POST]</code></p> </li> <li> <p>update <code>rio-tiler</code> requirement to <code>&gt;=6.2.1</code></p> </li> <li> <p>Take coverage weights in account when generating statistics from GeoJSON features</p> </li> </ul>"},{"location":"release-notes/#0141-2023-09-14","title":"0.14.1 (2023-09-14)","text":""},{"location":"release-notes/#titilerextension","title":"titiler.extension","text":"<ul> <li>add <code>GetFeatureInfo</code> capability in <code>wmsExtension</code> (author @benjaminleighton, developmentseed/titiler!698)</li> </ul>"},{"location":"release-notes/#0140-2023-08-30","title":"0.14.0 (2023-08-30)","text":""},{"location":"release-notes/#titilercore_16","title":"titiler.core","text":"<ul> <li>replace <code>-</code> by <code>_</code> in query parameters breaking change</li> <li><code>coord-crs</code> -&gt; <code>coord_crs</code></li> <li> <p><code>dst-crs</code> -&gt; <code>dst_crs</code></p> </li> <li> <p>replace <code>buffer</code> and <code>color_formula</code> endpoint parameters by external dependencies (<code>BufferParams</code> and <code>ColorFormulaParams</code>)</p> </li> <li> <p>add <code>titiler.core.utils.render_image</code> which allow non-binary alpha band created with custom colormap. <code>render_image</code> replace <code>ImageData.render</code> method.</p> <pre><code># before\nif cmap := colormap or dst_colormap:\n    image = image.apply_colormap(cmap)\n\nif not format:\n    format = ImageType.jpeg if image.mask.all() else ImageType.png\n\ncontent = image.render(\n    img_format=format.driver,\n    **format.profile,\n    **render_params,\n)\n\n# now\n# render_image will:\n# - apply the colormap\n# - choose the right output format if `None`\n# - create the binary data\ncontent, media_type = render_image(\n    image,\n    output_format=format,\n    colormap=colormap or dst_colormap,\n    **render_params,\n)\n</code></pre> </li> </ul>"},{"location":"release-notes/#titilerextension_1","title":"titiler.extension","text":"<ul> <li>rename <code>geom-densify-pts</code> to <code>geometry_densify</code> breaking change</li> <li>rename <code>geom-precision</code> to <code>geometry_precision</code> breaking change</li> </ul>"},{"location":"release-notes/#0133-2023-08-27","title":"0.13.3 (2023-08-27)","text":"<ul> <li>fix Factories <code>url_for</code> method and avoid changing <code>Request.path_params</code> object</li> </ul>"},{"location":"release-notes/#0132-2023-08-24","title":"0.13.2 (2023-08-24)","text":""},{"location":"release-notes/#titilerextensions_3","title":"titiler.extensions","text":"<ul> <li>replace mapbox-gl by maplibre</li> <li>replace Stamen by OpenStreetMap tiles</li> <li>simplify band selection handling (author @tayden, developmentseed/titiler!688)</li> </ul>"},{"location":"release-notes/#0131-2023-08-21","title":"0.13.1 (2023-08-21)","text":""},{"location":"release-notes/#titilercore_17","title":"titiler.core","text":"<ul> <li>fix <code>LowerCaseQueryStringMiddleware</code> unexpectedly truncating query parameters (authors @jthetzel and @jackharrhy, @developmentseed/titiler!677)</li> </ul>"},{"location":"release-notes/#titilerapplication_4","title":"titiler.application","text":"<ul> <li>add <code>cors_allow_methods</code> in <code>ApiSettings</code> to control the CORS allowed methods (author @ubi15, developmentseed/titiler!684)</li> </ul>"},{"location":"release-notes/#0130-2023-07-27","title":"0.13.0 (2023-07-27)","text":"<ul> <li>update core requirements to libraries using pydantic ~=2.0</li> </ul>"},{"location":"release-notes/#titilercore_18","title":"titiler.core","text":"<ul> <li>update requirements:</li> <li>fastapi <code>&gt;=0.95.1</code> \u2192 <code>&gt;=0.100.0</code></li> <li>pydantic <code>~=1.0</code> \u2192 <code>~=2.0</code></li> <li>rio-tiler <code>&gt;=5.0,&lt;6.0</code> \u2192 <code>&gt;=6.0,&lt;7.0</code></li> <li>morecantile<code>&gt;=4.3,&lt;5.0</code> \u2192 <code>&gt;=5.0,&lt;6.0</code></li> <li>geojson-pydantic <code>&gt;=0.4,&lt;0.7</code> \u2192 <code>&gt;=1.0,&lt;2.0</code></li> <li>typing_extensions <code>&gt;=4.6.1</code></li> </ul>"},{"location":"release-notes/#titilerextension_2","title":"titiler.extension","text":"<ul> <li>update requirements:</li> <li>rio-cogeo <code>&gt;=4.0,&lt;5.0\"</code> \u2192 <code>&gt;=5.0,&lt;6.0\"</code></li> </ul>"},{"location":"release-notes/#titilermosaic_5","title":"titiler.mosaic","text":"<ul> <li>update requirements:</li> <li>cogeo-mosaic <code>&gt;=6.0,&lt;7.0</code> \u2192 <code>&gt;=7.0,&lt;8.0</code></li> </ul>"},{"location":"release-notes/#titilerapplication_5","title":"titiler.application","text":"<ul> <li>use <code>/api</code> and <code>/api.html</code> for documentation (instead of <code>/openapi.json</code> and <code>/docs</code>)</li> <li>update landing page</li> </ul>"},{"location":"release-notes/#0120-2023-07-17","title":"0.12.0 (2023-07-17)","text":"<ul> <li>use <code>Annotated</code> Type for Query/Path parameters</li> <li>replace variable <code>TileMatrixSetId</code> by <code>tileMatrixSetId</code></li> </ul>"},{"location":"release-notes/#titilercore_19","title":"titiler.core","text":"<ul> <li>update FastAPI dependency to <code>&gt;=0.95.1</code></li> <li>set <code>pydantic</code> dependency to <code>~=1.0</code></li> <li>update <code>rio-tiler</code> dependency to <code>&gt;=5.0,&lt;6.0</code></li> <li>update TMS endpoints to match OGC Tiles specification</li> </ul>"},{"location":"release-notes/#titilerextensions_4","title":"titiler.extensions","text":"<ul> <li>use TiTiler's custom JSONResponse for the <code>/validate</code> endpoint to avoid issue when COG has <code>NaN</code> nodata value</li> <li>update <code>rio-cogeo</code> dependency to <code>&gt;=4.0,&lt;5.0</code></li> <li>update <code>rio-stac</code> requirement to <code>&gt;=0.8,&lt;0.9</code> and add <code>geom-densify-pts</code> and <code>geom-precision</code> options</li> </ul>"},{"location":"release-notes/#titilermosaic_6","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> dependency to <code>&gt;=6.0,&lt;7.0</code></li> <li>remove <code>titiler.mosaic.resources.enum.PixelSelectionMethod</code> and use <code>rio_tiler.mosaic.methods.PixelSelectionMethod</code></li> <li>allow more TileMatrixSet (than only <code>WebMercatorQuad</code>)</li> </ul>"},{"location":"release-notes/#0117-2023-05-18","title":"0.11.7 (2023-05-18)","text":""},{"location":"release-notes/#titilercore_20","title":"titiler.core","text":"<ul> <li>make HTML <code>templates</code> configurable in the factories</li> <li>rename <code>index.html</code> to <code>map.html</code></li> <li>rename <code>dependencies.CRSParams</code> to <code>dependencies.CoordCRSParams</code></li> <li>add <code>dst-crs</code> option for <code>/preview</code> and <code>/crop</code> endpoints to specify the output Coordinate Reference System.</li> </ul>"},{"location":"release-notes/#titilermosaic_7","title":"titiler.mosaic","text":"<ul> <li>make HTML <code>templates</code> configurable in the factories</li> </ul>"},{"location":"release-notes/#titilerextensions_5","title":"titiler.extensions","text":"<ul> <li>make HTML <code>templates</code> configurable in the factories</li> <li>rename <code>cog_index.html</code> to <code>cog_viewer.html</code></li> <li>rename <code>stac_index.html</code> to <code>stac_viewer.html</code></li> <li>add <code>zoom to point</code> in <code>stac</code> and <code>cog</code> viewers (author @dchirst, developmentseed/titiler!614)</li> </ul>"},{"location":"release-notes/#0116-2023-04-14","title":"0.11.6 (2023-04-14)","text":"<ul> <li>Allow a default <code>rescale</code> parameter to be set via a dependency (author @samn, developmentseed/titiler!619)</li> <li>add <code>coord-crs</code> parameter for <code>/point</code>, <code>/part</code> and <code>/feature</code> endpoints</li> </ul>"},{"location":"release-notes/#0115-2023-03-22","title":"0.11.5 (2023-03-22)","text":"<ul> <li>fix <code>TerrainRGB</code> (change interval from <code>1.0</code> to <code>0.1</code>)</li> </ul>"},{"location":"release-notes/#0114-2023-03-20","title":"0.11.4 (2023-03-20)","text":"<ul> <li>set FastAPI version lower than 0.95 (tiangolo/fastapi?9278)</li> </ul>"},{"location":"release-notes/#0113-2023-03-14","title":"0.11.3 (2023-03-14)","text":"<ul> <li>handle dateline crossing dataset in COG/STAC Viewer</li> <li>update Factories <code>url_for</code> method to make sure we return a string (developmentseed/titiler!607)</li> </ul>"},{"location":"release-notes/#0112-2023-03-08","title":"0.11.2 (2023-03-08)","text":"<ul> <li>Add OSM background in <code>/map</code> viewer when using WebMercator TMS</li> </ul>"},{"location":"release-notes/#0111-2023-03-01","title":"0.11.1 (2023-03-01)","text":"<ul> <li>no change since 0.11.1a0</li> </ul>"},{"location":"release-notes/#0111a0-2023-03-01","title":"0.11.1a0 (2023-03-01)","text":"<ul> <li>switch to <code>hatch</code> and <code>pdm-pep517</code> as build system and use <code>pyproject.toml</code> for python module metadata</li> <li>switch to <code>ruff</code> for python linting</li> <li>update pre-commit configuration</li> <li>documentation fixes \ud83d\ude4f (authors @jthetzel, @neilsh)</li> <li>fix documentation about <code>asset_bidx</code></li> </ul>"},{"location":"release-notes/#titilercore_21","title":"titiler.core","text":"<ul> <li>Algorithm change, make terrainrgb interval and baseval floats to support more quantizers (author @AndrewAnnex, developmentseed/titiler!587)</li> <li>update <code>rio-tiler</code> minimum version to <code>4.1.6</code></li> <li>Apply colormap before defining image output format (when not provided)</li> </ul>"},{"location":"release-notes/#titilermosaic_8","title":"titiler.mosaic","text":"<ul> <li>Apply colormap before defining image output format (when not provided)</li> </ul>"},{"location":"release-notes/#0110-2023-01-27","title":"0.11.0 (2023-01-27)","text":"<ul> <li>add <code>titiler.extensions</code> package (<code>cogValidateExtension</code>, <code>stacExtension</code>, <code>cogViewerExtension</code>,  <code>stacViewerExtension</code>, <code>wmsExtension</code>)</li> </ul>"},{"location":"release-notes/#titilermosaic_9","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version requirement to <code>&gt;=5.0,&lt;5.2</code> (allow using <code>az://</code> prefix from uri)</li> <li>add <code>MOSAIC_STRICT_ZOOM</code> environment variable to control if the application should allow fetching tiles outside mosaic min/max zooms</li> </ul> <p>breaking change</p>"},{"location":"release-notes/#titilercore_22","title":"titiler.core","text":"<ul> <li>add <code>extensions</code> option to the <code>BaseTilerFactory</code> to specify a list of extension we want to register. Each extension will be then registered in the <code>__post_init__</code> object creation step.</li> <li>remove <code>BaseHTTPMiddleware</code> class inheritance for middleware (write pure ASGI middleware)</li> </ul>"},{"location":"release-notes/#titilerapplication_6","title":"titiler.application","text":"<ul> <li>uses Extension to add more endpoints to default <code>titiler.core</code> factories</li> <li>move all <code>viewer</code> code into <code>titiler.extensions</code></li> <li>add <code>/cog/stac</code> endpoint from <code>titiler.extension.stacExtension</code> to create STAC Items from raster dataset</li> </ul>"},{"location":"release-notes/#titilermosaic_10","title":"titiler.mosaic","text":"<ul> <li>removed deprecated empty path (<code>/</code> is the correct route path, which enable prefixed and non-prefixed mosaic application)</li> </ul>"},{"location":"release-notes/#0102-2022-12-17","title":"0.10.2 (2022-12-17)","text":"<ul> <li>fix issue with new morecantile version</li> <li>replace path parameter in <code>router_prefix</code> in <code>BaseTilerFactory.url_for</code></li> </ul>"},{"location":"release-notes/#0101-2022-12-15","title":"0.10.1 (2022-12-15)","text":"<ul> <li>update <code>/map</code> endpoint and template to support multiple TMS (developmentseed/titiler!560)</li> </ul>"},{"location":"release-notes/#0100-2022-12-09","title":"0.10.0 (2022-12-09)","text":"<p>breaking change</p> <ul> <li>Simplify dependency requirements for titiler.mosaic and titiler.application and using <code>=={currentVersion}</code></li> </ul>"},{"location":"release-notes/#titilercore_23","title":"titiler.core","text":"<ul> <li>fix the <code>wmts.xml</code> template to work with non-epsg based CRS</li> </ul>"},{"location":"release-notes/#titilerapplication_7","title":"titiler.application","text":"<ul> <li>fix titiler.application viewer when using dataset with band name in metadata</li> </ul>"},{"location":"release-notes/#090-2022-12-05","title":"0.9.0 (2022-12-05)","text":""},{"location":"release-notes/#titilercore_24","title":"titiler.core","text":"<ul> <li>add <code>default_tms</code> in <code>BaseTilerFactory</code> to set the default TMS identifier supported by the tiler (e.g <code>WebMercatorQuad</code>)</li> </ul>"},{"location":"release-notes/#081-2022-12-01","title":"0.8.1 (2022-12-01)","text":""},{"location":"release-notes/#titilercore_25","title":"titiler.core","text":"<ul> <li>remove useless <code>titiler.core.version</code> file</li> </ul>"},{"location":"release-notes/#080-2022-12-01","title":"0.8.0 (2022-12-01)","text":"<ul> <li>remove python 3.7 support</li> <li>add python 3.10 and 3.11 in CI</li> </ul>"},{"location":"release-notes/#titilercore_26","title":"titiler.core","text":"<ul> <li>update FastAPI requirement to <code>&gt;=0.87</code></li> <li>update rio-tiler requirement to <code>&gt;=4.1,&lt;4.2</code></li> <li>remove <code>rescale</code> and <code>color_formula</code> from the <code>post_process</code> dependency</li> <li>add <code>algorithm</code> support and introduce new <code>algorithm</code> and <code>algorithm_params</code> query parameters</li> </ul> <p>breaking changes</p> <ul> <li>remove <code>timing headers</code> and <code>titiler.core.utils</code> submodule</li> <li>remove <code>asset_expression</code> (except in <code>/asset_statistics</code> endpoint) (see cogeotiff.github.io/rio-tiler/v4_migration/#multibasereader-expressions)</li> <li>update Point output model to include <code>band_names</code></li> <li>histogram and info band names are prefixed with <code>b</code> (e.g <code>b1</code>) (ref: cogeotiff.github.io/rio-tiler/v4_migration/#band-names)</li> <li>add <code>/map</code> endpoint in TilerFactory to display tiles given query-parameters</li> <li>remove <code>TMSParams</code> and <code>WebMercatorTMSParams</code> dependencies.</li> <li>replace <code>TilerFactory.tms_dependency</code> attribute by <code>TilerFactory.supported_tms</code>. This attribute gets a <code>morecantile.defaults.TileMatrixSets</code> store and will create the tms dependencies dynamically</li> <li>replace <code>TMSFactory.tms_dependency</code> attribute by <code>TMSFactory.supported_tms</code>. This attribute gets a <code>morecantile.defaults.TileMatrixSets</code> store and will create the tms dependencies dynamically</li> <li>move <code>stats_dependency</code> and <code>histogram_dependency</code> from <code>BaseTilerFactory</code> to <code>TilerFactory</code></li> <li>per rio-tiler changes, <code>;</code> has be to used in expression to indicate multiple bands. <code>b1*2,b2+b3,b1/b3</code> -&gt; <code>b1*2;b2+b3;b1/b3</code></li> </ul>"},{"location":"release-notes/#titilermosaic_11","title":"titiler.mosaic","text":"<ul> <li>update cogeo-mosaic requirement to <code>&gt;=4.2,&lt;4.3</code></li> </ul> <p>breaking changes</p> <ul> <li>remove <code>timing headers</code></li> <li>replace <code>MosaicTilerFactory.tms_dependency</code> attribute by <code>MosaicTilerFactory.supported_tms</code>. This attribute gets a <code>morecantile.defaults.TileMatrixSets</code> store and will create the tms dependencies dynamically</li> </ul>"},{"location":"release-notes/#titilerapplication_8","title":"titiler.application","text":"<ul> <li>code simplification by removing custom code and submodules from endpoints</li> </ul> <p>breaking changes</p> <ul> <li>remove custom TMS and custom Colormap dependencies</li> <li>remove middleware submodule</li> </ul>"},{"location":"release-notes/#071-2022-09-21","title":"0.7.1 (2022-09-21)","text":""},{"location":"release-notes/#titilermosaic_12","title":"titiler.mosaic","text":"<ul> <li>add <code>pixel_selection_dependency</code> options in <code>MosaicTilerFactory</code> to allow default method override (author @samn, developmentseed/titiler!495)</li> </ul>"},{"location":"release-notes/#titilerapplication_9","title":"titiler.application","text":"<ul> <li>allow <code>interval</code> colormaps in titiler.application</li> </ul>"},{"location":"release-notes/#helm-charts","title":"Helm charts","text":"<ul> <li>Check Charts workflow added for the Helm charts testing (author @emmanuelmathot, developmentseed/titiler!495)</li> </ul>"},{"location":"release-notes/#070-2022-06-08","title":"0.7.0 (2022-06-08)","text":"<ul> <li>add <code>environment_dependency</code> option in <code>BaseTilerFactory</code> to define GDAL environment at runtime.</li> <li>remove <code>gdal_config</code> option in <code>BaseTilerFactory</code> breaking</li> </ul> <pre><code># before\nrouter = TilerFactory(gdal_config={\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"}).router\n\n# now\nrouter = TilerFactory(environment_dependency=lambda: {\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"}).router\n\n\nclass ReaddirType(str, Enum):\n\n    false = \"false\"\n    true = \"true\"\n    empty_dir = \"empty_dir\"\n\n\n# or at endpoint call. The user could choose between false/true/empty_dir\ndef gdal_env(disable_read: ReaddirType = Query(ReaddirType.false)):\n    return {\"GDAL_DISABLE_READDIR_ON_OPEN\": disable_read.value.upper()}\n\nrouter = TilerFactory(environment_dependency=gdal_env).router\n</code></pre>"},{"location":"release-notes/#titilerapplication_10","title":"titiler.application","text":"<ul> <li>update <code>starlette-cramjam</code> requirement</li> </ul>"},{"location":"release-notes/#060-2022-05-13","title":"0.6.0 (2022-05-13)","text":"<ul> <li>no change since <code>0.6.0a2</code></li> </ul>"},{"location":"release-notes/#060a2-2022-05-11","title":"0.6.0a2 (2022-05-11)","text":"<ul> <li>revert to <code>setup.py</code> + <code>setuptools</code> instead of <code>pyproject.toml</code> + <code>flit</code> because it broke namespace packages (developmentseed/titiler!472)</li> </ul>"},{"location":"release-notes/#060a1-2022-05-11","title":"0.6.0a1 (2022-05-11)","text":""},{"location":"release-notes/#titilercore_27","title":"titiler.core","text":"<ul> <li>remove logging in error <code>exception_handler_factory</code></li> <li>add optional <code>reader_dependency</code> to enable passing <code>Reader</code>'s option defined by Query/Header/Path parameters.</li> <li>switch to <code>pyproject.toml</code></li> <li>move version definition in <code>titiler.core.__version__</code> breaking</li> <li>Include all values for a query param in <code>LowerCaseQueryStringMiddleware</code> (author @samn, developmentseed/titiler!464)</li> </ul>"},{"location":"release-notes/#titilermosaic_13","title":"titiler.mosaic","text":"<ul> <li>add optional <code>backend_dependency</code> to enable passing <code>Backend</code>'s option defined by Query/Header/Path parameters.</li> <li>remove <code>backend_options</code> MosaicTilerFactory argument in favor of the use of <code>backend_dependency</code> breaking</li> <li>switch to <code>pyproject.toml</code></li> <li>move version definition in <code>titiler.mosaic.__version__</code> breaking</li> </ul>"},{"location":"release-notes/#titilerapplication_11","title":"titiler.application","text":"<ul> <li>Fix frontend to handle anti-meridian crossing data</li> <li>switch to <code>pyproject.toml</code></li> <li>move version definition in <code>titiler.application.__version__</code> breaking</li> </ul>"},{"location":"release-notes/#051-2022-03-07","title":"0.5.1 (2022-03-07)","text":"<ul> <li>add <code>cachecontrol_max_http_code</code> option to <code>CacheControlMiddleware</code> to avoid adding cache-control headers for API errors (Author @sharkinsspatial, developmentseed/titiler!444)</li> </ul>"},{"location":"release-notes/#050-2022-02-22","title":"0.5.0 (2022-02-22)","text":"<ul> <li>update rio-tiler/morecantile/rio-cogeo/cogeo-mosaic versions</li> <li>add MultiBaseTilerFactory <code>/asset_statistics</code> which will return per asset statistics. Returns response in form of <code>Dict[{asset name}, Dict[{band name}, BandStatistics]]</code></li> </ul> <p>breaking change</p> <ul> <li>Multi-band expression now uses semicolon <code>;</code> instead of colon (<code>,</code>) as separator. Note: proper urlencoding might be needed.</li> </ul> <pre><code># before\nexpression = \"b1+b2,b2\"\n\n# new\nexpression = \"b1+b2;b2\"\n</code></pre> <ul> <li>MultiBaseTilerFactory <code>/statistics</code> now returns merged statistics in form of <code>Dict[{asset_band or expression}, BandStatistics]</code> (instead of <code>Dict[{asset name}, Dict[{band name}, BandStatistics]]</code>)</li> </ul> <pre><code># before\nresponse = httpx.get(f\"/stac/statistics?url=item.json\").json()\nprint(response)\n&gt;&gt;&gt; {\n    \"asset1\": {\n        \"1\": {\n            \"min\": ...,\n            \"max\": ...,\n            ...\n        },\n        \"2\": {\n            \"min\": ...,\n            \"max\": ...,\n            ...\n        }\n    }\n}\n\n# now\nresponse = httpx.get(f\"/stac/statistics?url=item.json\").json()\nprint(response)\n&gt;&gt;&gt; {\n    \"asset1_1\": {\n        \"min\": ...,\n        \"max\": ...,\n        ...\n    },\n    \"asset1_2\": {\n        \"min\": ...,\n        \"max\": ...,\n        ...\n    },\n}\n</code></pre>"},{"location":"release-notes/#043-2022-02-08","title":"0.4.3 (2022-02-08)","text":"<ul> <li>add tile <code>buffer</code> option to match rio-tiler tile options (developmentseed/titiler!427)</li> </ul>"},{"location":"release-notes/#042-2022-01-25","title":"0.4.2 (2022-01-25)","text":""},{"location":"release-notes/#titilercore_28","title":"titiler.core","text":"<ul> <li>update minimum FastAPI version to <code>&gt;=0.73</code> (developmentseed/titiler!425)</li> </ul>"},{"location":"release-notes/#041-2022-01-25","title":"0.4.1 (2022-01-25)","text":""},{"location":"release-notes/#titilercore_29","title":"titiler.core","text":"<ul> <li>update type information for the factory <code>colormap_dependency</code></li> </ul>"},{"location":"release-notes/#k8s","title":"k8s","text":"<ul> <li>Update ingress k8s templates to be compatible with latest resource types versions (developmentseed/titiler!425</li> </ul>"},{"location":"release-notes/#040-2021-11-30","title":"0.4.0 (2021-11-30)","text":"<ul> <li>rename <code>Dockerfile</code> to <code>Dockerfile.gunicorn</code></li> <li>switch default docker image to python3.9</li> <li>add <code>Dockerfile.uvicorn</code></li> </ul>"},{"location":"release-notes/#titilercore_30","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler</code> version requirement to <code>&gt;=3.0</code></li> </ul>"},{"location":"release-notes/#titilermosaic_14","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version to <code>&gt;=4.0</code></li> </ul>"},{"location":"release-notes/#040a2-2021-11-24","title":"0.4.0a2 (2021-11-24)","text":""},{"location":"release-notes/#titilercore_31","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler</code> version (&gt;=3.0.0a6) with new colormap types information and base classes</li> <li>remove <code>additional_dependency</code> attribute in <code>BaseTileFactory</code>. This also remove <code>**kwargs</code> in endpoints breaking</li> <li>remove <code>reader_options</code> attribute in <code>BaseTileFactory</code> breaking</li> <li><code>tms_dependency</code> default to <code>titiler.core.dependencies.TMSParams</code> which should supports all morecantile's TMS.</li> <li>add <code>route_dependencies</code> attribute to <code>BaseTilerFactory</code> to allow customizing route dependencies (author @alukach, developmentseed/titiler!406)</li> </ul>"},{"location":"release-notes/#titilermosaic_15","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version (&gt;=4.0.0a2) with updated Backend type hints information</li> </ul>"},{"location":"release-notes/#040a1-2021-11-12","title":"0.4.0a1 (2021-11-12)","text":"<ul> <li>fix titiler packages cross dependencies</li> </ul>"},{"location":"release-notes/#040a0-2021-11-12","title":"0.4.0a0 (2021-11-12)","text":"<ul> <li>remove python 3.6 supports (related to morecantile/pyproj update)</li> </ul>"},{"location":"release-notes/#titilercore_32","title":"titiler.core","text":"<ul> <li>update <code>rio-tiler/morecantile</code> requirement (&gt;=3.0)</li> <li>remove <code>utils.bbox_to_feature</code> (replaced by geojson_pydantic native function <code>Feature(geometry=Polygon.from_bounds(*bounds), properties=info)</code>)</li> <li>remove <code>utils.data_stats</code> (replaced by rio-tiler new statistics method)</li> <li>remove <code>metadata</code> endpoints  breaking API</li> <li>update <code>statistics</code> endpoints with histogram options</li> <li>update <code>statistics</code> endpoint responses breaking API</li> <li>remove <code>band_expression</code> in <code>BandsExprParams</code> dependency breaking API</li> <li>remove <code>morecantile</code> requirement definition in setup.py and defers to rio-tiler supported version</li> <li>update <code>titiler.core.dependencies.DefaultDependency</code> (allows dict unpacking and remove <code>.kwargs</code>) breaking API</li> <li>use standard for List in QueryParameter (e.g <code>bidx=1&amp;bidx=2&amp;bidx</code> instead of <code>bidx=1,2,3</code>) breaking API</li> <li>add <code>asset_bidx</code> query parameter in replacement of <code>bidx</code> in MultiBaseFactory dependencies and switch to new format: <code>{asset name}|{bidx,bidx,bidx}</code> breaking API</li> <li>update <code>asset_expression</code> to the new format: <code>{asset name}|{expression}</code> (e.g <code>data|b1+b2</code>) breaking API</li> <li>update <code>assets</code> QueryParameter to List (e.g <code>assets=COG&amp;assets=Data</code>) breaking API</li> <li>update <code>bands</code> QueryParameter to List (e.g <code>bands=B01&amp;bands=B02</code>) breaking API</li> <li>split <code>RenderParams</code> dependency into:<ul> <li><code>PostProcessParams</code>: <code>rescale</code> and <code>color_formula</code> parameters</li> <li><code>ImageRenderingParams</code>: <code>return_mask</code></li> </ul> </li> <li>add <code>process_dependency</code> attribute in <code>BaseTilerFactory</code> (defaults to <code>PostProcessParams</code>)</li> <li>use <code>resampling</code> alias instead of <code>resampling_method</code> for QueryParameter breaking API</li> <li>defaults to available assets if <code>assets</code> option is not provided for <code>MultiBaseTilerFactory</code> info and statistics endpoints.</li> <li>defaults to available bands if <code>bands</code> option is not provided for <code>MultiBandsTilerFactory</code> info and statistics endpoints.</li> <li>better output models definition</li> <li>keep <code>bounds</code>, <code>minzoom</code> and <code>maxzoom</code> in <code>/info</code> response</li> <li>remove <code>dataset</code> in <code>/info</code> response to better follow the Info model</li> <li>add <code>/statistics</code> endpoint by default</li> </ul>"},{"location":"release-notes/#titilermosaic_16","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> requirement (&gt;=4.0)</li> <li>update response from <code>/info</code> endpoint to match the model.</li> </ul>"},{"location":"release-notes/#titilerapplication_12","title":"titiler.application","text":"<ul> <li>update viewers to match changes in titiler.core endpoints</li> </ul>"},{"location":"release-notes/#0312-2021-10-20","title":"0.3.12 (2021-10-20)","text":""},{"location":"release-notes/#titilercore_33","title":"titiler.core","text":"<ul> <li>Update morecantile requirement to stay under <code>3.0</code> (author @robintw, developmentseed/titiler!389)</li> </ul>"},{"location":"release-notes/#0311-2021-10-07","title":"0.3.11 (2021-10-07)","text":""},{"location":"release-notes/#titilerapplication_13","title":"titiler.application","text":"<ul> <li>Update rio-cogeo requirement to stay under <code>3.0</code></li> </ul>"},{"location":"release-notes/#0310-2021-09-23","title":"0.3.10 (2021-09-23)","text":""},{"location":"release-notes/#titilercore_34","title":"titiler.core","text":"<ul> <li>add custom JSONResponse using simplejson to allow NaN/inf/-inf values (ref: developmentseed/titiler!374)</li> <li>use <code>titiler.core.resources.responses.JSONResponse</code> as default response for <code>info</code>, <code>metadata</code>, <code>statistics</code> and <code>point</code> endpoints (ref: developmentseed/titiler!374)</li> </ul>"},{"location":"release-notes/#titilerapplication_14","title":"titiler.application","text":"<ul> <li>switch to <code>starlette_cramjam</code> compression middleware (ref: developmentseed/titiler#369)</li> </ul>"},{"location":"release-notes/#039-2021-09-07","title":"0.3.9 (2021-09-07)","text":""},{"location":"release-notes/#titilercore_35","title":"titiler.core","text":"<ul> <li>update FastAPI requirements to <code>&gt;=0.65,&lt;0.68</code> (ref: developmentseed/titiler#366)</li> <li>surface <code>asset_expression</code> and <code>band_expression</code> in Multi*TilerFactory (ref: developmentseed/titiler#367)</li> </ul>"},{"location":"release-notes/#038-2021-09-02","title":"0.3.8 (2021-09-02)","text":""},{"location":"release-notes/#titilercore_36","title":"titiler.core","text":"<ul> <li>move <code>titiler.application.middleware</code> to <code>titiler.core.middleware</code> (developmentseed/titiler!365)</li> </ul>"},{"location":"release-notes/#037-2021-09-01","title":"0.3.7 (2021-09-01)","text":""},{"location":"release-notes/#titilercore_37","title":"titiler.core","text":"<ul> <li>Update the TileJSON model for better validation and to match with the specification (center is optional) (developmentseed/titiler!363)</li> </ul>"},{"location":"release-notes/#036-2021-08-23","title":"0.3.6 (2021-08-23)","text":""},{"location":"release-notes/#titilercore_38","title":"titiler.core","text":"<ul> <li>fix morecantile related tests (developmentseed/titiler#358)</li> <li>fix float parsing when datatype is float32 (developmentseed/rio-viz#39)</li> </ul>"},{"location":"release-notes/#titilerapplication_15","title":"titiler.application","text":"<ul> <li>fix morecantile related tests (developmentseed/titiler#358)</li> </ul>"},{"location":"release-notes/#035-2021-08-17","title":"0.3.5 (2021-08-17)","text":""},{"location":"release-notes/#titilermosaic_17","title":"titiler.mosaic","text":"<ul> <li>add <code>/{z}/{x}/{y}/assets</code>, <code>/{lon},{lat}/assets</code>, <code>/{minx},{miny},{maxx},{maxy}/assets</code> GET endpoints to return a list of assets that intersect a given geometry (author @mackdelany, developmentseed/titiler!351)</li> </ul>"},{"location":"release-notes/#034-2021-08-02-not-published-on-pypi-355","title":"0.3.4 (2021-08-02) - Not published on PyPi #355","text":""},{"location":"release-notes/#titilercore_39","title":"titiler.core","text":"<ul> <li>add <code>/crop</code> POST endpoint to return an image from a GeoJSON feature (developmentseed/titiler!339)</li> <li>add <code>/statistics</code> (GET and POST) endpoints to return advanced images statistics (developmentseed/titiler!347)</li> </ul>"},{"location":"release-notes/#titilerapplication_16","title":"titiler.application","text":"<ul> <li>add optional <code>root_path</code> setting to specify a url path prefix to use when running the app behind a reverse proxy (developmentseed/titiler!343)</li> </ul>"},{"location":"release-notes/#033-2021-06-29-not-published-on-pypi-355","title":"0.3.3 (2021-06-29) - Not published on PyPi #355","text":""},{"location":"release-notes/#titilercore_40","title":"titiler.core","text":"<ul> <li>fix possible bug when querystring parameter are case insensitive (developmentseed/titiler!323)</li> </ul>"},{"location":"release-notes/#titilermosaic_18","title":"titiler.mosaic","text":"<ul> <li>update <code>tilejson</code> and <code>WMTSCapabilities.xml</code> endpoints to allow list querystrings (as done previously in developmentseed/titiler#319)</li> </ul>"},{"location":"release-notes/#titilerapplication_17","title":"titiler.application","text":"<ul> <li>add <code>titiler.application.middleware.LowerCaseQueryStringMiddleware</code> to cast all query string parameter to lowercase (author @lorenzori, developmentseed/titiler!321)</li> </ul>"},{"location":"release-notes/#code-and-repo","title":"code and repo","text":"<ul> <li>move <code>titiler</code> code to <code>src/titiler</code></li> </ul>"},{"location":"release-notes/#032-2021-05-26","title":"0.3.2 (2021-05-26)","text":""},{"location":"release-notes/#titilercore_41","title":"titiler.core","text":"<ul> <li>update rio-tiler dependency to <code>&gt;=2.1</code> version and update <code>rescale</code> query-parameter (developmentseed/titiler#319)</li> </ul> <pre><code># before\n# previously, rio-tiler was splitting a list of input range in tuple of 2\nrescale=0,1000,0,1000,0,1000\n\n# now\n# rio-tiler 2.1 now expect sequence of tuple in form of Sequence[Tuple[Num, Num]]\nrescale=0,1000&amp;rescale=0,1000&amp;rescale=0,1000\n</code></pre>"},{"location":"release-notes/#titilermosaic_19","title":"titiler.mosaic","text":"<ul> <li>update <code>cogeo-mosaic</code> version to <code>&gt;=3.0,&lt;3.1</code>.</li> </ul>"},{"location":"release-notes/#titilerapplication_18","title":"titiler.application","text":"<ul> <li>re-order middlewares (developmentseed/titiler#311)</li> <li>update rio-cogeo version to <code>&gt;=2.2</code> and use <code>rio_cogeo.models</code> instead of custom ones.</li> </ul>"},{"location":"release-notes/#031-2021-04-27","title":"0.3.1 (2021-04-27)","text":"<ul> <li>add <code>exclude_path</code> options in <code>titiler.application.middleware.CacheControlMiddleware</code> to avoid adding cache-control headers to specific paths.</li> <li>allow <code>histogram_bins</code> to be a single value or a <code>,</code> delimited scalar (developmentseed/titiler!307)</li> <li> <p>change error status from <code>404</code> to <code>500</code> for <code>RasterioIOError</code> exception (author @kylebarron, developmentseed/titiler!300)</p> <p>Sometimes GDAL/Rasterio can lose track of the file handler (might be related to cache issue + threading) and raise <code>RasterioIOError: file not found</code>, while the file exists for real. To avoid caching this, we changed the error code to 500 (errors &gt;= 500 do not get <code>cache-control</code> header on titiler.application).</p> </li> </ul>"},{"location":"release-notes/#030-2021-04-19","title":"0.3.0 (2021-04-19)","text":"<ul> <li>add support for <code>.jpg</code> and <code>.jpeg</code> extensions (developmentseed/titiler!271)</li> <li>better error message when parsing the colormap value fails (developmentseed/titiler!279)</li> </ul> <p>breaking change</p> <ul> <li> <p>split <code>titiler</code> into a set of namespaces packages (developmentseed/titiler!284)</p> <p>titiler.core</p> <p>The <code>core</code> package host the low level tiler factories. <pre><code># before\nfrom titiler.endpoints.factory import TilerFactory\n\n# now\nfrom titiler.core.factory import TilerFactory\n</code></pre></p> <p>titiler.mosaic</p> <p>The <code>mosaic</code> package is a plugin to <code>titiler.core</code> which adds support for MosaicJSON <pre><code># before\nfrom titiler.endpoints.factory import MosaicTilerFactory\n\n# now\nfrom titiler.mosaic.factory import MosaicTilerFactory\n</code></pre></p> <p>titiler.application</p> <p>The <code>application</code> package is a full <code>ready to use</code> FastAPI application with support of STAC, COG and MosaicJSON.</p> <pre><code># before\n$ pip install titiler\n$ uvicorn titiler.main:app --reload\n\n# now\n$ pip install titiler.application uvicorn\n$ uvicorn titiler.application.main:app --reload\n</code></pre> </li> </ul>"},{"location":"release-notes/#020-2021-03-09","title":"0.2.0 (2021-03-09)","text":"<ul> <li>adapt for cogeo-mosaic <code>3.0.0rc2</code> and add <code>backend_options</code> attribute in MosaicTilerFactory (developmentseed/titiler!247)</li> <li>update FastAPI requirements</li> <li>update minimal python version to 3.6</li> <li>add <code>**render_params.kwargs</code> to pass custom render params in <code>image.render</code> method (developmentseed/titiler!259)</li> <li>Changed probe url from <code>/ping</code> to <code>/healthz</code> in k8s deployment</li> </ul> <p>breaking change</p> <ul> <li>renamed <code>OptionalHeaders</code>, <code>MimeTypes</code> and <code>ImageDrivers</code> enums to the singular form (developmentseed/titiler!258)</li> <li>renamed titiler.dependencies's Enums (<code>ColorMapName</code>, <code>ResamplingName</code> and <code>TileMatrixSetName</code>) to the singular form (developmentseed/titiler!260)</li> <li>renamed <code>MimeType</code> to <code>MediaType</code> (developmentseed/titiler!258)</li> <li>add <code>ColorMapParams</code> dependency to ease the creation of custom colormap dependency (developmentseed/titiler!252)</li> <li>renamed <code>PathParams</code> to <code>DatasetPathParams</code> and also made it a simple callable (developmentseed/titiler!260)</li> <li> <p>renamed <code>colormap</code> query-parameter to <code>colormap_name</code> (developmentseed/titiler!262)     <pre><code># before\n/cog/preview.png?colormap=viridis\n\n# now\n/cog/preview.png?colormap_name=viridis\n</code></pre></p> </li> <li> <p>use <code>colormap</code> query-parameter to pass custom colormap (developmentseed/titiler!262)     <pre><code>/cog/preview.png?colormap={\"0\": \"#FFFF00FF\", ...}\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#010-2021-02-17","title":"0.1.0 (2021-02-17)","text":"<ul> <li>update FastAPI requirements</li> <li>add <code>validate</code> in <code>MosaicTilerFactory</code> (developmentseed/titiler!206, author @drnextgis)</li> <li>rename <code>ressources</code> package to <code>resources</code> (developmentseed/titiler!210, author @drnextgis)</li> <li>renamed environment variables prefixes for API and STACK configurations: <code>TITILER_STACK</code> as prefix to CDK and <code>TITILER_API</code> as prefix to API (developmentseed/titiler!211, author @fredliporace)</li> <li>remove MosaicTilerFactory <code>create</code> and <code>update</code> endpoints (developmentseed/titiler!218)</li> <li>deleted <code>titiler.models.mosaics</code> because the models are not used anymore (developmentseed/titiler!221)</li> <li>update rio-tiler and cogeo-mosaic minimal versions (developmentseed/titiler!220, developmentseed/titiler!213)</li> <li>move STAC related dependencies to `titiler.dependencies (developmentseed/titiler!225)</li> <li>add <code>rio_tiler.io.MultiBandReader</code> bands dependencies (developmentseed/titiler!226)</li> <li>add <code>MultiBaseTilerFactory</code> and <code>MultiBandTilerFactory</code> custom tiler factories (developmentseed/titiler!230)</li> <li>Update STAC tiler to use the new <code>MultiBaseTilerFactory</code> factory</li> <li>depreciate empty GET endpoint for MosaicTilerFactory read (developmentseed/titiler!232)</li> <li>better <code>debug</code> configuration and make reponse headers metadata optional (developmentseed/titiler!232)</li> </ul> <p>breaking change</p> <ul> <li>update <code>titiler.dependencies.AssetsBidxParams</code> to make <code>asset</code> a required parameter (developmentseed/titiler!230</li> <li>the STAC <code>/info</code> endpoint now expect the <code>assets</code> parameter to be passed. To ge the list of available assets we added a new <code>/assets</code> endpoint within the tiler factory</li> <li>remove <code>COGReader</code> as default <code>reader</code> in <code>titiler.endpoints.factory.BaseTilerFactory</code></li> </ul>"},{"location":"release-notes/#010a14-2021-01-05","title":"0.1.0a14 (2021-01-05)","text":"<ul> <li>add <code>rio_tiler.errors.MissingBands</code> in known errors.</li> <li>add <code>titiler.endpoints.factory.TMSFactory</code> to enable custom TMS endpoints.</li> <li>breaking rename <code>BaseFactory</code> to <code>BaseTilerFactory</code> in <code>titiler.endpoints.factory</code></li> </ul>"},{"location":"release-notes/#010a13-2020-12-20","title":"0.1.0a13 (2020-12-20)","text":"<ul> <li>allow <code>API_DISABLE_{COG/STAC/MOSAIC}</code> environment variables to control default endpoints in titiler main app (developmentseed/titiler#156)</li> <li>add <code>overwriting=False/True</code> on MosaicJSON creation (developmentseed/titiler#164)</li> <li>add <code>gdal_config</code> option to Tiler factories to replace custom <code>APIRoute</code> class (developmentseed/titiler#168)</li> <li>add <code>info.geojson</code> endpoint to return dataset info as a GeoJSON feature (developmentseed/titiler#166)</li> <li>update <code>rio-tiler</code>, <code>cogeo-mosaic</code> and optional dependencies</li> </ul>"},{"location":"release-notes/#010a12-2020-11-18","title":"0.1.0a12 (2020-11-18)","text":"<ul> <li>require <code>rio-tiler&gt;=2.0.0rc2</code></li> <li>update Enums for Image types. (breaking)</li> <li>Add more output datatype (jpeg2000, pngraw)</li> <li>add <code>width/height</code> in <code>/crop</code> endpoint path</li> </ul> <pre><code>/crop/{minx},{miny},{maxx},{maxy}.{format}\n/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}\n</code></pre>"},{"location":"release-notes/#010a11post1-2020-11-12","title":"0.1.0a11.post1 (2020-11-12)","text":"<ul> <li>relax version for rio-tiler and cogeo-mosaic</li> </ul> <pre><code>\"rio-cogeo~=2.0\"\n\"rio-tiler&gt;=2.0.0rc1,&lt;2.1\"\n\"cogeo-mosaic&gt;=3.0.0a17,&lt;3.1\"\n</code></pre>"},{"location":"release-notes/#010a11-2020-11-12","title":"0.1.0a11 (2020-11-12)","text":"<ul> <li>split <code>tile()</code> for <code>MosaicTilerFactory</code> method (developmentseed/titiler#147)</li> </ul>"},{"location":"release-notes/#010a10-2020-11-09","title":"0.1.0a10 (2020-11-09)","text":"<ul> <li>update for rio-tiler==2.0.0rc1, cogeo-mosaic==3.0.0a17 and morecantile==2.0</li> <li>split <code>tile()</code> factory method (developmentseed/titiler#141, author @fredliporace)</li> </ul>"},{"location":"release-notes/#010a9-2020-10-26","title":"0.1.0a9 (2020-10-26)","text":"<ul> <li>avoid changing mutable TMS and Colormap list by using deepcopy.</li> <li>quiet/turn off logs</li> <li>add logger middleware (developmentseed/titiler!139)</li> </ul>"},{"location":"release-notes/#010a8-2020-10-13","title":"0.1.0a8 (2020-10-13)","text":"<ul> <li>update for rio-tiler 2.0.0b17, which now support TMS (morecantile) by default.</li> <li>update fastapi minimum version to 0.61</li> </ul> <p>breaking changes</p> <ul> <li>removed TMSTilerFactory (because default reader built with rio_tiler BaseReader should support TMS).</li> </ul> <p>Note: We changed the versioning scheme to <code>{major}.{minor}.{path}{pre}{prenum}</code></p>"},{"location":"release-notes/#010-alpha7-2020-10-13","title":"0.1.0-alpha.7 (2020-10-13)","text":"<ul> <li>remove <code>pkg_resources</code> (pypa/setuptools#510)</li> </ul>"},{"location":"release-notes/#010-alpha6-2020-10-05","title":"0.1.0-alpha.6 (2020-10-05)","text":"<ul> <li>refactor CacheControl Middleware</li> <li>rename headers value <code>X-Server-Timings</code> to <code>Server-Timing</code>.</li> <li>add <code>total;dur={}</code> in response header <code>Server-Timing</code>, using new <code>titiler.middleware.TotalTimeMiddleware</code> middleware (113)</li> </ul> <pre><code>from titiler.middleware import CacheControlMiddleware, TotalTimeMiddleware\nfrom fastapi import FastAPI\n\napp.add_middleware(CacheControlMiddleware, cachecontrol=\"public, max-age=3600\")\napp.add_middleware(TotalTimeMiddleware)\n</code></pre> <ul> <li>Add Brotli compression support (#126, author @kylebarron)</li> <li>Numerous fix to CDK app.py (co-author @kylebarron)</li> </ul>"},{"location":"release-notes/#010-alpha5-2020-09-22","title":"0.1.0-alpha.5 (2020-09-22)","text":"<ul> <li>exclude <code>tests/</code> an <code>stack/</code> in titiler python package.</li> <li>add <code>EPSG6933</code> in TMS</li> </ul> <p>breaking changes * [FACTORY] the <code>additional_dependency</code> should be a Callable which return a dict.</p> <pre><code>```python\n@dataclass  # type: ignore\nclass BaseFactory(metaclass=abc.ABCMeta):\n    \"\"\"BaseTiler Factory.\"\"\"\n    ...\n    # provide custom dependency\n    additional_dependency: Callable[..., Dict] = field(default=lambda: dict())\n```\n\n```python\ndef AssetsParams(\n    assets: Optional[str] = Query(\n        None,\n        title=\"Asset indexes\",\n        description=\"comma (',') delimited asset names (might not be an available options of some readers)\",\n    )\n) -&gt; Dict:\n    \"\"\"Assets Dependency.\"\"\"\n    kwargs = {}\n    if assets:\n        kwargs[\"assets\"] = assets.split(\",\")\n    return kwargs\n```\n</code></pre> <ul> <li>[FACTORY] remove <code>_</code> prefix in factory methods (e.g <code>_tile</code> -&gt; <code>tile</code>)</li> <li> <p>[FACTORY] refactor dependencies to better align with rio_tiler.io.BaseReader method definition.</p> <p>Example:</p> <p>In the <code>metadata</code>, the <code>MetadataParams</code> will be used to pass <code>pmin</code> and <code>pmax</code> because they are the only required parameters for the metadata method. All other params will be passed to a <code>kwargs</code> dict.</p> <p><pre><code>@dataclass\nclass MetadataParams(DefaultDependency):\n    \"\"\"Common Metadada parameters.\"\"\"\n    # Required params\n    pmin: float = Query(2.0, description=\"Minimum percentile\")\n    pmax: float = Query(98.0, description=\"Maximum percentile\")\n    # Optional parameters\n    bidx: Optional[str] = Query(\n        None, title=\"Band indexes\", description=\"comma (',') delimited band indexes\",\n    )\n    ...\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n\n        if self.bidx is not None:\n            self.kwargs[\"indexes\"] = tuple(\n                int(s) for s in re.findall(r\"\\d+\", self.bidx)\n            )\n    ...\n\n# metadata method in factory\ndef metadata(\n    src_path=Depends(self.path_dependency),\n    metadata_params=Depends(self.metadata_dependency),\n    kwargs: Dict = Depends(self.additional_dependency),\n):\n    \"\"\"Return metadata.\"\"\"\n    reader = src_path.reader or self.reader\n    with reader(src_path.url, **self.reader_options) as src_dst:\n        info = src_dst.metadata(\n            metadata_params.pmin,\n            metadata_params.pmax,\n            **metadata_params.kwargs,\n            **kwargs,\n        )\n    return info\n</code></pre> * [FACTORY] refactor dependencies definition <pre><code>@dataclass  # type: ignore\nclass BaseFactory(metaclass=abc.ABCMeta):\n    \"\"\"BaseTiler Factory.\"\"\"\n\n    reader: default_readers_type = field(default=COGReader)\n    reader_options: Dict = field(default_factory=dict)\n\n    # FastAPI router\n    router: APIRouter = field(default_factory=APIRouter)\n\n    # Path Dependency\n    path_dependency: Type[PathParams] = field(default=PathParams)\n\n    # Rasterio Dataset Options (nodata, unscale, resampling)\n    dataset_dependency: default_deps_type = field(default=DatasetParams)\n\n    # Indexes/Expression Dependencies\n    layer_dependency: default_deps_type = field(default=BidxExprParams)\n\n    # Image rendering Dependencies\n    render_dependency: default_deps_type = field(default=RenderParams)\n\n    # TileMatrixSet dependency\n    tms_dependency: Callable[..., TileMatrixSet] = WebMercatorTMSParams\n\n    # provide custom dependency\n    additional_dependency: Callable[..., Dict] = field(default=lambda: dict())\n</code></pre></p> </li> <li> <p>remove <code>PathParams.reader</code> attribute. This option was not used and would have been technically difficult to use.     <pre><code>@dataclass\nclass PathParams:\n    \"\"\"Create dataset path from args\"\"\"\n\n    url: str = Query(..., description=\"Dataset URL\")\n</code></pre></p> </li> </ul>"},{"location":"release-notes/#010-alpha4-2020-09-14","title":"0.1.0-alpha.4 (2020-09-14)","text":"<ul> <li> <p>Update <code>.npy</code> output format to follow the numpyTile format (#103)</p> <pre><code>import numpy\nimport requests\nfrom io import BytesIO\n\nendpoint = ...\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n\nr = requests.get(f\"{endpoint}/cog/tiles/14/10818/9146.npy\",\n    params = {\n        \"url\": url,\n    }\n)\ndata = numpy.load(BytesIO(r.content))\nprint(data.shape)\n&gt; (4, 256, 256)\n</code></pre> </li> <li> <p>Add <code>titiler.custom.routing.apiroute_factory</code>. This function enable the creation of custom fastapi.routing.APIRoute class with <code>rasterio.Env()</code> block.</p> <pre><code>from fastapi import FastAPI, APIRouter\nfrom rasterio._env import get_gdal_config\nfrom titiler.custom.routing import apiroute_factory\n\napp = FastAPI()\nroute_class = apiroute_factory({\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"})\nrouter = APIRouter(route_class=route_class)\n\n@router.get(\"/simple\")\ndef simple():\n    \"\"\"should return FALSE.\"\"\"\n    res = get_gdal_config(\"GDAL_DISABLE_READDIR_ON_OPEN\")\n    return {\"env\": res}\n\napp.include_router(router)\n</code></pre> <p>Note: This has only be tested for python 3.6 and 3.7.</p> </li> </ul>"},{"location":"release-notes/#010-alpha3-2020-09-03","title":"0.1.0-alpha.3 (2020-09-03)","text":"<ul> <li>add custom <code>url_for</code> method in TilerFactory to retrieve <code>prefixed</code> endpoint URL (#95)</li> <li>remove magic <code>titiler.dependencies.PathParams</code> mosaicid path translation, where a user could pass <code>url=mosaicid://</code> to the endpoint.</li> <li> <p>switch to <code>pydantic.BaseSettings</code> for FastAPI application setting management.</p> <p>List of Settings:</p> <pre><code>name: str = \"titiler\"\ncors_origins: str = \"*\"\ncachecontrol: str = \"public, max-age=3600\"\n</code></pre> </li> </ul> <p>API Settings can now be set by adding a <code>.env</code> file in your local project or by setting environment variables (e.g <code>API_CORS_ORIGIN=\"https://mywebsite.com/*\"</code>)</p>"},{"location":"release-notes/#010-alpha2-2020-09-01","title":"0.1.0-alpha.2 (2020-09-01)","text":"<ul> <li>add Transform and CRS information in <code>/part</code> GeoTIFF output</li> <li>pin rio-tiler-crs to <code>&gt;=3.0b4,&lt;3.1</code> and cogeo-mosaic to <code>&gt;=3.0a10,&lt;3.1</code></li> </ul>"},{"location":"release-notes/#010-alpha1-2020-09-01","title":"0.1.0-alpha.1 (2020-09-01)","text":"<ul> <li>rename titiler.models.cog.py to titiler.models.dataset.py</li> <li>remove cog* prefix to Bounds, Info and Metadata models</li> <li>allow Union[str, int] for key in Metadata.statistics (as defined in rio-tiler-pds)</li> </ul> <p>e.g Create a Landsat 8 Tiler <pre><code>from titiler.endpoints.factory import TilerFactory, MosaicTilerFactory\nfrom titiler.dependencies import BandsParams\n\nfrom rio_tiler_pds.landsat.aws.landsat8 import L8Reader  # Not in TiTiler dependencies\n\nfrom fastapi import FastAPI\n\napp = FastAPI(title=\"Landsat Tiler\", openapi_url=\"/api/v1/openapi.json\")\nscene = TilerFactory(\n    reader=L8Reader, additional_dependency=BandsParams, router_prefix=\"scenes\"\n)\nmosaic = MosaicTilerFactory(\n    dataset_reader=L8Reader,\n    additional_dependency=BandsParams,\n    add_update=False,\n    add_create=False,\n    router_prefix=\"mosaic\",\n)\napp.include_router(scene.router, prefix=\"/scenes\", tags=[\"Scenes\"])\napp.include_router(mosaic.router, prefix=\"/mosaic\", tags=[\"Mosaic\"])\n</code></pre></p>"},{"location":"release-notes/#01a0-2020-08-31","title":"0.1a0 (2020-08-31)","text":"<p>First release on pypi</p>"},{"location":"release-notes/#tiler-factory","title":"Tiler Factory","text":"<p>For this release we created new Tiler Factories class which handle creation of FastAPI routers for a given rio_tiler Readers.</p> <pre><code>from titiler.endpoints.factory import TilerFactory\nfrom rio_tiler.io import COGReader, STACReader\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\ncog = TilerFactory()\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n</code></pre>"},{"location":"release-notes/#readers-tilematrixsets","title":"Readers / TileMatrixSets","text":"<p>The <code>titiler.endpoints.factory.TilerFactory</code> class will create a tiler with <code>Web Mercator</code> as uniq supported Tile Matrix Set.</p> <p>For other TMS support, tiler needs to be created with <code>titiler.endpoints.factory.TMSTilerFactory</code> and with a TMS friendly reader (e.g <code>rio_tiler_crs.COGReader</code>).</p> <p>Simple tiler with only Web Mercator support <pre><code>from rio_tiler.io import COGReader\n\nfrom titiler.endpoints import factory\nfrom titiler.dependencies import WebMercatorTMSParams\n\napp = factory.TilerFactory(reader=COGReader)\nassert app.tms_dependency == WebMercatorTMSParams\n</code></pre></p> <p>Tiler with more TMS support (from morecantile) <pre><code>from rio_tiler_crs import COGReader\n\nfrom titiler.endpoints import factory\nfrom titiler.dependencies import TMSParams\n\napp = factory.TMSTilerFactory(reader=COGReader)\nassert app.tms_dependency == TMSParams\n</code></pre></p>"},{"location":"release-notes/#other-changes","title":"Other changes","text":"<ul> <li>add mosaic support  (#17 author @geospatial-jeff)</li> <li>update to rio-tiler-crs&gt;=3.0b* and rio-tiler&gt;=2.0b*</li> <li>Pin fastapi version to 0.60.1</li> <li>Remove titiler.core in favor of starlette settings (#55, author @geospatial-jeff)</li> <li>Add fastapi exception handlers (#56, author @geospatial-jeff)</li> <li>Remove intermediary routers (#57, author @geospatial-jeff)</li> <li>Remove /titiler/api submodule (e.g titiler.api.utils -&gt; titiler.utils)</li> <li>Add Cache-Control middleware. Endpoints do not define any cache-control headers. (part of #43, co-author with @geospatial-jeff)</li> <li>Add 'X-Assets' in response headers for mosaic tiles (#51)</li> <li>add cog validation via rio-cogeo (co-author with @geospatial-jeff, #37)</li> </ul>"},{"location":"release-notes/#breaking-changes","title":"Breaking changes","text":"<ul> <li>default tiler to Web Mercator only</li> <li>removed cache layer for tiles</li> <li>updated html templates</li> </ul> <pre><code>template_dir = pkg_resources.resource_filename(\"titiler\", \"templates\")\ntemplates = Jinja2Templates(directory=template_dir)\n\ncog_template = templates.TemplateResponse(\n    name=\"cog_index.html\",\n    context={\n        \"request\": request,\n        \"tilejson\": request.url_for(\"cog_tilejson\"),\n        \"metadata\": request.url_for(\"cog_metadata\"),\n    },\n    media_type=\"text/html\",\n)\n\nstac_template = templates.TemplateResponse(\n    name=\"stac_index.html\",\n    context={\n        \"request\": request,\n        \"tilejson\": request.url_for(\"stac_tilejson\"),\n        \"metadata\": request.url_for(\"stac_info\"),\n    },\n    media_type=\"text/html\",\n)\n</code></pre>"},{"location":"release-notes/#pre-pypi-releases","title":"Pre Pypi releases","text":""},{"location":"release-notes/#212-2020-06-24","title":"2.1.2 (2020-06-24)","text":"<ul> <li>add <code>width</code> &amp; <code>height</code> parameters in API docs to force output size for part/preview endpoints.</li> <li>add <code>resampling_method</code> in API docs.</li> </ul> <p>link: developmentseed/titiler@725da5f</p>"},{"location":"release-notes/#211-2020-06-22","title":"2.1.1 (2020-06-22)","text":"<ul> <li>add minimum fastapi version (0.54.0) and update docker config</li> </ul> <p>link: developmentseed/titiler@95b98a3</p>"},{"location":"release-notes/#210-2020-06-11","title":"2.1.0 (2020-06-11)","text":"<ul> <li>add <code>/preview</code>, <code>/crop</code>, <code>/point</code> endpoints</li> </ul> <p>link: developmentseed/titiler@8b63fc6</p>"},{"location":"release-notes/#200-2020-06-09","title":"2.0.0 (2020-06-09)","text":"<ul> <li>support STAC items (#16)</li> <li>better API documentation via response models</li> <li>update UI (<code>/stac/viewer</code>, <code>/cog/viewer</code>)</li> <li>re-order OpenAPI route tags</li> <li>update documentation</li> </ul> <p>link: developmentseed/titiler@fa2cb78</p>"},{"location":"release-notes/#100-2020-06-04","title":"1.0.0 (2020-06-04)","text":"<p>Initial release</p> <p>link: developmentseed/titiler@f4fdc02</p>"},{"location":"tile_matrix_sets/","title":"TileMatrixSets","text":"<p>Slippy map tiles are square or rectangular images that follow a coordinate system defined by a grid called <code>Tile Matrix</code>: docs.opengeospatial.org/is/17-083r2/17-083r2.html. The <code>Web Mercator grid</code> is the de facto standard for Web maps. Made popular by google since 2005, it has pros and cons and:</p> <p>With any such projection, some distortion is unavoidable. In the Mercator projection, geographical features further from the equator are exaggerated in size. For example, Greenland appears to be of a similar size to Africa. However, Africa is actually more than 14 times as large (by area).</p> <p>ref: developer.tomtom.com/blog/decoded/understanding-map-tile-grids-and-zoom-levels</p> <p>As one of the first requirements, we built <code>TiTiler</code> with support for serving tiles in multiple Projections by using <code>rio-tiler</code> and <code>morecantile</code> which provide the low level TileMatrixSets support.</p> <pre><code>$ curl http://127.0.0.1:8000/tileMatrixSets | jq '.tileMatrixSets[] | .id'\n\"LINZAntarticaMapTilegrid\"\n\"EuropeanETRS89_LAEAQuad\"\n\"CanadianNAD83_LCC\"\n\"UPSArcticWGS84Quad\"\n\"NZTM2000\"\n\"NZTM2000Quad\"\n\"UTM31WGS84Quad\"\n\"UPSAntarcticWGS84Quad\"\n\"WorldMercatorWGS84Quad\"\n\"WGS1984Quad\"\n\"WorldCRS84Quad\"\n\"WebMercatorQuad\"\n</code></pre> <p>You can easily add more TileMatrixSet support, see custom tms.</p> <p>Notebook: Working_with_nonWebMercatorTMS</p>"},{"location":"advanced/APIRoute_and_environment_variables/","title":"APIRoute and environment variables","text":"<p>Important</p> <p>This has been deprecated. You can now pass <code>environment_dependency=lambda: {\"GDAL_DISABLE_READDIR_ON_OPEN\":\"FALSE\"}</code> to the Tiler Factory. This will be passed to a <code>rasterio.Env()</code> context manager on top of all gdal related blocks.</p> <pre><code>from titiler.core.factory import TilerFactory\ncog = TilerFactory(\n    reader=COGReader,\n    router_prefix=\"cog\",\n    environment_dependency=lambda: {\"GDAL_DISABLE_READDIR_ON_OPEN\":\"FALSE\"},\n)\n</code></pre> <p>Sometimes, specifically when using GDAL, it can be useful to have environment variables set for certain endpoints (e.g. when using Landsat data on AWS you need <code>GDAL_DISABLE_READDIR_ON_OPEN=FALSE</code> but you don't want this environment variable set for other endpoints). To be able to do this we created a custom APIRoute class which wraps classic fastapi APIRoute with a <code>rasterio.Env()</code> block: github.com/developmentseed/titiler/blob/8a7127ca56631c2c327713d99e80285048c3aa6c/titiler/custom/routing.py#L13-L41</p> <p>Example:     <pre><code>from fastapi import FastAPI, APIRouter\nfrom rasterio._env import get_gdal_config\nfrom titiler.core.routing import apiroute_factory\nfrom titiler.core.factory import TilerFactory\n\napp = FastAPI()\nroute_class = apiroute_factory({\"GDAL_DISABLE_READDIR_ON_OPEN\": \"FALSE\"})\nrouter = APIRouter(route_class=route_class)\n\ntiler = TilerFactory(router=router)\n\n@router.get(\"/simple\")\ndef simple():\n    \"\"\"should return FALSE.\"\"\"\n    res = get_gdal_config(\"GDAL_DISABLE_READDIR_ON_OPEN\")\n    return {\"env\": res}\n\napp.include_router(router)\n</code></pre></p> <p>Important</p> <p>This has only be tested for python 3.6 and 3.7.</p>"},{"location":"advanced/Algorithms/","title":"Custom Algorithm","text":"<p>Starting with <code>titiler&gt;=0.8</code>, we added the possibility to apply custom algorithms on Image outputs from <code>tile</code>, <code>crop</code> or <code>preview</code> endpoints.</p> <p>The algorithms are meant to overcome the limitation of <code>expression</code> (using numexpr) by allowing more complex operations.</p> <p>We added a set of custom algorithms:</p> <ul> <li><code>hillshade</code>: Create hillshade from elevation dataset</li> <li><code>contours</code>: Create contours lines (raster) from elevation dataset</li> <li><code>terrarium</code>: Mapzen's format to encode elevation value in RGB values (github.com/tilezen/joerd/blob/master/docs/formats.md#terrarium)</li> <li><code>terrainrgb</code>: Mapbox's format to encode elevation value in RGB values (docs.mapbox.com/data/tilesets/guides/access-elevation-data/)</li> <li><code>normalizedIndex</code>: Normalized Difference Index (e.g NDVI)</li> </ul>"},{"location":"advanced/Algorithms/#usage","title":"Usage","text":"<p><pre><code># return a\nhttpx.get(\n    \"http://127.0.0.1:8081/cog/tiles/16/34059/23335\",\n    params={\n        \"url\": \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\",\n        \"buffer\": 3,  # By default hillshade will crop the output with a 3pixel buffer, so we need to apply a buffer on the tile\n        \"algorithm\": \"hillshade\",\n    },\n)\n</code></pre> </p> <p><pre><code># Pass algorithm parameter as a json string\nhttpx.get(\n    \"http://127.0.0.1:8081/cog/preview\",\n    params={\n        \"url\": \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\",\n        \"algorithm\": \"contour\",\n        \"algorithm_params\": json.dumps({\"minz\": 1600, \"maxz\": 2100}) # algorithm params HAVE TO be provided as a JSON string\n    },\n)\n</code></pre> </p>"},{"location":"advanced/Algorithms/#create-your-own-algorithm","title":"Create your own Algorithm","text":"<p>A titiler'w <code>Algorithm</code> must be defined using <code>titiler.core.algorithm.BaseAlgorithm</code> base class.</p> <pre><code>class BaseAlgorithm(BaseModel, metaclass=abc.ABCMeta):\n    \"\"\"Algorithm baseclass.\n\n    Note: attribute starting with `input_` or `output_` are considered as metadata\n\n    \"\"\"\n\n    # metadata\n    input_nbands: int\n    output_nbands: int\n    output_dtype: str\n    output_min: Optional[Sequence]\n    output_max: Optional[Sequence]\n\n    @abc.abstractmethod\n    def __call__(self, img: ImageData) -&gt; ImageData:\n        \"\"\"Apply algorithm\"\"\"\n        ...\n\n    class Config:\n        \"\"\"Config for model.\"\"\"\n\n        extra = \"allow\"\n</code></pre> <p>This base class defines that algorithm:</p> <ul> <li> <p>HAVE TO implement an <code>__call__</code> method which takes an ImageData as input and return an ImageData. Using <code>__call__</code> let us use the object as a callable (e.g <code>Algorithm(**kwargs)(image)</code>).</p> </li> <li> <p>can have input/output metadata (informative)</p> </li> <li> <p>can have<code>parameters</code> (enabled by <code>extra = \"allow\"</code> pydantic config)</p> </li> </ul> <p>Here is a simple example of a custom Algorithm:</p> <pre><code>from titiler.core.algorithm import BaseAlgorithm\nfrom rio_tiler.models import ImageData\n\nclass Multiply(BaseAlgorithm):\n\n    # Parameters\n    factor: int # There is no default, which means calls to this algorithm without any parameter will fail\n\n    # We don't set any metadata for this Algorithm\n\n    def __call__(self, img: ImageData) -&gt; ImageData:\n        # Multiply image data bcy factor\n        data = img.data * self.factor\n\n        # Create output ImageData\n        return ImageData(\n            data,\n            img.mask,\n            assets=img.assets,\n            crs=img.crs,\n            bounds=img.bounds,\n        )\n</code></pre>"},{"location":"advanced/Algorithms/#class-vs-script","title":"Class Vs script","text":"<p>Using a Pydantic's <code>BaseModel</code> class to construct the custom algorithm enables two things parametrization and type casting/validation.</p> <p>If we look at the <code>Multiply</code> algorithm, we can see it needs a <code>factor</code> parameter. In Titiler (in the post_process dependency) we will pass this parameter via query string (e.g <code>/preview.png?algo=multiply&amp;algo_parameter={\"factor\":3}</code>) and pydantic will make sure we use the right types/values.</p> <pre><code># Available algorithm\nalgo = {\"multiply\": Multiply}\n\ndef post_process_dependency(\n    algorithm: Literal[tuple(algo.keys())] = Query(None, description=\"Algorithm name\"),\n    algorithm_params: str = Query(None, description=\"Algorithm parameter\"),\n) -&gt; Optional[BaseAlgorithm]:\n    \"\"\"Data Post-Processing dependency.\"\"\"\n    # Parse `algorithm_params` JSON parameters\n    kwargs = json.loads(algorithm_params) if algorithm_params else {}\n    if algorithm:\n        # Here we construct the Algorithm Object with the kwargs from the `algo_params` query-parameter\n        return algo[algorithm](**kwargs)\n\n    return None\n</code></pre>"},{"location":"advanced/Algorithms/#dependency","title":"Dependency","text":"<p>To be able to use your own algorithm in titiler's endpoint you need to create a <code>Dependency</code> to tell the application what algorithm are available.</p> <p>To ease the dependency creation, we added a <code>dependency</code> property in the <code>titiler.core.algorithm.Algorithms</code> class, which will return a FastAPI dependency to be added to the endpoints.</p> <p>Note: The <code>Algorithms</code> class is a store for the algorithm that can be extented using the <code>.register()</code> method.</p> <pre><code>from typing import Callable\nfrom titiler.core.algorithm import algorithms as default_algorithms\nfrom titiler.core.algorithm import Algorithms\nfrom titiler.core.factory import TilerFactory\n\n# Add the `Multiply` algorithm to the default ones\nalgorithms: Algorithms = default_algorithms.register({\"multiply\": Multiply})\n\n# Create a PostProcessParams dependency\nPostProcessParams: Callable = algorithms.dependency\n\nendpoints = TilerFactory(process_dependency=PostProcessParams)\n</code></pre>"},{"location":"advanced/Algorithms/#order-of-operation","title":"Order of operation","text":"<p>When creating a map tile (or other images), we will fist apply the <code>algorithm</code> then the <code>rescaling</code> and finally the <code>color_formula</code>.</p> <pre><code>with reader(url as src_dst:\n    image = src_dst.tile(\n        x,\n        y,\n        z,\n    )\n    dst_colormap = getattr(src_dst, \"colormap\", None)\n\n# Apply algorithm\nif post_process:\n    image = post_process(image)\n\n# Apply data rescaling\nif rescale:\n    image.rescale(rescale)\n\n# Apply color-formula\nif color_formula:\n    image.apply_color_formula(color_formula)\n\n# Determine the format\nif not format:\n    format = ImageType.jpeg if image.mask.all() else ImageType.png\n\n# Image Rendering\nreturn image.render(\n    img_format=format.driver,\n    colormap=colormap or dst_colormap,\n    **format.profile,\n)\n</code></pre>"},{"location":"advanced/Extensions/","title":"Extensions","text":"<p>Starting with <code>titiler&gt;=0.11</code>, we added a new titiler package <code>titiler.extensions</code> which aim to ease the addition of <code>optional</code> endpoints to factories.</p> <p>In <code>titiler.core.factory.BaseTilerFactory</code> class, we've added a new attribute: <code>extensions: List[FactoryExtension] = field(default_factory=list)</code>. The <code>list</code> of extension will then be used in the <code>post-init</code> step such as:</p> <pre><code>def __post_init__(self):\n    \"\"\"Post Init: register route and configure specific options.\"\"\"\n    # Register endpoints\n    self.register_routes()\n\n    # Register Extensions\n    for ext in self.extensions:\n        ext.register(self)\n\n    # Update endpoints dependencies\n    for scopes, dependencies in self.route_dependencies:\n        self.add_route_dependencies(scopes=scopes, dependencies=dependencies)\n</code></pre> <p>We defined extension using an Abstract Base Class to make sure they implement a <code>register</code> method:</p> <pre><code>@dataclass\nclass FactoryExtension(metaclass=abc.ABCMeta):\n    \"\"\"Factory Extension.\"\"\"\n\n    @abc.abstractmethod\n    def register(self, factory: \"BaseTilerFactory\"):\n        \"\"\"Register extension to the factory.\"\"\"\n        ...\n</code></pre>"},{"location":"advanced/Extensions/#available-extensions","title":"Available extensions","text":""},{"location":"advanced/Extensions/#cogvalidateextension","title":"cogValidateExtension","text":"<ul> <li>Goal: adds a <code>/validate</code> endpoint which return the content of rio-cogeo <code>info</code> method</li> <li>Additional requirements: <code>titiler.extensions[\"cogeo\"]</code> (installs <code>rio-cogeo</code>)</li> </ul>"},{"location":"advanced/Extensions/#cogviewerextension","title":"cogViewerExtension","text":"<ul> <li>Goal: adds a <code>/viewer</code> endpoint which return an HTML viewer for simple COGs</li> </ul>"},{"location":"advanced/Extensions/#stacviewerextension","title":"stacViewerExtension","text":"<ul> <li>Goal: adds a <code>/viewer</code> endpoint which return an HTML viewer for STAC item</li> </ul>"},{"location":"advanced/Extensions/#stacextension","title":"stacExtension","text":"<ul> <li>Goal: adds a <code>/stac</code> endpoint which return an HTML viewer for STAC item</li> <li>Additional requirements: <code>titiler.extensions[\"stac\"]</code> (installs <code>rio-stac</code>)</li> </ul>"},{"location":"advanced/Extensions/#wmsextension","title":"wmsExtension","text":"<ul> <li>Goal: adds a <code>/wms</code> endpoint to support OGC WMS specification (<code>GetCapabilities</code> and <code>GetMap</code>)</li> </ul>"},{"location":"advanced/Extensions/#how-to","title":"How To","text":""},{"location":"advanced/Extensions/#use-extensions","title":"Use extensions","text":"<p>Extensions must be set at TilerFactory's creation using the <code>extensions=</code> options.</p> <pre><code>from fastapi import FastAPI\nfrom titiler.core.factory import TilerFactory\nfrom titiler.extensions import cogValidateExtension\n\n# Create a FastAPI application\napp = FastAPI(description=\"A lightweight Cloud Optimized GeoTIFF tile server\")\n\n# Create a set of endpoints using TiTiler TilerFactory\ntiler = TilerFactory(\n    router_prefix=\"/cog\",\n    extensions=[\n        cogValidateExtension()  # the cogeoExtension will add a rio-cogeo /validate endpoint\n    ]\n)\n\n# Register endpoints to the application\napp.include_router(tiler.router, prefix=\"/cog\")\n</code></pre> <p>See titiler.application for a full example.</p>"},{"location":"advanced/Extensions/#create-your-own","title":"Create your own","text":"<pre><code>from dataclasses import dataclass, field\nfrom typing import Tuple, List, Optional\n\nimport rasterio\nfrom starlette.responses import Response\nfrom fastapi import Depends, FastAPI, Query\nfrom titiler.core.factory import BaseTilerFactory, FactoryExtension, TilerFactory\nfrom titiler.core.dependencies import RescalingParams\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.resources.enums import ImageType\n\n\n@dataclass\nclass thumbnailExtension(FactoryExtension):\n    \"\"\"Add endpoint to a TilerFactory.\"\"\"\n\n    # Set some options\n    max_size: int = field(default=128)\n\n    # Register method is mandatory and must take a BaseTilerFactory object as input\n    def register(self, factory: BaseTilerFactory):\n        \"\"\"Register endpoint to the tiler factory.\"\"\"\n\n        # register an endpoint to the factory's router\n        @factory.router.get(\n            \"/thumbnail\",\n            responses={\n                200: {\n                    \"content\": {\n                        \"image/png\": {},\n                        \"image/jpeg\": {},\n                    },\n                    \"description\": \"Return an image.\",\n                }\n            },\n            response_class=Response,\n        )\n        def thumbnail(\n            # we can reuse the factory dependency\n            src_path: str = Depends(factory.path_dependency),\n            layer_params=Depends(factory.layer_dependency),\n            dataset_params=Depends(factory.dataset_dependency),\n            post_process=Depends(factory.process_dependency),\n            rescale: Optional[List[Tuple[float, ...]]] = Depends(RescalingParams),\n            color_formula: Optional[str] = Query(\n                None,\n                title=\"Color Formula\",\n                description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n            ),\n            colormap=Depends(factory.colormap_dependency),\n            render_params=Depends(factory.render_dependency),\n            reader_params=Depends(factory.reader_dependency),\n            env=Depends(factory.environment_dependency),\n        ):\n            with rasterio.Env(**env):\n                with factory.reader(src_path, **reader_params.as_dict()) as src:\n                    image = src.preview(\n                        max_size=self.max_size,\n                        **layer_params.as_dict(),\n                        **dataset_params.as_dict(),\n                    )\n\n            if post_process:\n                image = post_process(image)\n\n            if rescale:\n                image.rescale(rescale)\n\n            if color_formula:\n                image.apply_color_formula(color_formula)\n\n            format = ImageType.jpeg if image.mask.all() else ImageType.png\n\n            content = image.render(\n                img_format=format.driver,\n                colormap=colormap,\n                **format.profile,\n                **render_params.as_dict(),\n            )\n\n            return Response(content, media_type=format.mediatype)\n\n# Use it\napp = FastAPI()\ntiler = TilerFactory(\n    extensions=[\n        thumbnailExtension(max_size=64)\n    ]\n)\napp.include_router(tiler.router)\n</code></pre>"},{"location":"advanced/customization/","title":"Customization","text":"<p><code>TiTiler</code> is designed to help user customize input/output for each endpoint. This section goes over some simple customization examples.</p>"},{"location":"advanced/customization/#custom-colormap","title":"Custom Colormap","text":"<p>Add user defined colormap to the default colormaps provided by rio-tiler</p> <pre><code>from fastapi import FastAPI\n\nfrom rio_tiler.colormap import cmap as default_cmap\n\nfrom titiler.core.dependencies import create_colormap_dependency\nfrom titiler.core.factory import TilerFactory\n\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\ncmap_values = {\n    \"cmap1\": {6: (4, 5, 6, 255)},\n}\n# add custom colormap `cmap1` to the default colormaps\ncmap = default_cmap.register(cmap_values)\nColorMapParams = create_colormap_dependency(cmap)\n\n\ncog = TilerFactory(colormap_dependency=ColorMapParams)\napp.include_router(cog.router)\n</code></pre>"},{"location":"advanced/customization/#custom-datasetpathparams-for-reader_dependency","title":"Custom DatasetPathParams for <code>reader_dependency</code>","text":"<p>One common customization could be to create your own <code>path_dependency</code>. This dependency is used on all endpoint and pass inputs to the Readers (MosaicBackend, COGReader, STACReader...).</p> <p>Here an example which allow a mosaic to be passed by a <code>mosaic name</code> instead of a full S3 url.</p> <pre><code>import os\nimport re\n\nfrom fastapi import FastAPI, HTTPException, Query\n\nfrom titiler.mosaic.factory import MosaicTilerFactory\n\n\nMOSAIC_BACKEND = os.getenv(\"TITILER_MOSAIC_BACKEND\")\nMOSAIC_HOST = os.getenv(\"TITILER_MOSAIC_HOST\")\n\n\ndef MosaicPathParams(\n    mosaic: str = Query(..., description=\"mosaic name\")\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    # mosaic name should be in form of `{user}.{layername}`\n    if not re.match(self.mosaic, r\"^[a-zA-Z0-9-_]{1,32}\\.[a-zA-Z0-9-_]{1,32}$\"):\n        raise HTTPException(\n            status_code=400,\n                detail=f\"Invalid mosaic name {self.input}.\",\n            )\n\n        return f\"{MOSAIC_BACKEND}{MOSAIC_HOST}/{self.input}.json.gz\"\n\n\napp = FastAPI()\nmosaic = MosaicTilerFactory(path_dependency=MosaicPathParams)\napp.include_router(mosaic.router)\n</code></pre> <p>The endpoint url will now look like: <code>{endpoint}/mosaic/tilejson.json?mosaic=vincent.mosaic</code></p>"},{"location":"advanced/customization/#custom-tms","title":"Custom TMS","text":"<pre><code>from morecantile import tms, TileMatrixSet\nfrom pyproj import CRS\n\nfrom titiler.core.factory import TilerFactory\n\n# 1. Create Custom TMS\nEPSG6933 = TileMatrixSet.custom(\n    (-17357881.81713629, -7324184.56362408, 17357881.81713629, 7324184.56362408),\n    CRS.from_epsg(6933),\n    identifier=\"EPSG6933\",\n    matrix_scale=[1, 1],\n)\n\n# 2. Register TMS\ntms = tms.register([EPSG6933])\n\n# 3. Create Tiler\nCOGTilerWithCustomTMS = TilerFactory(supported_tms=tms)\n</code></pre>"},{"location":"advanced/customization/#add-a-mosaicjson-creation-endpoint","title":"Add a MosaicJSON creation endpoint","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\n\nfrom titiler.mosaic.factory import MosaicTilerFactory\nfrom titiler.core.errors import BadRequestError\nfrom cogeo_mosaic.mosaic import MosaicJSON\nfrom cogeo_mosaic.utils import get_footprints\nimport rasterio\n\nfrom pydantic import BaseModel\n\n\n# Models from POST/PUT Body\nclass CreateMosaicJSON(BaseModel):\n    \"\"\"Request body for MosaicJSON creation\"\"\"\n\n    files: List[str]              # Files to add to the mosaic\n    url: str                      # path where to save the mosaicJSON\n    minzoom: Optional[int] = None\n    maxzoom: Optional[int] = None\n    max_threads: int = 20\n    overwrite: bool = False\n\n\nclass UpdateMosaicJSON(BaseModel):\n    \"\"\"Request body for updating an existing MosaicJSON\"\"\"\n\n    files: List[str]              # Files to add to the mosaic\n    url: str                      # path where to save the mosaicJSON\n    max_threads: int = 20\n    add_first: bool = True\n\n\n@dataclass\nclass CustomMosaicFactory(MosaicTilerFactory):\n\n    def register_routes(self):\n        \"\"\"Update the class method to add create/update\"\"\"\n        super().register_routes()\n        # new methods/endpoint\n        self.create()\n        self.update()\n\n    def create(self):\n        \"\"\"Register / (POST) Create endpoint.\"\"\"\n\n        @self.router.post(\n            \"\", response_model=MosaicJSON, response_model_exclude_none=True\n        )\n        def create(\n            body: CreateMosaicJSON,\n            env=Depends(self.environment_dependency),\n        ):\n            \"\"\"Create a MosaicJSON\"\"\"\n            # Write can write to either a local path, a S3 path...\n            # See https://developmentseed.org/cogeo-mosaic/advanced/backends/ for the list of supported backends\n\n            # Create a MosaicJSON file from a list of URL\n            mosaic = MosaicJSON.from_urls(\n                body.files,\n                minzoom=body.minzoom,\n                maxzoom=body.maxzoom,\n                max_threads=body.max_threads,\n            )\n\n            # Write the MosaicJSON using a cogeo-mosaic backend\n            with rasterio.Env(**env):\n                with self.reader(\n                    body.url, mosaic_def=mosaic, reader=self.dataset_reader\n                ) as mosaic:\n                    try:\n                        mosaic.write(overwrite=body.overwrite)\n                    except NotImplementedError:\n                        raise BadRequestError(\n                            f\"{mosaic.__class__.__name__} does not support write operations\"\n                        )\n                    return mosaic.mosaic_def\n\n    def update(self):\n        \"\"\"Register / (PUST) Update endpoint.\"\"\"\n\n        @self.router.put(\n            \"\", response_model=MosaicJSON, response_model_exclude_none=True\n        )\n        def update_mosaicjson(\n            body: UpdateMosaicJSON,\n            env=Depends(self.environment_dependency),\n        ):\n            \"\"\"Update an existing MosaicJSON\"\"\"\n            with rasterio.Env(**env):\n                with self.reader(body.url, reader=self.dataset_reader) as mosaic:\n                    features = get_footprints(body.files, max_threads=body.max_threads)\n                    try:\n                        mosaic.update(features, add_first=body.add_first, quiet=True)\n                    except NotImplementedError:\n                        raise BadRequestError(\n                            f\"{mosaic.__class__.__name__} does not support update operations\"\n                        )\n                    return mosaic.mosaic_def\n</code></pre>"},{"location":"advanced/dependencies/","title":"Dependencies","text":"<p>If you are new to the concept of Dependency Injection, please read this awesome tutorial: fastapi.tiangolo.com/tutorial/dependencies/</p> <p>In titiler <code>Factories</code>, we use the dependencies to define the inputs for each endpoint (and thus the OpenAPI documentation).</p> <p>Example: <pre><code>from dataclasses import dataclass\nfrom fastapi import Depends, FastAPI, Query\nfrom titiler.core.dependencies import DefaultDependency\nfrom typing_extensions import Annotated\nfrom rio_tiler.io import Reader\n\n@dataclass\nclass ImageParams(DefaultDependency):\n    max_size: Annotated[\n        int, Query(description=\"Maximum image size to read onto.\")\n    ] = 1024\n\napp = FastAPI()\n\n# Simple preview endpoint\n@app.get(\"/preview.png\")\ndef preview(\n    url: str = Query(..., description=\"data set URL\"),\n    params: ImageParams = Depends(),\n):\n    with Reader(url) as cog:\n        img = cog.preview(**params.as_dict())  # we use `DefaultDependency().as_dict()` to pass only non-None parameters\n        # or\n        img = cog.preview(max_size=params.max_size)\n    ...\n</code></pre></p> <p>Important</p> <p>In the example above, we create a custom <code>ImageParams</code> dependency which will then be injected to the <code>preview</code> endpoint to add  max_size, height and width query string parameters.</p> <p>Using <code>titiler.core.dependencies.DefaultDependency</code>, we can use <code>.as_dict(exclude_none=True/False)</code> method to <code>unpack</code> the object parameters. This can be useful if method or reader do not take the same parameters.</p>"},{"location":"advanced/dependencies/#assetsparams","title":"AssetsParams","text":"<p>Define <code>assets</code>.</p> Name Type Required Default assets Query (str) No None <pre><code>@dataclass\nclass AssetsParams(DefaultDependency):\n    \"\"\"Assets parameters.\"\"\"\n\n    assets: List[str] = Query(\n        None,\n        title=\"Asset names\",\n        description=\"Asset's names.\",\n        openapi_examples={\n            \"one-asset\": {\n                \"description\": \"Return results for asset `data`.\",\n                \"value\": [\"data\"],\n            },\n            \"multi-assets\": {\n                \"description\": \"Return results for assets `data` and `cog`.\",\n                \"value\": [\"data\", \"cog\"],\n            },\n        },\n    )\n</code></pre>"},{"location":"advanced/dependencies/#assetsbidxparams","title":"AssetsBidxParams","text":"<p>Define <code>assets</code> with option of <code>per-asset</code> expression with <code>asset_expression</code> option.</p> Name Type Required Default assets Query (str) No None asset_indexes Query (str) No None asset_expression Query (str) No False <pre><code>@dataclass\nclass AssetsBidxParams(AssetsParams):\n    \"\"\"Assets, Asset's band Indexes and Asset's band Expression parameters.\"\"\"\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1;2;3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1;2;3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_expression: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band expression\",\n            description=\"Per asset band expression\",\n            openapi_examples={\n                \"one-asset\": {\n                    \"description\": \"Return results for expression `b1*b2+b3` of asset `data`.\",\n                    \"value\": [\"data|b1*b2+b3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return results for expressions `b1*b2+b3` for asset `data` and `b1+b3` for asset `cog`.\",\n                    \"value\": [\"data|b1*b2+b3\", \"cog|b1+b3\"],\n                },\n            },\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes: Dict[str, Sequence[int]] = {  # type: ignore\n                idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n                for idx in self.asset_indexes\n            }\n\n        if self.asset_expression:\n            self.asset_expression: Dict[str, str] = {  # type: ignore\n                idx.split(\"|\")[0]: idx.split(\"|\")[1] for idx in self.asset_expression\n            }\n</code></pre>"},{"location":"advanced/dependencies/#assetsbidxexprparams","title":"AssetsBidxExprParams","text":"<p>Define <code>assets</code>.</p> Name Type Required Default assets Query (str) No* None expression Query (str) No* None asset_indexes Query (str) No None asset_as_band Query (bool) No False <p>* <code>assets</code> or <code>expression</code> is required.</p> <pre><code>@dataclass\nclass AssetsBidxExprParams(AssetsParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"Band math expression between assets\",\n            openapi_examples={\n                \"simple\": {\n                    \"description\": \"Return results of expression between assets.\",\n                    \"value\": \"asset1_b1 + asset2_b1 / asset3_b1\",\n                },\n            },\n        ),\n    ] = None\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes (coma separated indexes)\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1,2,3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1,2,3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_as_band: Annotated[\n        Optional[bool],\n        Query(\n            title=\"Consider asset as a 1 band dataset\",\n            description=\"Asset as Band\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if not self.assets and not self.expression:\n            raise MissingAssets(\n                \"assets must be defined either via expression or assets options.\"\n            )\n\n        if self.asset_indexes:\n            self.asset_indexes: Dict[str, Sequence[int]] = {  # type: ignore\n                idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n                for idx in self.asset_indexes\n            }\n</code></pre>"},{"location":"advanced/dependencies/#assetsbidxexprparamsoptional","title":"AssetsBidxExprParamsOptional","text":"<p>Define <code>assets</code>. Without requirement on assets nor expression.</p> Name Type Required Default assets Query (str) No None expression Query (str) No None asset_indexes Query (str) No None asset_as_band Query (bool) No False <pre><code>@dataclass\nclass AssetsBidxExprParamsOptional(AssetsBidxExprParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters but with no requirement.\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes: Dict[str, Sequence[int]] = {  # type: ignore\n                idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n                for idx in self.asset_indexes\n            }\n</code></pre>"},{"location":"advanced/dependencies/#bandsparams","title":"BandsParams","text":"<p>Define <code>bands</code>.</p> Name Type Required Default bands Query (str) No None <pre><code>@dataclass\nclass BandsParams(DefaultDependency):\n    \"\"\"Band names parameters.\"\"\"\n\n    bands: List[str] = Query(\n        None,\n        title=\"Band names\",\n        description=\"Band's names.\",\n        openapi_examples={\n            \"one-band\": {\n                \"description\": \"Return results for band `B01`.\",\n                \"value\": [\"B01\"],\n            },\n            \"multi-bands\": {\n                \"description\": \"Return results for bands `B01` and `B02`.\",\n                \"value\": [\"B01\", \"B02\"],\n            },\n        },\n    )\n</code></pre>"},{"location":"advanced/dependencies/#bandsexprparams","title":"BandsExprParams","text":"<p>Define <code>bands</code>.</p> Name Type Required Default bands Query (str) No* None expression Query (str) No* None <p>* <code>bands</code> or <code>expression</code> is required.</p> <pre><code>@dataclass\nclass BandsExprParamsOptional(ExpressionParams, BandsParams):\n    \"\"\"Optional Band names and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#bandsexprparamsoptional","title":"BandsExprParamsOptional","text":"<p>Define <code>bands</code>.</p> Name Type Required Default bands Query (str) No None expression Query (str) No None <pre><code>@dataclass\nclass BandsExprParamsOptional(ExpressionParams, BandsParams):\n    \"\"\"Optional Band names and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#bidxparams","title":"<code>BidxParams</code>","text":"<p>Define band indexes.</p> Name Type Required Default bidx Query (int) No None <pre><code>@dataclass\nclass BidxParams(DefaultDependency):\n    \"\"\"Band Indexes parameters.\"\"\"\n\n    indexes: Annotated[\n        Optional[List[int]],\n        Query(\n            title=\"Band indexes\",\n            alias=\"bidx\",\n            description=\"Dataset band indexes\",\n            openapi_examples={\"one-band\": {\"value\": [1]}, \"multi-bands\": {\"value\": [1, 2, 3]}},\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#expressionparams","title":"<code>ExpressionParams</code>","text":"<p>Define band expression.</p> Name Type Required Default expression Query (str) No None <pre><code>@dataclass\nclass ExpressionParams(DefaultDependency):\n    \"\"\"Expression parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"rio-tiler's band math expression\",\n            openapi_examples={\n                \"simple\": {\"description\": \"Simple band math.\", \"value\": \"b1/b2\"},\n                \"multi-bands\": {\n                    \"description\": \"Semicolon (;) delimited expressions (band1: b1/b2, band2: b2+b3).\",\n                    \"value\": \"b1/b2;b2+b3\",\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#bidxexprparams","title":"<code>BidxExprParams</code>","text":"<p>Define band indexes or expression.</p> Name Type Required Default bidx Query (int) No None expression Query (str) No None <pre><code>@dataclass\nclass BidxExprParams(ExpressionParams, BidxParams):\n    \"\"\"Band Indexes and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"advanced/dependencies/#colorformulaparams","title":"<code>ColorFormulaParams</code>","text":"<p>Color Formula option (see vincentsarago/color-operations).</p> Name Type Required Default color_formula Query (str) No None <pre><code>def ColorFormulaParams(\n    color_formula: Annotated[\n        Optional[str],\n        Query(\n            title=\"Color Formula\",\n            description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n        ),\n    ] = None,\n) -&gt; Optional[str]:\n    \"\"\"ColorFormula Parameter.\"\"\"\n    return color_formula\n</code></pre>"},{"location":"advanced/dependencies/#colormapparams","title":"<code>ColorMapParams</code>","text":"<p>Colormap options. See titiler.core.dependencies.</p> Name Type Required Default colormap_name Query (str) No None colormap Query (encoded json) No None <pre><code>cmap = {}\n\ndef ColorMapParams(\n    colormap_name: Annotated[  # type: ignore\n        Literal[tuple(cmap.list())],\n        Query(description=\"Colormap name\"),\n    ] = None,\n    colormap: Annotated[\n        Optional[str], Query(description=\"JSON encoded custom Colormap\")\n    ] = None,\n):\n    if colormap_name:\n        return cmap.get(colormap_name)\n\n    if colormap:\n        try:\n            c = json.loads(\n                colormap,\n                object_hook=lambda x: {\n                    int(k): parse_color(v) for k, v in x.items()\n                },\n            )\n\n            # Make sure to match colormap type\n            if isinstance(c, Sequence):\n                c = [(tuple(inter), parse_color(v)) for (inter, v) in c]\n\n            return c\n        except json.JSONDecodeError as e:\n            raise HTTPException(\n                status_code=400, detail=\"Could not parse the colormap value.\"\n            ) from e\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#coordcrsparams","title":"CoordCRSParams","text":"<p>Define input Coordinate Reference System.</p> Name Type Required Default crs Query (str) No None <pre><code>def CoordCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"coord_crs\",\n            description=\"Coordinate Reference System of the input coords. Default to `epsg:4326`.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#datasetparams","title":"<code>DatasetParams</code>","text":"<p>Overwrite <code>nodata</code> value, apply <code>rescaling</code> and change the <code>I/O</code> or <code>Warp</code> resamplings.</p> Name Type Required Default nodata Query (str, int, float) No None unscale Query (bool) No False resampling Query (str) No 'nearest' reproject Query (str) No 'nearest' <pre><code>@dataclass\nclass DatasetParams(DefaultDependency):\n    \"\"\"Low level WarpedVRT Optional parameters.\"\"\"\n\n    nodata: Annotated[\n        Optional[Union[str, int, float]],\n        Query(\n            title=\"Nodata value\",\n            description=\"Overwrite internal Nodata value\",\n        ),\n    ] = None\n    unscale: Annotated[\n        bool,\n        Query(\n            title=\"Apply internal Scale/Offset\",\n            description=\"Apply internal Scale/Offset. Defaults to `False` in rio-tiler.\",\n        ),\n    ] = False\n    resampling_method: Annotated[\n        Optional[RIOResampling],\n        Query(\n            alias=\"resampling\",\n            description=\"RasterIO resampling algorithm. Defaults to `nearest` in rio-tiler.\",\n        ),\n    ] = None\n    reproject_method: Annotated[\n        Optional[WarpResampling],\n        Query(\n            alias=\"reproject\",\n            description=\"WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest` in rio-tiler.\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.nodata is not None:\n            self.nodata = numpy.nan if self.nodata == \"nan\" else float(self.nodata)\n\n        if self.unscale is not None:\n            self.unscale = bool(self.unscale)\n</code></pre>"},{"location":"advanced/dependencies/#datasetpathparams","title":"<code>DatasetPathParams</code>","text":"<p>Set dataset path.</p> Name Type Required Default url Query (str) Yes - <pre><code>def DatasetPathParams(\n    url: Annotated[str, Query(description=\"Dataset URL\")]\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    return url\n</code></pre>"},{"location":"advanced/dependencies/#dstcrsparams","title":"DstCRSParams","text":"<p>Define output Coordinate Reference System.</p> Name Type Required Default crs Query (str) No None <pre><code>def DstCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"dst_crs\",\n            description=\"Output Coordinate Reference System.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#histogramparams","title":"HistogramParams","text":"<p>Define numpy's histogram options.</p> Name Type Required Default histogram_bins Query (encoded list of Number) No 10 histogram_range Query (encoded list of Number) No None <pre><code>@dataclass\nclass HistogramParams(DefaultDependency):\n    \"\"\"Numpy Histogram options.\"\"\"\n\n    bins: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_bins\",\n            title=\"Histogram bins.\",\n            description=\"\"\"\nDefines the number of equal-width bins in the given range (10, by default).\n\nIf bins is a sequence (comma `,` delimited values), it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            openapi_examples={\n                \"simple\": {\n                    \"description\": \"Defines the number of equal-width bins\",\n                    \"value\": 8,\n                },\n                \"array\": {\n                    \"description\": \"Defines custom bin edges (comma `,` delimited values)\",\n                    \"value\": \"0,100,200,300\",\n                },\n            },\n        ),\n    ] = None\n\n    range: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_range\",\n            title=\"Histogram range\",\n            description=\"\"\"\nComma `,` delimited range of the bins.\n\nThe lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()).\n\nValues outside the range are ignored. The first element of the range must be less than or equal to the second.\nrange affects the automatic bin computation as well.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            examples=\"0,1000\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.bins:\n            bins = self.bins.split(\",\")\n            if len(bins) == 1:\n                self.bins = int(bins[0])  # type: ignore\n            else:\n                self.bins = list(map(float, bins))  # type: ignore\n        else:\n            self.bins = 10\n\n        if self.range:\n            self.range = list(map(float, self.range.split(\",\")))  # type: ignore\n</code></pre>"},{"location":"advanced/dependencies/#imagerenderingparams","title":"<code>ImageRenderingParams</code>","text":"<p>Control output image rendering options.</p> Name Type Required Default return_mask Query (bool) No False <pre><code>@dataclass\nclass ImageRenderingParams(DefaultDependency):\n    \"\"\"Image Rendering options.\"\"\"\n\n    add_mask: Annotated[\n        Optional[bool],\n        Query(\n            alias=\"return_mask\",\n            description=\"Add mask to the output data. Defaults to `True` in rio-tiler\",\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#partfeatureparams","title":"PartFeatureParams","text":"<p>Same as <code>PreviewParams</code> but without default <code>max_size</code>.</p> Name Type Required Default max_size Query (int) No None height Query (int) No None width Query (int) No None <pre><code>@dataclass\nclass PartFeatureParams(DefaultDependency):\n    \"\"\"Common parameters for bbox and feature.\"\"\"\n\n    max_size: Annotated[Optional[int], \"Maximum image size to read onto.\"] = None\n    height: Annotated[Optional[int], \"Force output image height.\"] = None\n    width: Annotated[Optional[int], \"Force output image width.\"] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width and self.height:\n            self.max_size = None\n</code></pre>"},{"location":"advanced/dependencies/#pixelselectionparams","title":"PixelSelectionParams","text":"<p>In <code>titiler.mosaic</code>, define pixel-selection method to apply.</p> Name Type Required Default pixel_selection Query (str) No 'first' <pre><code>def PixelSelectionParams(\n    pixel_selection: Annotated[  # type: ignore\n        Literal[tuple([e.name for e in PixelSelectionMethod])],\n        Query(description=\"Pixel selection method.\"),\n    ] = \"first\",\n) -&gt; MosaicMethodBase:\n    \"\"\"\n    Returns the mosaic method used to combine datasets together.\n    \"\"\"\n    return PixelSelectionMethod[pixel_selection].value()\n</code></pre>"},{"location":"advanced/dependencies/#previewparams","title":"PreviewParams","text":"<p>Define image output size.</p> Name Type Required Default max_size Query (int) No 1024 height Query (int) No None width Query (int) No None <pre><code>@dataclass\nclass PreviewParams(DefaultDependency):\n    \"\"\"Common Preview parameters.\"\"\"\n\n    max_size: Annotated[int, \"Maximum image size to read onto.\"] = 1024\n    height: Annotated[Optional[int], \"Force output image height.\"] = None\n    width: Annotated[Optional[int], \"Force output image width.\"] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width and self.height:\n            self.max_size = None\n</code></pre>"},{"location":"advanced/dependencies/#rescalingparams","title":"<code>RescalingParams</code>","text":"<p>Set Min/Max values to rescale from, to 0 -&gt; 255.</p> Name Type Required Default rescale Query (str, comma delimited Numer) No None <pre><code>def RescalingParams(\n    rescale: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Min/Max data Rescaling\",\n            description=\"comma (',') delimited Min,Max range. Can set multiple time for multiple bands.\",\n            examples=[\"0,2000\", \"0,1000\", \"0,10000\"],  # band 1  # band 2  # band 3\n        ),\n    ] = None,\n) -&gt; Optional[RescaleType]:\n    \"\"\"Min/Max data Rescaling\"\"\"\n    if rescale:\n        return [tuple(map(float, r.replace(\" \", \"\").split(\",\"))) for r in rescale]\n\n    return None\n</code></pre>"},{"location":"advanced/dependencies/#statisticsparams","title":"StatisticsParams","text":"<p>Define options for rio-tiler's statistics method.</p> Name Type Required Default categorical Query (bool) No False categories Query (list of Number) No None p Query (list of Number) No [2, 98] <pre><code>@dataclass\nclass StatisticsParams(DefaultDependency):\n    \"\"\"Statistics options.\"\"\"\n\n    categorical: Annotated[\n        Optional[bool],\n        Query(description=\"Return statistics for categorical dataset. Defaults to `False` in rio-tiler\"),\n    ] = None\n    categories: Annotated[\n        Optional[List[Union[float, int]]],\n        Query(\n            alias=\"c\",\n            title=\"Pixels values for categories.\",\n            description=\"List of values for which to report counts.\",\n            examples=[1, 2, 3],\n        ),\n    ] = None\n    percentiles: Annotated[\n        Optional[List[int]],\n        Query(\n            alias=\"p\",\n            title=\"Percentile values\",\n            description=\"List of percentile values (default to [2, 98]).\",\n            examples=[2, 5, 95, 98],\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Set percentiles default.\"\"\"\n        if not self.percentiles:\n            self.percentiles = [2, 98]\n</code></pre>"},{"location":"advanced/dependencies/#tileparams","title":"TileParams","text":"<p>Defile <code>buffer</code> and <code>padding</code> to apply at tile creation.</p> Name Type Required Default buffer Query (float) No None padding Query (int) No None <pre><code>@dataclass\nclass TileParams(DefaultDependency):\n    \"\"\"Tile options.\"\"\"\n\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None\n\n    padding: Annotated[\n        Optional[int],\n        Query(\n            gt=0,\n            title=\"Tile padding.\",\n            description=\"Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"advanced/dependencies/#algorithmdependency","title":"<code>algorithm.dependency</code>","text":"<p>Control which <code>algorithm</code> to apply to the data.</p> <p>See titiler.core.algorithm.</p> Name Type Required Default algorithm Query (str) No None algorithm_params Query (encoded json) No None <pre><code>algorithms = {}\n\ndef post_process(\n    algorithm: Annotated[\n        Literal[tuple(algorithms.keys())],\n        Query(description=\"Algorithm name\"),\n    ] = None,\n    algorithm_params: Annotated[\n        Optional[str],\n        Query(description=\"Algorithm parameter\"),\n    ] = None,\n) -&gt; Optional[BaseAlgorithm]:\n    \"\"\"Data Post-Processing options.\"\"\"\n    kwargs = json.loads(algorithm_params) if algorithm_params else {}\n    if algorithm:\n        try:\n            return algorithms.get(algorithm)(**kwargs)\n\n        except ValidationError as e:\n            raise HTTPException(status_code=400, detail=str(e)) from e\n\n    return None\n</code></pre>"},{"location":"advanced/endpoints_factories/","title":"Endpoints Factories","text":"<p>TiTiler's endpoints factories are helper functions that let users create a FastAPI router (<code>fastapi.APIRouter</code>) with a minimal set of endpoints.</p> <p>Important</p> <p>Most of <code>tiler</code> Factories are built around <code>rio_tiler.io.BaseReader</code>, which defines basic methods to access datasets (e.g COG or STAC). The default reader is <code>Reader</code> for <code>TilerFactory</code> and <code>MosaicBackend</code> for <code>MosaicTilerFactory</code>.</p> <p>Factories classes use dependencies injection to define most of the endpoint options.</p>"},{"location":"advanced/endpoints_factories/#basetilerfactory","title":"BaseTilerFactory","text":"<p>class: <code>titiler.core.factory.BaseTilerFactory</code></p> <p>Most Factories are built from this abstract based class which is used to define commons attributes and utility functions shared between all factories.</p>"},{"location":"advanced/endpoints_factories/#methods","title":"Methods","text":"<ul> <li>register_routes: Abstract method which needs to be define by each factories.</li> <li>url_for: Method to construct endpoint URL</li> <li>add_route_dependencies: Add dependencies to routes.</li> </ul>"},{"location":"advanced/endpoints_factories/#attributes","title":"Attributes","text":"<ul> <li>reader: Dataset Reader required.</li> <li>router: FastAPI router. Defaults to <code>fastapi.APIRouter</code>.</li> <li>path_dependency: Dependency to use to define the dataset url. Defaults to <code>titiler.core.dependencies.DatasetPathParams</code>.</li> <li>layer_dependency: Dependency to define band indexes or expression. Defaults to <code>titiler.core.dependencies.BidxExprParams</code>.</li> <li>dataset_dependency: Dependency to overwrite <code>nodata</code> value, apply <code>rescaling</code> and change the <code>I/O</code> or <code>Warp</code> resamplings. Defaults to <code>titiler.core.dependencies.DatasetParams</code>.</li> <li>process_dependency: Dependency to control which <code>algorithm</code> to apply to the data. Defaults to <code>titiler.core.algorithm.algorithms.dependency</code>.</li> <li>rescale_dependency: Dependency to set Min/Max values to rescale from, to 0 -&gt; 255. Defaults to <code>titiler.core.dependencies.RescalingParams</code>.</li> <li>color_formula_dependency: Dependency to define the Color Formula. Defaults to <code>titiler.core.dependencies.ColorFormulaParams</code>.</li> <li>colormap_dependency: Dependency to define the Colormap options. Defaults to <code>titiler.core.dependencies.ColorMapParams</code></li> <li>render_dependency: Dependency to control output image rendering options. Defaults to <code>titiler.core.dependencies.ImageRenderingParams</code></li> <li>reader_dependency: Dependency to control options passed to the reader instance init. Defaults to <code>titiler.core.dependencies.DefaultDependency</code></li> <li>environment_dependency: Dependency to defile GDAL environment at runtime. Default to <code>lambda: {}</code>.</li> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> <li>default_tms: Default <code>TileMatrixSet</code> identifier to use. Defaults to <code>WebMercatorQuad</code>.</li> <li>router_prefix: Set prefix to all factory's endpoint. Defaults to <code>\"\"</code>.</li> <li>optional_headers: List of <code>OptionalHeader</code> which endpoints could add (if implemented). Defaults to <code>[]</code>.</li> <li>route_dependencies: Additional routes dependencies to add after routes creations. Defaults to <code>[]</code>.</li> <li>extension: TiTiler extensions to register after endpoints creations. Defaults to <code>[]</code>.</li> <li>templates: Jinja2 templates to use in endpoints. Defaults to <code>titiler.core.factory.DEFAULT_TEMPLATES</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#tilerfactory","title":"TilerFactory","text":"<p>class: <code>titiler.core.factory.TilerFactory</code></p> <p>Factory meant to create endpoints for single dataset using rio-tiler's <code>Reader</code>.</p>"},{"location":"advanced/endpoints_factories/#attributes_1","title":"Attributes","text":"<ul> <li>reader: Dataset Reader. Defaults to <code>Reader</code>.</li> <li>stats_dependency: Dependency to define options for rio-tiler's statistics method used in <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.StatisticsParams</code>.</li> <li>histogram_dependency: Dependency to define numpy's histogram options used in <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.HistogramParams</code>.</li> <li>img_preview_dependency: Dependency to define image size for <code>/preview</code> and <code>/statistics</code> endpoints. Defaults to <code>titiler.core.dependencies.PreviewParams</code>.</li> <li>img_part_dependency: Dependency to define image size for <code>/bbox</code> and <code>/feature</code> endpoints. Defaults to <code>titiler.core.dependencies.PartFeatureParams</code>.</li> <li>tile_dependency: Dependency to defile <code>buffer</code> and <code>padding</code> to apply at tile creation. Defaults to <code>titiler.core.dependencies.TileParams</code>.</li> <li>add_preview: . Add <code>/preview</code> endpoint to the router. Defaults to <code>True</code>.</li> <li>add_part: . Add <code>/bbox</code> and <code>/feature</code> endpoints to the router. Defaults to <code>True</code>.</li> <li>add_viewer: . Add <code>/map</code> endpoints to the router. Defaults to <code>True</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints","title":"Endpoints","text":"<pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import TilerFactory\n\n# Create FastAPI application\napp = FastAPI()\n\n# Create router and register set of endpoints\ncog = TilerFactory(\n    add_preview=True,\n    add_part=True,\n    add_viewer=True,\n)\n\n# add router endpoint to the main application\napp.include_router(cog.router)\n</code></pre> Method URL Output Description <code>GET</code> <code>/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/info</code> JSON (Info) return dataset's basic info <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return dataset's basic info as a GeoJSON feature <code>GET</code> <code>/statistics</code> JSON (Statistics) return dataset's statistics <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) return dataset's statistics for a GeoJSON <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a dataset <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel values from a dataset <code>GET</code> <code>/preview[.{format}]</code> image/bin create a preview image from a dataset Optional <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of a dataset Optional <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a GeoJSON feature Optional <code>GET</code> <code>/{tileMatrixSetId}/map</code> HTML return a simple map viewer Optional"},{"location":"advanced/endpoints_factories/#multibasetilerfactory","title":"MultiBaseTilerFactory","text":"<p>class: <code>titiler.core.factory.MultiBaseTilerFactory</code></p> <p>Custom <code>TilerFactory</code> to be used with <code>rio_tiler.io.MultiBaseReader</code> type readers (e.g <code>rio_tiler.io.STACReader</code>).</p>"},{"location":"advanced/endpoints_factories/#attributes_2","title":"Attributes","text":"<ul> <li>reader: <code>MultiBase</code> Dataset Reader required.</li> <li>layer_dependency: Dependency to define assets or expression. Defaults to <code>titiler.core.dependencies.AssetsBidxExprParams</code>.</li> <li>assets_dependency: Dependency to define assets to be used. Defaults to <code>titiler.core.dependencies.AssetsParams</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints_1","title":"Endpoints","text":"<pre><code>from fastapi import FastAPI\n\nfrom rio_tiler.io import STACReader  # STACReader is a MultiBaseReader\n\nfrom titiler.core.factory import MultiBaseTilerFactory\n\napp = FastAPI()\nstac = MultiBaseTilerFactory(reader=STACReader)\napp.include_router(stac.router)\n</code></pre> Method URL Output Description <code>GET</code> <code>/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/assets</code> JSON return the list of available assets <code>GET</code> <code>/info</code> JSON (Info) return assets basic info <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return assets basic info as a GeoJSON feature <code>GET</code> <code>/asset_statistics</code> JSON (Statistics) return per asset statistics <code>GET</code> <code>/statistics</code> JSON (Statistics) return assets statistics (merged) <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) return assets statistics for a GeoJSON (merged) <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from assets <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel values from assets <code>GET</code> <code>/preview[.{format}]</code> image/bin create a preview image from assets Optional <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of assets Optional <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson feature intersecting assets Optional <code>GET</code> <code>/{tileMatrixSetId}/map</code> HTML return a simple map viewer Optional"},{"location":"advanced/endpoints_factories/#multibandtilerfactory","title":"MultiBandTilerFactory","text":"<p>class: <code>titiler.core.factory.MultiBandTilerFactory</code></p> <p>Custom <code>TilerFactory</code> to be used with <code>rio_tiler.io.MultiBandReader</code> type readers.</p>"},{"location":"advanced/endpoints_factories/#attributes_3","title":"Attributes","text":"<ul> <li>reader: <code>MultiBands</code> Dataset Reader required.</li> <li>layer_dependency: Dependency to define assets or expression. Defaults to <code>titiler.core.dependencies.BandsExprParams</code>.</li> <li>bands_dependency: Dependency to define bands to be used. Defaults to <code>titiler.core.dependencies.BandsParams</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints_2","title":"Endpoints","text":"<pre><code>from fastapi import FastAPI, Query\n\n\nfrom rio_tiler_pds.landsat.aws import LandsatC2Reader  # LandsatC2Reader is a MultiBandReader\nfrom titiler.core.factory import MultiBandTilerFactory\n\n\ndef SceneIDParams(\n    sceneid: Annotated[\n        str,\n        Query(description=\"Landsat Scene ID\")\n    ]\n) -&gt; str:\n    \"\"\"Use `sceneid` in query instead of url.\"\"\"\n    return sceneid\n\n\napp = FastAPI()\nlandsat = MultiBandTilerFactory(reader=LandsatC2Reader, path_dependency=SceneIDParams)\napp.include_router(landsat.router)\n</code></pre> Method URL Output Description <code>GET</code> <code>/bounds</code> JSON (Bounds) return dataset's bounds <code>GET</code> <code>/bands</code> JSON return the list of available bands <code>GET</code> <code>/info</code> JSON (Info) return basic info for a dataset <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return basic info for a dataset as a GeoJSON feature <code>GET</code> <code>/statistics</code> JSON (Statistics) return info and statistics for a dataset <code>POST</code> <code>/statistics</code> GeoJSON (Statistics) return info and statistics for a dataset <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a dataset <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel value from a dataset <code>GET</code> <code>/preview[.{format}]</code> image/bin create a preview image from a dataset Optional <code>GET</code> <code>/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of a dataset Optional <code>POST</code> <code>/feature[/{width}x{height}][.{format}]</code> image/bin create an image from a geojson feature Optional <code>GET</code> <code>/{tileMatrixSetId}/map</code> HTML return a simple map viewer Optional"},{"location":"advanced/endpoints_factories/#mosaictilerfactory","title":"MosaicTilerFactory","text":"<p>class: <code>titiler.mosaic.factory.MosaicTilerFactory</code></p> <p>Endpoints factory for mosaics, built on top of MosaicJSON.</p>"},{"location":"advanced/endpoints_factories/#attributes_4","title":"Attributes","text":"<ul> <li>reader: <code>BaseBackend</code> Mosaic Reader required.</li> <li>dataset_reader: Dataset Reader. Defaults to <code>rio_tiler.io.Reader</code></li> <li>backend_dependency: Dependency to control options passed to the backend instance init. Defaults to <code>titiler.core.dependencies.DefaultDependency</code></li> <li>pixel_selection_dependency: Dependency to select the <code>pixel_selection</code> method. Defaults to <code>titiler.mosaic.factory.PixelSelectionParams</code>.</li> <li>tile_dependency: Dependency to defile <code>buffer</code> and <code>padding</code> to apply at tile creation. Defaults to <code>titiler.core.dependencies.TileParams</code>.</li> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> <li>default_tms: DEPRECATED, Default <code>TileMatrixSet</code> identifier to use. Defaults to <code>WebMercatorQuad</code>.</li> <li>add_viewer: . Add <code>/map</code> endpoints to the router. Defaults to <code>True</code>.</li> </ul>"},{"location":"advanced/endpoints_factories/#endpoints_3","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/</code> JSON MosaicJSON return a MosaicJSON document <code>GET</code> <code>/bounds</code> JSON (Bounds) return mosaic's bounds <code>GET</code> <code>/info</code> JSON (Info) return mosaic's basic info <code>GET</code> <code>/info.geojson</code> GeoJSON (InfoGeoJSON) return mosaic's basic info  as a GeoJSON feature <code>GET</code> <code>/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a MosaicJSON <code>GET</code> <code>/{tileMatrixSetId}/tilejson.json</code> JSON (TileJSON) return a Mapbox TileJSON document <code>GET</code> <code>/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/point/{lon},{lat}</code> JSON (Point) return pixel value from a MosaicJSON dataset <code>GET</code> <code>/{z}/{x}/{y}/assets</code> JSON return list of assets intersecting a XYZ tile <code>GET</code> <code>/{lon},{lat}/assets</code> JSON return list of assets intersecting a point <code>GET</code> <code>/{minx},{miny},{maxx},{maxy}/assets</code> JSON return list of assets intersecting a bounding box <code>GET</code> <code>/{tileMatrixSetId}/map</code> HTML return a simple map viewer Optional"},{"location":"advanced/endpoints_factories/#tmsfactory","title":"TMSFactory","text":"<p>class: <code>titiler.core.factory.TMSFactory</code></p> <p>Endpoints factory for OGC <code>TileMatrixSets</code>.</p>"},{"location":"advanced/endpoints_factories/#attributes_5","title":"Attributes","text":"<ul> <li>supported_tms: List of available TileMatrixSets. Defaults to <code>morecantile.tms</code>.</li> </ul> <pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import TMSFactory\n\napp = FastAPI()\ntms = TMSFactory()\napp.include_router(tms.router)\n</code></pre>"},{"location":"advanced/endpoints_factories/#endpoints_4","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/tileMatrixSets</code> JSON (TileMatrixSetList) retrieve the list of available tiling schemes (tile matrix sets) <code>GET</code> <code>/tileMatrixSets/{tileMatrixSetId}</code> JSON (TileMatrixSet) retrieve the definition of the specified tiling scheme (tile matrix set)"},{"location":"advanced/endpoints_factories/#algorithmfactory","title":"AlgorithmFactory","text":"<p>class: <code>titiler.core.factory.AlgorithmFactory</code></p> <p>Endpoints factory for custom algorithms.</p>"},{"location":"advanced/endpoints_factories/#attributes_6","title":"Attributes","text":"<ul> <li>supported_algorithm: List of available <code>Algorithm</code>. Defaults to <code>titiler.core.algorithm.algorithms</code>.</li> </ul> <pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import AlgorithmFactory\n\napp = FastAPI()\nalgo = AlgorithmFactory()\napp.include_router(algo.router)\n</code></pre>"},{"location":"advanced/endpoints_factories/#endpoints_5","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/algorithms</code> JSON (Dict of Algorithm Metadata) retrieve the list of available Algorithms <code>GET</code> <code>/algorithms/{algorithmId}</code> JSON (Algorithm Metadata) retrieve the metadata of the specified algorithm."},{"location":"advanced/endpoints_factories/#colormapfactory","title":"ColorMapFactory","text":"<p>class: <code>titiler.core.factory.ColorMapFactory</code></p> <p>Endpoints factory for colorMaps metadata.</p>"},{"location":"advanced/endpoints_factories/#attributes_7","title":"Attributes","text":"<ul> <li>supported_colormaps: List of available <code>ColorMaps</code>. Defaults to <code>rio_tiler.colormap.cmap</code>.</li> </ul> <pre><code>from fastapi import FastAPI\n\nfrom titiler.core.factory import ColorMapFactory\n\napp = FastAPI()\ncolormap = ColorMapFactory()\napp.include_router(colormap.router)\n</code></pre>"},{"location":"advanced/endpoints_factories/#endpoints_6","title":"Endpoints","text":"Method URL Output Description <code>GET</code> <code>/colorMaps</code> JSON (colorMapList) retrieve the list of available colorMaps <code>GET</code> <code>/colorMaps/{colorMapId}</code> JSON (colorMap) retrieve the metadata or image of the specified colorMap."},{"location":"advanced/performance_tuning/","title":"Performance Tuning","text":""},{"location":"advanced/performance_tuning/#overview","title":"Overview","text":"<p>Titiler makes use of several great underlying libraries, including GDAL and Python bindings to GDAL. An effective deployment of titiler generally requires tweaking GDAL configuration settings. This document provides an overview of relevant settings. Full documentation from GDAL is available here.</p>"},{"location":"advanced/performance_tuning/#gdal-configuration","title":"GDAL Configuration","text":""},{"location":"advanced/performance_tuning/#setting-a-config-variable","title":"Setting a config variable","text":"<p>GDAL configuration is modified using environment variables. Thus in order to change a setting you'll need to set environment variables through your deployment mechanism. For example, in order to test locally you'd set an environment variable in bash:</p> <pre><code>export GDAL_HTTP_MULTIPLEX=YES\n</code></pre>"},{"location":"advanced/performance_tuning/#available-configuration-settings","title":"Available configuration settings","text":""},{"location":"advanced/performance_tuning/#gdal_http_merge_consecutive_ranges","title":"<code>GDAL_HTTP_MERGE_CONSECUTIVE_RANGES</code>","text":"<p>When set to <code>YES</code>, this tells GDAL to merge adjacent range requests. Instead of making two requests for byte ranges <code>1-5</code> and <code>6-10</code>, it would make a single request for <code>1-10</code>. This should always be set to <code>YES</code>.</p>"},{"location":"advanced/performance_tuning/#gdal_disable_readdir_on_open","title":"<code>GDAL_DISABLE_READDIR_ON_OPEN</code>","text":"<p>This is a very important setting to control the number of requests GDAL makes.</p> <p>This setting has two options: <code>FALSE</code> and <code>EMPTY_DIR</code>. <code>FALSE</code> (the default) causes GDAL to try to establish a list of all the available files in the directory. <code>EMPTY_DIR</code> tells GDAL to imagine that the directory is empty except for the requested file.</p> <p>When reading datasets with necessary external sidecar files, it's imperative to set <code>FALSE</code>. For example, the <code>landsat-pds</code> bucket on AWS S3 contains GeoTIFF images where overviews are in external <code>.ovr</code> files. If set to <code>EMPTY_DIR</code>, GDAL won't find the <code>.ovr</code> files.</p> <p>However, in all other cases, it's much better to set <code>EMPTY_DIR</code> because this prevents GDAL from making a <code>LIST</code> request.</p> <p>This setting also has cost implications for reading data from requester-pays buckets. When set to <code>FALSE</code>, GDAL makes a <code>LIST</code> request every time it opens a file. Since <code>LIST</code> requests are much more expensive than <code>GET</code> requests, this can bring unexpected costs.</p>"},{"location":"advanced/performance_tuning/#cpl_vsil_curl_allowed_extensions","title":"<code>CPL_VSIL_CURL_ALLOWED_EXTENSIONS</code>","text":"<p>A list of file extensions that GDAL is allowed to open. For example if set to <code>.tif</code>, then GDAL would only open files with a <code>.tif</code> extension. For example, it would fail on JPEG2000 files with a <code>.jp2</code> extension, but also wouldn't open GeoTIFFs exposed through an API endpoint that don't have a <code>.tif</code> suffix.</p> <p>Note that you also need to include extensions of external overview files. For example, the <code>landsat-pds</code> bucket on AWS S3 has external overviews in <code>.ovr</code> files, so if you wished to read this data, you'd want</p>"},{"location":"advanced/performance_tuning/#gdal_ingested_bytes_at_open","title":"<code>GDAL_INGESTED_BYTES_AT_OPEN</code>","text":"<p>Gives the number of initial bytes GDAL should read when opening a file and inspecting its metadata.</p> <p>Titiler works best with Cloud-Optimized GeoTIFFs (COGs) because they have a tiled internal structure that supports efficient random reads. These files have an initial metadata section that describes the location (byte range) within the file of each internal tile. The more internal tiles the COG has, the more data the header needs to contain.</p> <p>GDAL needs to read the entire header before it can read any other portion of the file. By default GDAL reads the first 16KB of the file, then if that doesn't contain the entire metadata, it makes one more request for the rest of the metadata.</p> <p>In environments where latency is relatively high (at least compared to bandwidth), such as AWS S3, it may be beneficial to increase this value depending on the data you expect to read.</p> <p>There isn't currently a way to get the number of header bytes using GDAL, but alternative GeoTIFF readers such as <code>aiocogeo</code> can. Using its cli you can find the image's header size:</p> <pre><code>export AWS_REQUEST_PAYER=\"requester\"\naiocogeo info s3://usgs-landsat/collection02/level-2/standard/oli-tirs/2020/072/076/LC08_L2SR_072076_20201203_20210313_02_T2/LC08_L2SR_072076_20201203_20210313_02_T2_SR_B1.TIF\n\n          PROFILE\n            ...\n            Header size:      32770\n</code></pre> <p>It's wise to inspect the header sizes of your data sources, and set <code>GDAL_INGESTED_BYTES_AT_OPEN</code> appropriately. Beware, however, that the given number of bytes will be read for every image, so you don't want to make the value too large.</p>"},{"location":"advanced/performance_tuning/#gdal_cachemax","title":"<code>GDAL_CACHEMAX</code>","text":"<p>Default GDAL block cache. The value can be either in Mb, bytes or percent of the physical RAM</p> <p>Recommended: 200 (200Mb)</p>"},{"location":"advanced/performance_tuning/#cpl_vsil_curl_cache_size","title":"<code>CPL_VSIL_CURL_CACHE_SIZE</code>","text":"<p>A global least-recently-used cache shared among all downloaded content and may be reused after a file handle has been closed and reopen</p> <p>Recommended: 200000000 (200Mb)</p>"},{"location":"advanced/performance_tuning/#vsi_cache","title":"<code>VSI_CACHE</code>","text":"<p>Setting this to <code>TRUE</code> enables GDAL to use an internal caching mechanism. It's</p> <p>Recommended (Strongly): TRUE.</p>"},{"location":"advanced/performance_tuning/#vsi_cache_size","title":"<code>VSI_CACHE_SIZE</code>","text":"<p>The size of the above VSI cache in bytes per-file handle. If you open a VRT with 10 files and your VSI_CACHE_SIZE is 10 bytes, the total cache memory usage would be 100 bytes. The cache is RAM based and the content of the cache is discarded when the file handle is closed.</p> <p>Recommended: 5000000 (5Mb per file handle)</p>"},{"location":"advanced/performance_tuning/#gdal_band_block_cache","title":"<code>GDAL_BAND_BLOCK_CACHE</code>","text":"<p>GDAL Block Cache type: <code>ARRAY</code> or <code>HASHSET</code>. See gdal.org/development/rfc/rfc26_blockcache.html</p>"},{"location":"advanced/performance_tuning/#proj_network","title":"<code>PROJ_NETWORK</code>","text":"<p>Introduced with GDAL 3 and PROJ&gt;7, the PROJ library can fetch more precise transformation grids hosted on the cloud.</p> <p>Values: ON/OFF</p> <p>Ref: proj.org/usage/network.html</p>"},{"location":"advanced/performance_tuning/#gdal_http_multiplex","title":"<code>GDAL_HTTP_MULTIPLEX</code>","text":"<p>When set to <code>YES</code>, this attempts to download multiple range requests in parallel, reusing the same TCP connection. Note this is only possible when the server supports HTTP2, which many servers don't yet support. There's no downside to setting <code>YES</code> here.</p>"},{"location":"advanced/performance_tuning/#gdal_data","title":"<code>GDAL_DATA</code>","text":"<p>The <code>GDAL_DATA</code> variable tells rasterio/GDAL where the GDAL C libraries have been installed. When using rasterio wheels, GDAL_DATA must be unset.</p>"},{"location":"advanced/performance_tuning/#proj_lib","title":"<code>PROJ_LIB</code>","text":"<p>The <code>PROJ_LIB</code> variable tells rasterio/GDAL where the PROJ C libraries have been installed. When using rasterio wheels, PROJ_LIB must be unset.</p>"},{"location":"advanced/performance_tuning/#aws-configuration","title":"AWS Configuration","text":""},{"location":"advanced/performance_tuning/#aws_request_payer","title":"<code>AWS_REQUEST_PAYER</code>","text":""},{"location":"advanced/performance_tuning/#recommended-configuration-for-dynamic-tiling","title":"Recommended Configuration for dynamic tiling","text":"<ul> <li><code>CPL_VSIL_CURL_ALLOWED_EXTENSIONS=\".tif,.TIF,.tiff\"</code></li> </ul> <p>In addition to <code>GDAL_DISABLE_READDIR_ON_OPEN</code>, we set the allowed extensions to <code>.tif</code> to only enable tif files. (OPTIONAL)</p> <ul> <li><code>GDAL_CACHEMAX=\"200\"</code></li> </ul> <p>200 Mb Cache.</p> <ul> <li><code>CPL_VSIL_CURL_CACHE_SIZE=\"200000000</code></li> </ul> <p>200 Mb VSI Cache.</p> <ul> <li> <p><code>GDAL_BAND_BLOCK_CACHE=\"HASHSET\"</code></p> </li> <li> <p><code>GDAL_DISABLE_READDIR_ON_OPEN=\"EMPTY_DIR\"</code></p> </li> </ul> <p>Maybe the most important variable. Setting it to <code>EMPTY_DIR</code> reduce the number of GET/LIST requests.</p> <ul> <li><code>GDAL_HTTP_MERGE_CONSECUTIVE_RANGES=\"YES\"</code></li> </ul> <p>Tells GDAL to merge consecutive range GET requests.</p> <ul> <li><code>GDAL_HTTP_MULTIPLEX=\"YES\"</code></li> <li><code>GDAL_HTTP_VERSION=\"2\"</code></li> </ul> <p>Both Multiplex and HTTP_VERSION will only have impact if the files are stored in an environment which support HTTP 2 (e.g cloudfront).</p> <ul> <li><code>VSI_CACHE=\"TRUE\"</code></li> <li><code>VSI_CACHE_SIZE=\"5000000\"</code></li> </ul> <p>5Mb cache per file handle.</p>"},{"location":"advanced/rendering/","title":"Rendering Options","text":"<p>When using Titiler to visualize imagery, there are some helper options that change how the data appears on the screen. You can:</p> <ol> <li>Adjust band values using basic color-oriented image operations</li> <li>Apply color maps to create heat maps, colorful terrain based on band value</li> <li>Rescale images on a per-band basis</li> </ol>"},{"location":"advanced/rendering/#color-map","title":"Color Map","text":"<p>Color maps are arrays of colors, used to map pixel values to specific colors. For example, it is possible to map a single band DEM, where pixel values denote height, to a color map which shows higher values as white:</p> <p></p> <p>Titiler supports both default colormaps (each with a name) and custom color maps.</p>"},{"location":"advanced/rendering/#default-colormaps","title":"Default Colormaps","text":"<p>Default colormaps pre-made, each with a given name. These maps come from the <code>rio-tiler</code> library, which has taken colormaps packaged with Matplotlib and has added others that are commonly used with raster data.</p> <p>A list of available color maps can be found in Titiler's Swagger docs, or in the rio-tiler documentation.</p> <p>To use a default colormap, simply use the parameter <code>colormap_name</code>:</p> <pre><code>import httpx\n\nresp = httpx.get(\n    \"https://titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"colormap_name\": \"&lt;YOUR COLORMAP NAME HERE&gt;\" # e.g. autumn_r\n    }\n)\n</code></pre> <p>You can take any of the colormaps listed on <code>rio-tiler</code>, and add <code>_r</code> to reverse it.</p>"},{"location":"advanced/rendering/#custom-colormaps","title":"Custom Colormaps","text":"<p>If you'd like to specify your own colormap, you can specify your own using an encoded JSON:</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https://titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"bidx\": \"1\",\n        \"colormap\": json.dumps({\n            \"0\": \"#e5f5f9\",\n            \"10\": \"#99d8c9\",\n            \"255\": \"#2ca25f\",\n        })\n    }\n)\n</code></pre> <p>Titiler supports colormaps that are both discrete (where pixels will be one of the colors that you specify) and linear (where pixel colors will blend between the given colors).</p> <p>For more information, please check out rio-tiler's docs.</p> <p>It is also possible to add a colormap dependency to automatically apply a default colormap.</p>"},{"location":"advanced/rendering/#color-formula","title":"Color Formula","text":"<p>Color formulae are simple commands that apply color corrections to images. This is useful for reducing artefacts like atmospheric haze, dark shadows, or muted colors.</p> <p>Titiler supports color formulae as defined in Mapbox's <code>rio-color</code> plugin. These include the operations (taken from the <code>rio-color</code> docs):</p> <ul> <li> <p>Gamma adjustment adjusts RGB values according to a power law, effectively brightening or darkening the midtones. It can be very effective in satellite imagery for reducing atmospheric haze in the blue and green bands.</p> </li> <li> <p>Sigmoidal contrast adjustment can alter the contrast and brightness of an image in a way that matches human's non-linear visual perception. It works well to increase contrast without blowing out the very dark shadows or already-bright parts of the image.</p> </li> <li> <p>Saturation can be thought of as the \"colorfulness\" of a pixel. Highly saturated colors are intense and almost cartoon-like, low saturation is more muted, closer to black and white. You can adjust saturation independently of brightness and hue but the data must be transformed into a different color space.</p> </li> </ul> <p>In Titiler, color_formulae are applied through the <code>color_formula</code> parameter as a string. An example of this option in action:</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https://titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"color_formula\": \"gamma rg 1.3, sigmoidal rgb 22 0.1, saturation 1.5\"\n    }\n)\n</code></pre>"},{"location":"advanced/rendering/#rescaling","title":"Rescaling","text":"<p>Rescaling is the act of adjusting the minimum and maximum values when rendering an image. In an image with a single band, the rescaled minimum value will be set to black, and the rescaled maximum value will be set to white. This is useful if you want to accentuate features that only appear at a certain pixel value (e.g. you have a DEM, but you want to highlight how the terrain changes between sea level and 100m).</p> <p>All titiler endpoinds returning image support <code>rescale</code> parameter. The parameter should be in form of <code>\"rescale={min},{max}\"</code>.</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https;//titiler.xyz/cog/preview\",\n    params={\n        \"url\": \"&lt;YOUR DATASET URL HERE&gt;\",\n        \"rescale\": \"0,100\",\n    },\n)\n</code></pre> <p>Titiler supports rescaling on a per-band basis, using multiple <code>rescale</code> parameters.</p> <pre><code>import httpx\n\nresponse = httpx.get(\n    \"https;//titiler.xyz/cog/preview\",\n    params=(\n        (\"url\", \"&lt;YOUR DATASET URL HERE&gt;\"),\n        (\"rescale\", \"0,100\"),\n        (\"rescale\", \"0,1000\"),\n        (\"rescale\", \"0,10000\"),\n    ),\n)\n</code></pre> <p>By default, Titiler will rescale the bands using the min/max values of the input datatype. For example, PNG images 8- or 16-bit unsigned pixels, giving a possible range of 0 to 255 or 0 to 65,536, so Titiler will use these ranges to rescale to the output format.</p> <p>For certain datasets (e.g. DEMs) this default behaviour can make the image seem washed out (or even entirely one color), so if you see this happen look into rescaling your images to something that makes sense for your data.</p> <p>It is also possible to add a rescaling dependency to automatically apply a default rescale.</p>"},{"location":"api/titiler/core/dependencies/","title":"dependencies","text":""},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies","title":"titiler.core.dependencies","text":"<p>Common dependency.</p>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsBidxExprParams","title":"AssetsBidxExprParams  <code>dataclass</code>","text":"<p>               Bases: <code>AssetsParams</code>, <code>BidxParams</code></p> <p>Assets, Expression and Asset's band Indexes parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsBidxExprParams(AssetsParams, BidxParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"Band math expression between assets\",\n            openapi_examples={\n                \"simple\": {\n                    \"description\": \"Return results of expression between assets.\",\n                    \"value\": \"asset1_b1 + asset2_b1 / asset3_b1\",\n                },\n            },\n        ),\n    ] = None\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes (coma separated indexes)\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1,2,3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1,2,3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_as_band: Annotated[\n        Optional[bool],\n        Query(\n            title=\"Consider asset as a 1 band dataset\",\n            description=\"Asset as Band\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if not self.assets and not self.expression:\n            raise MissingAssets(\n                \"assets must be defined either via expression or assets options.\"\n            )\n\n        if self.asset_indexes:\n            self.asset_indexes = parse_asset_indexes(self.asset_indexes)\n\n        if self.asset_indexes and self.indexes:\n            warnings.warn(\n                \"Both `asset_bidx` and `bidx` passed; only `asset_bidx` will be considered.\",\n                UserWarning,\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsBidxExprParamsOptional","title":"AssetsBidxExprParamsOptional  <code>dataclass</code>","text":"<p>               Bases: <code>AssetsBidxExprParams</code></p> <p>Assets, Expression and Asset's band Indexes parameters but with no requirement.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsBidxExprParamsOptional(AssetsBidxExprParams):\n    \"\"\"Assets, Expression and Asset's band Indexes parameters but with no requirement.\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes = parse_asset_indexes(self.asset_indexes)\n\n        if self.asset_indexes and self.indexes:\n            warnings.warn(\n                \"Both `asset_bidx` and `bidx` passed; only `asset_bidx` will be considered.\",\n                UserWarning,\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsBidxParams","title":"AssetsBidxParams  <code>dataclass</code>","text":"<p>               Bases: <code>AssetsParams</code>, <code>BidxParams</code></p> <p>Assets, Asset's band Indexes and Asset's band Expression parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsBidxParams(AssetsParams, BidxParams):\n    \"\"\"Assets, Asset's band Indexes and Asset's band Expression parameters.\"\"\"\n\n    asset_indexes: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band indexes\",\n            description=\"Per asset band indexes\",\n            alias=\"asset_bidx\",\n            openapi_examples={\n                \"one-asset\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data`.\",\n                    \"value\": [\"data|1;2;3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return indexes 1,2,3 of asset `data` and indexes 1 of asset `cog`\",\n                    \"value\": [\"data|1;2;3\", \"cog|1\"],\n                },\n            },\n        ),\n    ] = None\n\n    asset_expression: Annotated[\n        Optional[Sequence[str]],\n        Query(\n            title=\"Per asset band expression\",\n            description=\"Per asset band expression\",\n            openapi_examples={\n                \"one-asset\": {\n                    \"description\": \"Return results for expression `b1*b2+b3` of asset `data`.\",\n                    \"value\": [\"data|b1*b2+b3\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return results for expressions `b1*b2+b3` for asset `data` and `b1+b3` for asset `cog`.\",\n                    \"value\": [\"data|b1*b2+b3\", \"cog|b1+b3\"],\n                },\n            },\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.asset_indexes:\n            self.asset_indexes = parse_asset_indexes(self.asset_indexes)\n\n        if self.asset_expression:\n            self.asset_expression = parse_asset_expression(self.asset_expression)\n\n        if self.asset_indexes and self.indexes:\n            warnings.warn(\n                \"Both `asset_bidx` and `bidx` passed; only `asset_bidx` will be considered.\",\n                UserWarning,\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.AssetsParams","title":"AssetsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Assets parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass AssetsParams(DefaultDependency):\n    \"\"\"Assets parameters.\"\"\"\n\n    assets: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Asset names\",\n            description=\"Asset's names.\",\n            openapi_examples={\n                \"one-asset\": {\n                    \"description\": \"Return results for asset `data`.\",\n                    \"value\": [\"data\"],\n                },\n                \"multi-assets\": {\n                    \"description\": \"Return results for assets `data` and `cog`.\",\n                    \"value\": [\"data\", \"cog\"],\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BandsExprParams","title":"BandsExprParams  <code>dataclass</code>","text":"<p>               Bases: <code>ExpressionParams</code>, <code>BandsParams</code></p> <p>Band names and Expression parameters (Band or Expression required).</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BandsExprParams(ExpressionParams, BandsParams):\n    \"\"\"Band names and Expression parameters (Band or Expression required).\"\"\"\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if not self.bands and not self.expression:\n            raise MissingBands(\n                \"bands must be defined either via expression or bands options.\"\n            )\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BandsExprParamsOptional","title":"BandsExprParamsOptional  <code>dataclass</code>","text":"<p>               Bases: <code>ExpressionParams</code>, <code>BandsParams</code></p> <p>Optional Band names and Expression parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BandsExprParamsOptional(ExpressionParams, BandsParams):\n    \"\"\"Optional Band names and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BandsParams","title":"BandsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Band names parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BandsParams(DefaultDependency):\n    \"\"\"Band names parameters.\"\"\"\n\n    bands: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Band names\",\n            description=\"Band's names.\",\n            openapi_examples={\n                \"one-band\": {\n                    \"description\": \"Return results for band `B01`.\",\n                    \"value\": [\"B01\"],\n                },\n                \"multi-bands\": {\n                    \"description\": \"Return results for bands `B01` and `B02`.\",\n                    \"value\": [\"B01\", \"B02\"],\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BidxExprParams","title":"BidxExprParams  <code>dataclass</code>","text":"<p>               Bases: <code>ExpressionParams</code>, <code>BidxParams</code></p> <p>Band Indexes and Expression parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BidxExprParams(ExpressionParams, BidxParams):\n    \"\"\"Band Indexes and Expression parameters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BidxParams","title":"BidxParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Band Indexes parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass BidxParams(DefaultDependency):\n    \"\"\"Band Indexes parameters.\"\"\"\n\n    indexes: Annotated[\n        Optional[List[int]],\n        Query(\n            title=\"Band indexes\",\n            alias=\"bidx\",\n            description=\"Dataset band indexes\",\n            openapi_examples={\n                \"one-band\": {\"value\": [1]},\n                \"multi-bands\": {\"value\": [1, 2, 3]},\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DatasetParams","title":"DatasetParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Low level WarpedVRT Optional parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass DatasetParams(DefaultDependency):\n    \"\"\"Low level WarpedVRT Optional parameters.\"\"\"\n\n    nodata: Annotated[\n        Optional[Union[str, int, float]],\n        Query(\n            title=\"Nodata value\",\n            description=\"Overwrite internal Nodata value\",\n        ),\n    ] = None\n    unscale: Annotated[\n        Optional[bool],\n        Query(\n            title=\"Apply internal Scale/Offset\",\n            description=\"Apply internal Scale/Offset. Defaults to `False`.\",\n        ),\n    ] = None\n    resampling_method: Annotated[\n        Optional[RIOResampling],\n        Query(\n            alias=\"resampling\",\n            description=\"RasterIO resampling algorithm. Defaults to `nearest`.\",\n        ),\n    ] = None\n    reproject_method: Annotated[\n        Optional[WarpResampling],\n        Query(\n            alias=\"reproject\",\n            description=\"WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.nodata is not None:\n            self.nodata = numpy.nan if self.nodata == \"nan\" else float(self.nodata)\n\n        if self.unscale is not None:\n            self.unscale = bool(self.unscale)\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DefaultDependency","title":"DefaultDependency  <code>dataclass</code>","text":"<p>Dataclass with dict unpacking</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass DefaultDependency:\n    \"\"\"Dataclass with dict unpacking\"\"\"\n\n    def keys(self):\n        \"\"\"Return Keys.\"\"\"\n        warnings.warn(\n            \"Dict unpacking will be removed for `DefaultDependency` in titiler 0.19.0\",\n            DeprecationWarning,\n        )\n        return self.__dict__.keys()\n\n    def __getitem__(self, key):\n        \"\"\"Return value.\"\"\"\n        return self.__dict__[key]\n\n    def as_dict(self, exclude_none: bool = True) -&gt; Dict:\n        \"\"\"Transform dataclass to dict.\"\"\"\n        if exclude_none:\n            return {k: v for k, v in self.__dict__.items() if v is not None}\n\n        return dict(self.__dict__.items())\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DefaultDependency.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Return value.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"Return value.\"\"\"\n    return self.__dict__[key]\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DefaultDependency.as_dict","title":"as_dict","text":"<pre><code>as_dict(exclude_none: bool = True) -&gt; Dict\n</code></pre> <p>Transform dataclass to dict.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def as_dict(self, exclude_none: bool = True) -&gt; Dict:\n    \"\"\"Transform dataclass to dict.\"\"\"\n    if exclude_none:\n        return {k: v for k, v in self.__dict__.items() if v is not None}\n\n    return dict(self.__dict__.items())\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DefaultDependency.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return Keys.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def keys(self):\n    \"\"\"Return Keys.\"\"\"\n    warnings.warn(\n        \"Dict unpacking will be removed for `DefaultDependency` in titiler 0.19.0\",\n        DeprecationWarning,\n    )\n    return self.__dict__.keys()\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.ExpressionParams","title":"ExpressionParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Expression parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass ExpressionParams(DefaultDependency):\n    \"\"\"Expression parameters.\"\"\"\n\n    expression: Annotated[\n        Optional[str],\n        Query(\n            title=\"Band Math expression\",\n            description=\"rio-tiler's band math expression\",\n            openapi_examples={\n                \"simple\": {\"description\": \"Simple band math.\", \"value\": \"b1/b2\"},\n                \"multi-bands\": {\n                    \"description\": \"Semicolon (;) delimited expressions (band1: b1/b2, band2: b2+b3).\",\n                    \"value\": \"b1/b2;b2+b3\",\n                },\n            },\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.HistogramParams","title":"HistogramParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Numpy Histogram options.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass HistogramParams(DefaultDependency):\n    \"\"\"Numpy Histogram options.\"\"\"\n\n    bins: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_bins\",\n            title=\"Histogram bins.\",\n            description=\"\"\"\nDefines the number of equal-width bins in the given range (10, by default).\n\nIf bins is a sequence (comma `,` delimited values), it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            openapi_examples={\n                \"simple\": {\n                    \"description\": \"Defines the number of equal-width bins\",\n                    \"value\": 8,\n                },\n                \"array\": {\n                    \"description\": \"Defines custom bin edges (comma `,` delimited values)\",\n                    \"value\": \"0,100,200,300\",\n                },\n            },\n        ),\n    ] = None\n\n    range: Annotated[\n        Optional[str],\n        Query(\n            alias=\"histogram_range\",\n            title=\"Histogram range\",\n            description=\"\"\"\nComma `,` delimited range of the bins.\n\nThe lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()).\n\nValues outside the range are ignored. The first element of the range must be less than or equal to the second.\nrange affects the automatic bin computation as well.\n\nlink: https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\n            \"\"\",\n            examples=\"0,1000\",\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.bins:\n            bins = self.bins.split(\",\")\n            if len(bins) == 1:\n                self.bins = int(bins[0])  # type: ignore\n            else:\n                self.bins = list(map(float, bins))  # type: ignore\n        else:\n            self.bins = 10\n\n        if self.range:\n            parsed = list(map(float, self.range.split(\",\")))\n            assert (\n                len(parsed) == 2\n            ), f\"Invalid histogram_range values: {self.range}, should be of form 'min,max'\"\n\n            self.range = parsed  # type: ignore\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.ImageRenderingParams","title":"ImageRenderingParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Image Rendering options.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass ImageRenderingParams(DefaultDependency):\n    \"\"\"Image Rendering options.\"\"\"\n\n    add_mask: Annotated[\n        Optional[bool],\n        Query(\n            alias=\"return_mask\",\n            description=\"Add mask to the output data. Defaults to `True`\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.PartFeatureParams","title":"PartFeatureParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Common parameters for bbox and feature.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass PartFeatureParams(DefaultDependency):\n    \"\"\"Common parameters for bbox and feature.\"\"\"\n\n    max_size: Annotated[Optional[int], \"Maximum image size to read onto.\"] = None\n    height: Annotated[Optional[int], \"Force output image height.\"] = None\n    width: Annotated[Optional[int], \"Force output image width.\"] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width and self.height:\n            self.max_size = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.PreviewParams","title":"PreviewParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Common Preview parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass PreviewParams(DefaultDependency):\n    \"\"\"Common Preview parameters.\"\"\"\n\n    max_size: Annotated[int, \"Maximum image size to read onto.\"] = 1024\n    height: Annotated[Optional[int], \"Force output image height.\"] = None\n    width: Annotated[Optional[int], \"Force output image width.\"] = None\n\n    def __post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        if self.width and self.height:\n            self.max_size = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.StatisticsParams","title":"StatisticsParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Statistics options.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass StatisticsParams(DefaultDependency):\n    \"\"\"Statistics options.\"\"\"\n\n    categorical: Annotated[\n        Optional[bool],\n        Query(\n            description=\"Return statistics for categorical dataset. Defaults to `False`\"\n        ),\n    ] = None\n    categories: Annotated[\n        Optional[List[Union[float, int]]],\n        Query(\n            alias=\"c\",\n            title=\"Pixels values for categories.\",\n            description=\"List of values for which to report counts.\",\n            examples=[1, 2, 3],\n        ),\n    ] = None\n    percentiles: Annotated[\n        Optional[List[int]],\n        Query(\n            alias=\"p\",\n            title=\"Percentile values\",\n            description=\"List of percentile values (default to [2, 98]).\",\n            examples=[2, 5, 95, 98],\n        ),\n    ] = None\n\n    def __post_init__(self):\n        \"\"\"Set percentiles default.\"\"\"\n        if not self.percentiles:\n            self.percentiles = [2, 98]\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.TileParams","title":"TileParams  <code>dataclass</code>","text":"<p>               Bases: <code>DefaultDependency</code></p> <p>Tile options.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>@dataclass\nclass TileParams(DefaultDependency):\n    \"\"\"Tile options.\"\"\"\n\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None\n\n    padding: Annotated[\n        Optional[int],\n        Query(\n            gt=0,\n            title=\"Tile padding.\",\n            description=\"Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.\",\n        ),\n    ] = None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.BufferParams","title":"BufferParams","text":"<pre><code>BufferParams(\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None\n) -&gt; Optional[float]\n</code></pre> <p>Tile buffer Parameter.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def BufferParams(\n    buffer: Annotated[\n        Optional[float],\n        Query(\n            gt=0,\n            title=\"Tile buffer.\",\n            description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n        ),\n    ] = None,\n) -&gt; Optional[float]:\n    \"\"\"Tile buffer Parameter.\"\"\"\n    return buffer\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.ColorFormulaParams","title":"ColorFormulaParams","text":"<pre><code>ColorFormulaParams(\n    color_formula: Annotated[\n        Optional[str],\n        Query(\n            title=\"Color Formula\",\n            description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n        ),\n    ] = None\n) -&gt; Optional[str]\n</code></pre> <p>ColorFormula Parameter.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def ColorFormulaParams(\n    color_formula: Annotated[\n        Optional[str],\n        Query(\n            title=\"Color Formula\",\n            description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n        ),\n    ] = None,\n) -&gt; Optional[str]:\n    \"\"\"ColorFormula Parameter.\"\"\"\n    return color_formula\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.CoordCRSParams","title":"CoordCRSParams","text":"<pre><code>CoordCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=coord_crs,\n            description=\"Coordinate Reference System of the input coords. Default to `epsg:4326`.\",\n        ),\n    ] = None\n) -&gt; Optional[CRS]\n</code></pre> <p>Coordinate Reference System Coordinates Param.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def CoordCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"coord_crs\",\n            description=\"Coordinate Reference System of the input coords. Default to `epsg:4326`.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DatasetPathParams","title":"DatasetPathParams","text":"<pre><code>DatasetPathParams(url: Annotated[str, Query(description='Dataset URL')]) -&gt; str\n</code></pre> <p>Create dataset path from args</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def DatasetPathParams(url: Annotated[str, Query(description=\"Dataset URL\")]) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    return url\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.DstCRSParams","title":"DstCRSParams","text":"<pre><code>DstCRSParams(\n    crs: Annotated[\n        Optional[str], Query(alias=dst_crs, description=\"Output Coordinate Reference System.\")\n    ] = None\n) -&gt; Optional[CRS]\n</code></pre> <p>Coordinate Reference System Coordinates Param.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def DstCRSParams(\n    crs: Annotated[\n        Optional[str],\n        Query(\n            alias=\"dst_crs\",\n            description=\"Output Coordinate Reference System.\",\n        ),\n    ] = None,\n) -&gt; Optional[CRS]:\n    \"\"\"Coordinate Reference System Coordinates Param.\"\"\"\n    if crs:\n        return CRS.from_user_input(crs)\n\n    return None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.RescalingParams","title":"RescalingParams","text":"<pre><code>RescalingParams(\n    rescale: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Min/Max data Rescaling\",\n            description=\"comma (',') delimited Min,Max range. Can set multiple time for multiple bands.\",\n            examples=[(0, 2000), (0, 1000), (0, 10000)],\n        ),\n    ] = None\n) -&gt; Optional[RescaleType]\n</code></pre> <p>Min/Max data Rescaling</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def RescalingParams(\n    rescale: Annotated[\n        Optional[List[str]],\n        Query(\n            title=\"Min/Max data Rescaling\",\n            description=\"comma (',') delimited Min,Max range. Can set multiple time for multiple bands.\",\n            examples=[\"0,2000\", \"0,1000\", \"0,10000\"],  # band 1  # band 2  # band 3\n        ),\n    ] = None,\n) -&gt; Optional[RescaleType]:\n    \"\"\"Min/Max data Rescaling\"\"\"\n    if rescale:\n        rescale_array = []\n        for r in rescale:\n            parsed = tuple(\n                map(\n                    float,\n                    r.replace(\" \", \"\").replace(\"[\", \"\").replace(\"]\", \"\").split(\",\"),\n                )\n            )\n            assert (\n                len(parsed) == 2\n            ), f\"Invalid rescale values: {rescale}, should be of form ['min,max', 'min,max'] or [[min,max], [min, max]]\"\n            rescale_array.append(parsed)\n\n        return rescale_array\n\n    return None\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.create_colormap_dependency","title":"create_colormap_dependency","text":"<pre><code>create_colormap_dependency(cmap: ColorMaps) -&gt; Callable\n</code></pre> <p>Create Colormap Dependency.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def create_colormap_dependency(cmap: ColorMaps) -&gt; Callable:\n    \"\"\"Create Colormap Dependency.\"\"\"\n\n    def deps(\n        colormap_name: Annotated[  # type: ignore\n            Literal[tuple(cmap.list())],\n            Query(description=\"Colormap name\"),\n        ] = None,\n        colormap: Annotated[\n            Optional[str], Query(description=\"JSON encoded custom Colormap\")\n        ] = None,\n    ):\n        if colormap_name:\n            return cmap.get(colormap_name)\n\n        if colormap:\n            try:\n                c = json.loads(\n                    colormap,\n                    object_hook=lambda x: {\n                        int(k): parse_color(v) for k, v in x.items()\n                    },\n                )\n\n                # Make sure to match colormap type\n                if isinstance(c, Sequence):\n                    c = [(tuple(inter), parse_color(v)) for (inter, v) in c]\n\n                return c\n            except json.JSONDecodeError as e:\n                raise HTTPException(\n                    status_code=400, detail=\"Could not parse the colormap value.\"\n                ) from e\n\n        return None\n\n    return deps\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.parse_asset_expression","title":"parse_asset_expression","text":"<pre><code>parse_asset_expression(asset_expression: Union[Sequence[str], Dict[str, str]]) -&gt; Dict[str, str]\n</code></pre> <p>parse asset expression parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def parse_asset_expression(\n    asset_expression: Union[Sequence[str], Dict[str, str]],\n) -&gt; Dict[str, str]:\n    \"\"\"parse asset expression parameters.\"\"\"\n    return {idx.split(\"|\")[0]: idx.split(\"|\")[1] for idx in asset_expression}\n</code></pre>"},{"location":"api/titiler/core/dependencies/#titiler.core.dependencies.parse_asset_indexes","title":"parse_asset_indexes","text":"<pre><code>parse_asset_indexes(\n    asset_indexes: Union[Sequence[str], Dict[str, Sequence[int]]]\n) -&gt; Dict[str, Sequence[int]]\n</code></pre> <p>parse asset indexes parameters.</p> Source code in <code>titiler/core/dependencies.py</code> <pre><code>def parse_asset_indexes(\n    asset_indexes: Union[Sequence[str], Dict[str, Sequence[int]]],\n) -&gt; Dict[str, Sequence[int]]:\n    \"\"\"parse asset indexes parameters.\"\"\"\n    return {\n        idx.split(\"|\")[0]: list(map(int, idx.split(\"|\")[1].split(\",\")))\n        for idx in asset_indexes\n    }\n</code></pre>"},{"location":"api/titiler/core/errors/","title":"errors","text":""},{"location":"api/titiler/core/errors/#titiler.core.errors","title":"titiler.core.errors","text":"<p>Titiler error classes.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.BadRequestError","title":"BadRequestError","text":"<p>               Bases: <code>TilerError</code></p> <p>Bad request error.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.TileNotFoundError","title":"TileNotFoundError","text":"<p>               Bases: <code>TilerError</code></p> <p>Tile not found error.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.TilerError","title":"TilerError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.add_exception_handlers","title":"add_exception_handlers","text":"<pre><code>add_exception_handlers(app: FastAPI, status_codes: Dict[Type[Exception], int]) -&gt; None\n</code></pre> <p>Add exception handlers to the FastAPI app.</p>"},{"location":"api/titiler/core/errors/#titiler.core.errors.exception_handler_factory","title":"exception_handler_factory","text":"<pre><code>exception_handler_factory(status_code: int) -&gt; Callable\n</code></pre> <p>Create a FastAPI exception handler from a status code.</p>"},{"location":"api/titiler/core/factory/","title":"factory","text":""},{"location":"api/titiler/core/factory/#titiler.core.factory","title":"titiler.core.factory","text":"<p>TiTiler Router factories.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.AlgorithmFactory","title":"AlgorithmFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>Algorithm endpoints Factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.AlgorithmFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>Register Algorithm routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory","title":"BaseFactory","text":"<p>Base Factory.</p> <p>Abstract Base Class which defines most inputs used by dynamic tiler.</p> <p>Attributes:</p> <ul> <li> <code>router</code>               (<code>APIRouter</code>)           \u2013            <p>Application router to register endpoints to.</p> </li> <li> <code>router_prefix</code>               (<code>str</code>)           \u2013            <p>prefix where the router will be mounted in the application.</p> </li> </ul>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.__attrs_post_init__","title":"__attrs_post_init__","text":"<pre><code>__attrs_post_init__()\n</code></pre> <p>Post Init: register route and configure specific options.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.add_route_dependencies","title":"add_route_dependencies","text":"<pre><code>add_route_dependencies(*, scopes: List[EndpointScope], dependencies=List[DependsFunc])\n</code></pre> <p>Add dependencies to routes.</p> <p>Allows a developer to add dependencies to a route after the route has been defined.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.register_routes","title":"register_routes  <code>abstractmethod</code>","text":"<pre><code>register_routes()\n</code></pre> <p>Register Routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.BaseFactory.url_for","title":"url_for","text":"<pre><code>url_for(request: Request, name: str, **path_params: Any) -&gt; str\n</code></pre> <p>Return full url (with prefix) for a specific endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.ColorMapFactory","title":"ColorMapFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>Colormap endpoints Factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.ColorMapFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>Register ColorMap routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.FactoryExtension","title":"FactoryExtension","text":"<p>Factory Extension.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.FactoryExtension.register","title":"register  <code>abstractmethod</code>","text":"<pre><code>register(factory: BaseFactory)\n</code></pre> <p>Register extension to the factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBandTilerFactory","title":"MultiBandTilerFactory","text":"<p>               Bases: <code>TilerFactory</code></p> <p>Custom Tiler Factory for MultiBandReader classes.</p> Note <p>To be able to use the rio_tiler.io.MultiBandReader we need to be able to pass a <code>bands</code> argument to most of its methods. By using the <code>BandsExprParams</code> for the <code>layer_dependency</code>, the .tile(), .point(), .preview() and the .part() methods will receive bands or expression arguments.</p> <p>The rio_tiler.io.MultiBandReader  <code>.info()</code> and <code>.metadata()</code> have <code>bands</code> as a requirement arguments (github.com/cogeotiff/rio-tiler/blob/main/rio_tiler/io/base.py#L775). This means we have to update the /info and /metadata endpoints in order to add the <code>bands</code> dependency.</p> <p>For implementation example see developmentseed/titiler-pds</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBandTilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBandTilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>add statistics endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBaseTilerFactory","title":"MultiBaseTilerFactory","text":"<p>               Bases: <code>TilerFactory</code></p> <p>Custom Tiler Factory for MultiBaseReader classes.</p> Note <p>To be able to use the rio_tiler.io.MultiBaseReader we need to be able to pass a <code>assets</code> argument to most of its methods. By using the <code>AssetsBidxExprParams</code> for the <code>layer_dependency</code>, the .tile(), .point(), .preview() and the .part() methods will receive assets, expression or indexes arguments.</p> <p>The rio_tiler.io.MultiBaseReader  <code>.info()</code> and <code>.metadata()</code> have <code>assets</code> as a requirement arguments (github.com/cogeotiff/rio-tiler/blob/main/rio_tiler/io/base.py#L365). This means we have to update the /info and /metadata endpoints in order to add the <code>assets</code> dependency.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBaseTilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.MultiBaseTilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>Register /statistics endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TMSFactory","title":"TMSFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>TileMatrixSet endpoints Factory.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TMSFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>Register TMS endpoint routes.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory","title":"TilerFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>Tiler Factory.</p> <p>Attributes:</p> <ul> <li> <code>reader</code>               (<code>BaseReader</code>)           \u2013            <p>A rio-tiler reader. Defaults to <code>rio_tiler.io.Reader</code>.</p> </li> <li> <code>path_dependency</code>               (<code>Callable</code>)           \u2013            <p>Endpoint dependency defining <code>path</code> to pass to the reader init.</p> </li> <li> <code>dataset_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining dataset overwriting options (e.g nodata).</p> </li> <li> <code>layer_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining dataset indexes/bands/assets options.</p> </li> <li> <code>render_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining image rendering options (e.g add_mask).</p> </li> <li> <code>colormap_dependency</code>               (<code>Callable</code>)           \u2013            <p>Endpoint dependency defining ColorMap options (e.g colormap_name).</p> </li> <li> <code>process_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining image post-processing options (e.g rescaling, color-formula).</p> </li> <li> <code>tms_dependency</code>               (<code>Callable</code>)           \u2013            <p>Endpoint dependency defining TileMatrixSet to use.</p> </li> <li> <code>reader_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining BaseReader options.</p> </li> <li> <code>environment_dependency</code>               (<code>Callable</code>)           \u2013            <p>Endpoint dependency to define GDAL environment at runtime.</p> </li> <li> <code>stats_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for rio-tiler's statistics method.</p> </li> <li> <code>histogram_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for numpy's histogram method.</p> </li> <li> <code>img_preview_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for rio-tiler's preview method.</p> </li> <li> <code>img_part_dependency</code>               (<code>DefaultDependency</code>)           \u2013            <p>Endpoint dependency defining options for rio-tiler's part/feature methods.</p> </li> <li> <code>add_preview</code>               (<code>bool</code>)           \u2013            <p>add <code>/preview</code> endpoints. Defaults to True.</p> </li> <li> <code>add_part</code>               (<code>bool</code>)           \u2013            <p>add <code>/bbox</code> and <code>/feature</code> endpoints. Defaults to True.</p> </li> <li> <code>add_viewer</code>               (<code>bool</code>)           \u2013            <p>add <code>/map</code> endpoints. Defaults to True.</p> </li> </ul>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.bounds","title":"bounds","text":"<pre><code>bounds()\n</code></pre> <p>Register /bounds endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.map_viewer","title":"map_viewer","text":"<pre><code>map_viewer()\n</code></pre> <p>Register /map endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.part","title":"part","text":"<pre><code>part()\n</code></pre> <p>Register /bbox and <code>/feature</code> endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.point","title":"point","text":"<pre><code>point()\n</code></pre> <p>Register /point endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.preview","title":"preview","text":"<pre><code>preview()\n</code></pre> <p>Register /preview endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>This Method register routes to the router.</p> <p>Because we wrap the endpoints in a class we cannot define the routes as methods (because of the self argument). The HACK is to define routes inside the class method and register them after the class initialization.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.statistics","title":"statistics","text":"<pre><code>statistics()\n</code></pre> <p>add statistics endpoints.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.tile","title":"tile","text":"<pre><code>tile()\n</code></pre> <p>Register /tiles endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.tilejson","title":"tilejson","text":"<pre><code>tilejson()\n</code></pre> <p>Register /tilejson.json endpoint.</p>"},{"location":"api/titiler/core/factory/#titiler.core.factory.TilerFactory.wmts","title":"wmts","text":"<pre><code>wmts()\n</code></pre> <p>Register /wmts endpoint.</p>"},{"location":"api/titiler/core/middleware/","title":"middleware","text":""},{"location":"api/titiler/core/middleware/#titiler.core.middleware","title":"titiler.core.middleware","text":"<p>Titiler middlewares.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.CacheControlMiddleware","title":"CacheControlMiddleware","text":"<p>MiddleWare to add CacheControl in response headers.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.CacheControlMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.CacheControlMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(\n    app: ASGIApp,\n    cachecontrol: Optional[str] = None,\n    cachecontrol_max_http_code: Optional[int] = 500,\n    exclude_path: Optional[Set[str]] = None,\n) -&gt; None\n</code></pre> <p>Init Middleware.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>ASGIApp</code>)           \u2013            <p>starlette/FastAPI application.</p> </li> <li> <code>cachecontrol</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Cache-Control string to add to the response.</p> </li> <li> <code>exclude_path</code>               (<code>set</code>, default:                   <code>None</code> )           \u2013            <p>Set of regex expression to use to filter the path.</p> </li> </ul>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LoggerMiddleware","title":"LoggerMiddleware","text":"<p>MiddleWare to add logging.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LoggerMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LoggerMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app: ASGIApp, querystrings: bool = False, headers: bool = False) -&gt; None\n</code></pre> <p>Init Middleware.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>ASGIApp</code>)           \u2013            <p>starlette/FastAPI application.</p> </li> </ul>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LowerCaseQueryStringMiddleware","title":"LowerCaseQueryStringMiddleware","text":"<p>Middleware to make URL parameters case-insensitive. taken from: tiangolo/fastapi#826</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LowerCaseQueryStringMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.LowerCaseQueryStringMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app: ASGIApp) -&gt; None\n</code></pre> <p>Init Middleware.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>ASGIApp</code>)           \u2013            <p>starlette/FastAPI application.</p> </li> </ul>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.TotalTimeMiddleware","title":"TotalTimeMiddleware","text":"<p>MiddleWare to add Total process time in response headers.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.TotalTimeMiddleware.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope: Scope, receive: Receive, send: Send)\n</code></pre> <p>Handle call.</p>"},{"location":"api/titiler/core/middleware/#titiler.core.middleware.TotalTimeMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app: ASGIApp) -&gt; None\n</code></pre> <p>Init Middleware.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>ASGIApp</code>)           \u2013            <p>starlette/FastAPI application.</p> </li> </ul>"},{"location":"api/titiler/core/routing/","title":"routing","text":""},{"location":"api/titiler/core/routing/#titiler.core.routing","title":"titiler.core.routing","text":"<p>Custom routing classes.</p>"},{"location":"api/titiler/core/routing/#titiler.core.routing.EndpointScope","title":"EndpointScope","text":"<p>               Bases: <code>TypedDict</code></p> <p>Define endpoint.</p>"},{"location":"api/titiler/core/routing/#titiler.core.routing.add_route_dependencies","title":"add_route_dependencies","text":"<pre><code>add_route_dependencies(\n    routes: List[BaseRoute], *, scopes: List[EndpointScope], dependencies=List[params.Depends]\n)\n</code></pre> <p>Add dependencies to routes.</p> <p>Allows a developer to add dependencies to a route after the route has been defined.</p>"},{"location":"api/titiler/core/routing/#titiler.core.routing.apiroute_factory","title":"apiroute_factory","text":"<pre><code>apiroute_factory(env: Optional[Dict] = None) -&gt; Type[APIRoute]\n</code></pre> <p>Create Custom API Route class with custom Env.</p> <p>Because we cannot create middleware for specific router we need to create a custom APIRoute which add the <code>rasterio.Env(</code> block before the endpoint is actually called. This way we set the env outside the threads and we make sure that event multithreaded Reader will get the environment set.</p> <p>Note: This has been tested in python 3.6 and 3.7 only.</p>"},{"location":"api/titiler/core/models/OGC/","title":"OGC","text":""},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC","title":"titiler.core.models.OGC","text":"<p>OGC models.</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.Link","title":"Link","text":"<p>               Bases: <code>BaseModel</code></p> <p>Link model.</p> <p>Ref: github.com/opengeospatial/ogcapi-tiles/blob/master/openapi/schemas/common-core/link.yaml</p> <p>Code generated using koxudaxi/datamodel-code-generator</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileMatrixSetLink","title":"TileMatrixSetLink","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileMatrixSetLink model.</p> <p>Based on docs.opengeospatial.org/per/19-069.html#_tilematrixsets</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileMatrixSetList","title":"TileMatrixSetList","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileMatrixSetList model.</p> <p>Based on docs.opengeospatial.org/per/19-069.html#_tilematrixsets</p>"},{"location":"api/titiler/core/models/OGC/#titiler.core.models.OGC.TileMatrixSetRef","title":"TileMatrixSetRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileMatrixSetRef model.</p> <p>Based on docs.opengeospatial.org/per/19-069.html#_tilematrixsets</p>"},{"location":"api/titiler/core/models/mapbox/","title":"Mapbox/MapLibre","text":""},{"location":"api/titiler/core/models/mapbox/#titiler.core.models.mapbox","title":"titiler.core.models.mapbox","text":"<p>Common response models.</p>"},{"location":"api/titiler/core/models/mapbox/#titiler.core.models.mapbox.TileJSON","title":"TileJSON","text":"<p>               Bases: <code>BaseModel</code></p> <p>TileJSON model.</p> <p>Based on github.com/mapbox/tilejson-spec/tree/master/2.2.0</p>"},{"location":"api/titiler/core/models/mapbox/#titiler.core.models.mapbox.TileJSON.compute_center","title":"compute_center","text":"<pre><code>compute_center()\n</code></pre> <p>Compute center if it does not exist.</p>"},{"location":"api/titiler/core/models/responses/","title":"responses","text":""},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses","title":"titiler.core.models.responses","text":"<p>TiTiler response models.</p>"},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses.ColorMapsList","title":"ColorMapsList","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for colormap list.</p>"},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses.Point","title":"Point","text":"<p>               Bases: <code>BaseModel</code></p> <p>Point model.</p> <p>response model for <code>/point</code> endpoints</p>"},{"location":"api/titiler/core/models/responses/#titiler.core.models.responses.StatisticsInGeoJSON","title":"StatisticsInGeoJSON","text":"<p>               Bases: <code>BaseModel</code></p> <p>Statistics model in geojson response.</p>"},{"location":"api/titiler/core/resources/enums/","title":"enums","text":""},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums","title":"titiler.core.resources.enums","text":"<p>Titiler.core Enums.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageDriver","title":"ImageDriver","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported output GDAL drivers.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType","title":"ImageType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available Output image type.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType.driver","title":"driver","text":"<pre><code>driver()\n</code></pre> <p>Return rio-tiler image default profile.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType.mediatype","title":"mediatype","text":"<pre><code>mediatype()\n</code></pre> <p>Return image media type.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.ImageType.profile","title":"profile","text":"<pre><code>profile()\n</code></pre> <p>Return rio-tiler image default profile.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.MediaType","title":"MediaType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Responses Media types formerly known as MIME types.</p>"},{"location":"api/titiler/core/resources/enums/#titiler.core.resources.enums.OptionalHeader","title":"OptionalHeader","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Optional Header to add in responses.</p>"},{"location":"api/titiler/core/resources/responses/","title":"responses","text":""},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses","title":"titiler.core.resources.responses","text":"<p>Common response models.</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.GeoJSONResponse","title":"GeoJSONResponse","text":"<p>               Bases: <code>JSONResponse</code></p> <p>GeoJSON Response</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.JSONResponse","title":"JSONResponse","text":"<p>               Bases: <code>JSONResponse</code></p> <p>Custom JSON Response.</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.JSONResponse.render","title":"render","text":"<pre><code>render(content: Any) -&gt; bytes\n</code></pre> <p>Render JSON.</p> <p>Same defaults as starlette.responses.JSONResponse.render but allow NaN to be replaced by null using simplejson</p>"},{"location":"api/titiler/core/resources/responses/#titiler.core.resources.responses.XMLResponse","title":"XMLResponse","text":"<p>               Bases: <code>Response</code></p> <p>XML Response</p>"},{"location":"api/titiler/extensions/cogeo/","title":"cogeo","text":""},{"location":"api/titiler/extensions/cogeo/#titiler.extensions.cogeo","title":"titiler.extensions.cogeo","text":"<p>rio-cogeo Extension.</p>"},{"location":"api/titiler/extensions/cogeo/#titiler.extensions.cogeo.cogValidateExtension","title":"cogValidateExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /validate endpoint to a COG TilerFactory.</p>"},{"location":"api/titiler/extensions/cogeo/#titiler.extensions.cogeo.cogValidateExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/extensions/stac/","title":"stac","text":""},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac","title":"titiler.extensions.stac","text":"<p>rio-stac Extension.</p>"},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac.Item","title":"Item","text":"<p>               Bases: <code>TypedDict</code></p> <p>STAC Item.</p>"},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac.stacExtension","title":"stacExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /stac endpoint to a COG TilerFactory.</p>"},{"location":"api/titiler/extensions/stac/#titiler.extensions.stac.stacExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/extensions/viewer/","title":"viewer","text":""},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer","title":"titiler.extensions.viewer","text":"<p>titiler Viewer Extensions.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.cogViewerExtension","title":"cogViewerExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /viewer endpoint to the TilerFactory.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.cogViewerExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.stacViewerExtension","title":"stacViewerExtension","text":"<p>               Bases: <code>FactoryExtension</code></p> <p>Add /viewer endpoint to the TilerFactory.</p>"},{"location":"api/titiler/extensions/viewer/#titiler.extensions.viewer.stacViewerExtension.register","title":"register","text":"<pre><code>register(factory: TilerFactory)\n</code></pre> <p>Register endpoint to the tiler factory.</p>"},{"location":"api/titiler/mosaic/errors/","title":"errors","text":""},{"location":"api/titiler/mosaic/errors/#titiler.mosaic.errors","title":"titiler.mosaic.errors","text":"<p>Titiler mosaic errors.</p>"},{"location":"api/titiler/mosaic/factory/","title":"factory","text":""},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory","title":"titiler.mosaic.factory","text":"<p>TiTiler.mosaic Router factories.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory","title":"MosaicTilerFactory","text":"<p>               Bases: <code>BaseFactory</code></p> <p>MosaicTiler Factory.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.assets","title":"assets","text":"<pre><code>assets()\n</code></pre> <p>Register /assets endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.bounds","title":"bounds","text":"<pre><code>bounds()\n</code></pre> <p>Register /bounds endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Register /info endpoint</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.map_viewer","title":"map_viewer","text":"<pre><code>map_viewer()\n</code></pre> <p>Register /map endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.point","title":"point","text":"<pre><code>point()\n</code></pre> <p>Register /point endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.read","title":"read","text":"<pre><code>read()\n</code></pre> <p>Register / (Get) Read endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.register_routes","title":"register_routes","text":"<pre><code>register_routes()\n</code></pre> <p>This Method register routes to the router.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.tile","title":"tile","text":"<pre><code>tile()\n</code></pre> <p>Register /tiles endpoints.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.tilejson","title":"tilejson","text":"<pre><code>tilejson()\n</code></pre> <p>Add tilejson endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.validate","title":"validate","text":"<pre><code>validate()\n</code></pre> <p>Register /validate endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.MosaicTilerFactory.wmts","title":"wmts","text":"<pre><code>wmts()\n</code></pre> <p>Add wmts endpoint.</p>"},{"location":"api/titiler/mosaic/factory/#titiler.mosaic.factory.PixelSelectionParams","title":"PixelSelectionParams","text":"<pre><code>PixelSelectionParams(\n    pixel_selection: Annotated[\n        Literal[tuple([name for e in PixelSelectionMethod])],\n        Query(description=\"Pixel selection method.\"),\n    ] = \"first\"\n) -&gt; MosaicMethodBase\n</code></pre> <p>Returns the mosaic method used to combine datasets together.</p>"},{"location":"api/titiler/mosaic/models/responses/","title":"responses","text":""},{"location":"api/titiler/mosaic/models/responses/#titiler.mosaic.models.responses","title":"titiler.mosaic.models.responses","text":"<p>TiTiler.mosaic response models.</p>"},{"location":"api/titiler/mosaic/models/responses/#titiler.mosaic.models.responses.Point","title":"Point","text":"<p>               Bases: <code>BaseModel</code></p> <p>Point model.</p> <p>response model for <code>/point</code> endpoints</p>"},{"location":"deployment/azure/","title":"Azure","text":""},{"location":"deployment/azure/#function","title":"Function","text":"<p>TiTiler is built on top of FastAPI, a modern, fast, Python web framework for building APIs. We can make our FastAPI application work as an Azure Function by wrapping it within the Azure Function Python worker.</p> <p>If you are not familiar with Azure functions we recommend checking docs.microsoft.com/en-us/azure/azure-functions/ first.</p> <p>Minimal TiTiler Azure function code: <pre><code>import azure.functions as func\nfrom titiler.application.main import cog, mosaic, stac, tms\nfrom fastapi import FastAPI\n\n\napp = FastAPI()\napp.include_router(cog.router, prefix=\"/cog\", tags=[\"Cloud Optimized GeoTIFF\"])\napp.include_router(\n    stac.router, prefix=\"/stac\", tags=[\"SpatioTemporal Asset Catalog\"]\n)\napp.include_router(mosaic.router, prefix=\"/mosaicjson\", tags=[\"MosaicJSON\"])\napp.include_router(tms.router, tags=[\"TileMatrixSets\"])\n\n\nasync def main(\n    req: func.HttpRequest, context: func.Context,\n) -&gt; func.HttpResponse:\n    return await func.AsgiMiddleware(app).handle_async(req, context)\n</code></pre></p>"},{"location":"deployment/azure/#requirements","title":"Requirements","text":"<ul> <li>Azure CLI: docs.microsoft.com/en-us/cli/azure/install-azure-cli</li> <li>Azure Function Tool: docs.microsoft.com/en-us/azure/azure-functions/functions-run-local</li> </ul>"},{"location":"deployment/azure/#deployment","title":"Deployment","text":"<p>See: docs.microsoft.com/en-us/azure/azure-functions/create-first-function-cli-python?tabs=azure-cli%2Cbash%2Cbrowser#create-supporting-azure-resources-for-your-function</p> <pre><code>$ git clone https://github.com/developmentseed/titiler.git\n$ cd titiler/deployment/azure\n\n$ az login\n$ az group create --name AzureFunctionsTiTiler-rg --location eastus\n$ az storage account create --name titilerstorage --sku Standard_LRS -g AzureFunctionsTiTiler-rg\n$ az functionapp create --consumption-plan-location eastus --runtime python --runtime-version 3.8 --functions-version 3 --name titiler --os-type linux -g AzureFunctionsTiTiler-rg -s titilerstorage\n$ func azure functionapp publish titiler\n</code></pre> <p>or</p> <p>use VScode: docs.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-python#publish-the-project-to-azure</p>"},{"location":"deployment/azure/#docs","title":"Docs","text":"<ul> <li>docs.microsoft.com/en-us/azure/azure-functions/functions-deployment-technologies</li> <li>docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings</li> <li>docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python</li> </ul>"},{"location":"deployment/k8s/","title":"k8s / Helm Deployment","text":""},{"location":"deployment/k8s/#k8s-helm-deployment","title":"k8s / Helm Deployment","text":"<p>Try locally</p> <pre><code>minikube start\nkubectl config use-context minikube\nhelm init --wait\n\n# in the k8s directory\nhelm install -f titiler/Chart.yaml titiler\n</code></pre> <p>For more info about K8S cluster and node configuration please see: developmentseed/titiler#212</p>"},{"location":"deployment/aws/ecs/","title":"AWS ECS (Fargate) + ALB (Application Load Balancer)","text":"<p>Warning</p> <pre><code>When using Fargate or vanilla ECS, you should set the number of worker carefully. Setting too high a number of workers could lead to extra charges due to a bug in fastapi (https://github.com/developmentseed/titiler/issues/119, https://github.com/tiangolo/fastapi/issues/253).\n</code></pre>"},{"location":"deployment/aws/ecs/#deploy","title":"Deploy","text":"<p>The example handles tasks such as generating a docker image and setting up an application load balancer (ALB) and ECS services.</p> <ol> <li> <p>Install CDK and connect to your AWS account. This step is only necessary once per AWS account.</p> <pre><code># Download titiler repo\n$ git clone https://github.com/developmentseed/titiler.git\n\n# Create a virtual environment\npython -m pip install --upgrade virtualenv\nvirtualenv .venv\nsource .venv/bin/activate\n\n# Install CDK dependencies\npython -m pip install -r requirements-cdk.txt\n\n# Install NodeJS dependencies\nnpm install\n\n$ npm run cdk -- bootstrap # Deploys the CDK toolkit stack into an AWS environment\n\n# or in specific region\n$ npm run cdk -- bootstrap aws://${AWS_ACCOUNT_ID}/eu-central-1\n</code></pre> </li> <li> <p>Generate CloudFormation template</p> <pre><code>$ npm run cdk -- synth  # Synthesizes and prints the CloudFormation template for this stack\n</code></pre> </li> <li> <p>Update settings (see intro.md)</p> <pre><code>export TITILER_STACK_NAME=\"mytiler\"\nexport TITILER_STACK_STAGE=\"dev\"\nexport TITILER_STACK_MIN_ECS_INSTANCES=10\n</code></pre> <p>Available settings for ECS:</p> <pre><code>min_ecs_instances: int = 5\nmax_ecs_instances: int = 50\n\n# CPU value      |   Memory value\n# 256 (.25 vCPU) | 0.5 GB, 1 GB, 2 GB\n# 512 (.5 vCPU)  | 1 GB, 2 GB, 3 GB, 4 GB\n# 1024 (1 vCPU)  | 2 GB, 3 GB, 4 GB, 5 GB, 6 GB, 7 GB, 8 GB\n# 2048 (2 vCPU)  | Between 4 GB and 16 GB in 1-GB increments\n# 4096 (4 vCPU)  | Between 8 GB and 30 GB in 1-GB increments\ntask_cpu: int = 256\ntask_memory: int = 512\n\n# GUNICORN configuration\n# Ref: https://github.com/developmentseed/titiler/issues/119\n\n# WORKERS_PER_CORE\n# This image will check how many CPU cores are available in the current server running your container.\n# It will set the number of workers to the number of CPU cores multiplied by this value.\nworkers_per_core: int = 1\n\n# MAX_WORKERS\n# You can use it to let the image compute the number of workers automatically but making sure it's limited to a maximum.\n# should depends on `task_cpu`\nmax_workers: int = 1\n\n# WEB_CONCURRENCY\n# Override the automatic definition of number of workers.\n# Set to the number of CPU cores in the current server multiplied by the environment variable WORKERS_PER_CORE.\n# So, in a server with 2 cores, by default it will be set to 2.\nweb_concurrency: Optional[int]\n</code></pre> </li> <li> <p>Deploy</p> <pre><code># Deploys the stack(s) mytiler-ecs-dev in cdk/app.py\n$ npm run cdk -- deploy mytiler-ecs-dev\n</code></pre> </li> </ol>"},{"location":"deployment/aws/intro/","title":"Amazon Web Services deployments","text":"<p>Examples of AWS deployments can be found in github.com/developmentseed/titiler/tree/main/deployment/aws. Those examples use AWS Cloud Development Kit to define stacks using python code.</p>"},{"location":"deployment/aws/intro/#configurationsettings","title":"Configuration/Settings","text":"<p>Deployment settings are managed via pydantic.BaseSettings and stored in config.py. Pydantic BaseSettings can receive input to overwrite the default value from a <code>.env</code> file or from environment variables.</p> <p>Variables in <code>.env</code> or in environment variable need to be prefixed with <code>TITILER_STACK_</code>:</p> <pre><code>TITILER_STACK_NAME=\"my-tiler\"\nTITILER_STACK_STAGE=\"dev\"\n\nTITILER_STACK_BUCKETS='[\"my-bucket*\", \"*\"]'\n\nTITILER_STACK_MEMORY=3008\n\n# Uncomment to allow lambda to access content on requester-payer buckets\n# TITILER_STACK_ENV='{\"AWS_REQUEST_PAYER\":\"requester\"}'\n\n# Uncomment if you only on the /cog endpoint\n# TITILER_STACK_ENV='{\"TITILER_API_DISABLE_STAC\": \"TRUE\", \"TITILER_API_DISABLE_MOSAIC\": \"TRUE\"}'\n</code></pre> <p>Default values from config.py: <pre><code>name: str = \"titiler\"\nstage: str = \"production\"\n\nowner: Optional[str]\nclient: Optional[str]\n\n# Default options are optimized for CloudOptimized GeoTIFF\n# For more information on GDAL env see: https://gdal.org/user/configoptions.html\nenv: Dict = {\n    \"CPL_VSIL_CURL_ALLOWED_EXTENSIONS\": \".tif,.TIF,.tiff\",\n    \"GDAL_CACHEMAX\": \"200\" # 200 mb\n    \"GDAL_DISABLE_READDIR_ON_OPEN\": \"EMPTY_DIR\",\n    \"GDAL_HTTP_MERGE_CONSECUTIVE_RANGES\": \"YES\",\n    \"GDAL_HTTP_MULTIPLEX\": \"YES\",\n    \"GDAL_HTTP_VERSION\": \"2\",\n    \"PYTHONWARNINGS\": \"ignore\",\n    \"VSI_CACHE\": \"TRUE\",\n    \"VSI_CACHE_SIZE\": \"5000000\" # 5 MB (per file-handle)\n}\n\n# add S3 bucket where TiTiler could do HEAD and GET Requests\nbuckets: List = []\n\n###########################################################################\n# AWS ECS\n# The following settings only apply to AWS ECS deployment\nmin_ecs_instances: int = 5\nmax_ecs_instances: int = 50\n\n# CPU value      |   Memory value\n# 256 (.25 vCPU) | 0.5 GB, 1 GB, 2 GB\n# 512 (.5 vCPU)  | 1 GB, 2 GB, 3 GB, 4 GB\n# 1024 (1 vCPU)  | 2 GB, 3 GB, 4 GB, 5 GB, 6 GB, 7 GB, 8 GB\n# 2048 (2 vCPU)  | Between 4 GB and 16 GB in 1-GB increments\n# 4096 (4 vCPU)  | Between 8 GB and 30 GB in 1-GB increments\ntask_cpu: int = 256\ntask_memory: int = 512\n\n# GUNICORN configuration\n# Ref: https://github.com/developmentseed/titiler/issues/119\n\n# WORKERS_PER_CORE\n# This image will check how many CPU cores are available in the current server running your container.\n# It will set the number of workers to the number of CPU cores multiplied by this value.\nworkers_per_core: int = 1\n\n# MAX_WORKERS\n# You can use it to let the image compute the number of workers automatically but making sure it's limited to a maximum.\n# should depends on `task_cpu`\nmax_workers: int = 1\n\n# WEB_CONCURRENCY\n# Override the automatic definition of number of workers.\n# Set to the number of CPU cores in the current server multiplied by the environment variable WORKERS_PER_CORE.\n# So, in a server with 2 cores, by default it will be set to 2.\nweb_concurrency: Optional[int]\n\nimage_version: str = \"latest\"\n\n###########################################################################\n# AWS LAMBDA\n# The following settings only apply to AWS Lambda deployment\ntimeout: int = 10\nmemory: int = 1536\n# more about lambda config: https://www.sentiatechblog.com/aws-re-invent-2020-day-3-optimizing-lambda-cost-with-multi-threading\n\n# The maximum of concurrent executions you want to reserve for the function.\n# Default: - No specific limit - account limit.\nmax_concurrent: Optional[int]\n</code></pre></p>"},{"location":"deployment/aws/lambda/","title":"AWS Lambda","text":"<p>TiTiler is built on top of FastAPI, a modern, fast, Python web framework for building APIs. It doesn't work natively with AWS Lambda and API Gateway because FastAPI understands HTTP requests, not API Gateway's <code>event</code> and <code>context</code> JSON objects. However, we can make our FastAPI application work on Lambda by wrapping it with the awesome <code>mangum</code> module, which translates API Gateway events into HTTP requests.</p> <pre><code>from mangum import Mangum\nfrom titiler.main import app\n\nhandler = Mangum(app, enable_lifespan=False)\n</code></pre>"},{"location":"deployment/aws/lambda/#deploy","title":"Deploy","text":"<p>The Lambda stack is also deployed by the AWS CDK utility. Under the hood, CDK will create the deployment package required for AWS Lambda, upload it to AWS, and handle the creation of the Lambda and API Gateway resources.</p> <ol> <li> <p>Install CDK and connect to your AWS account. This step is only necessary once per AWS account.</p> <pre><code># Download titiler repo\ngit clone https://github.com/developmentseed/titiler.git\ncd titiler/deployment/aws\n\n# Create a virtual environment\npython -m pip install --upgrade virtualenv\nvirtualenv .venv\nsource .venv/bin/activate\n\n# Install CDK dependencies\npython -m pip install -r requirements-cdk.txt\n\n# Install NodeJS dependencies\nnpm install\n\n$ npm run cdk -- bootstrap # Deploys the CDK toolkit stack into an AWS environment\n\n# or in specific region\n$ npm run cdk -- bootstrap aws://${AWS_ACCOUNT_ID}/eu-central-1\n</code></pre> </li> <li> <p>Pre-Generate CFN template</p> <pre><code>$ npm run cdk -- synth  # Synthesizes and prints the CloudFormation template for this stack\n</code></pre> </li> <li> <p>Update settings (see intro.md)</p> <pre><code>export TITILER_STACK_NAME=\"mytiler\"\nexport TITILER_STACK_STAGE=\"dev\"\nexport TITILER_STACK_MEMORY=512\n</code></pre> <p>Available settings for AWS Lambda:</p> <pre><code>timeout: int = 10\nmemory: int = 1536\n\n# The maximum of concurrent executions you want to reserve for the function.\n# Default: - No specific limit - account limit.\nmax_concurrent: Optional[int]\n</code></pre> </li> <li> <p>Deploy</p> <pre><code>$ npm run cdk -- deploy mytiler-lambda-dev # Deploys the stack(s) titiler-lambda-dev in cdk/app.py\n\n# Deploy in specific region\n$ AWS_DEFAULT_REGION=eu-central-1 AWS_REGION=eu-central-1 npm run cdk -- deploy mytiler-lambda-dev\n</code></pre> </li> </ol>"},{"location":"deployment/aws/sam/","title":"AWS Serverless Application (SAM)","text":"<p>An AWS SAM (Serverless Application Model) application is publicly available over serverlessrepo.aws.amazon.com/applications/us-east-1/552819999234/TiTiler</p> <p>This enable almost a <code>one click</code> deployment solution</p> <p></p> <p>The SAM template is built on top of developmentseed/titiler-lambda-layer.</p> <p></p>"},{"location":"endpoints/algorithms/","title":"/algorithms","text":"<p>In addition to the <code>/cog</code>, <code>/stac</code> and <code>/mosaicjson</code> endpoints, the <code>titiler.application</code> package FastAPI application commes with additional metadata endpoints.</p>"},{"location":"endpoints/algorithms/#algorithms","title":"Algorithms","text":""},{"location":"endpoints/algorithms/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/algorithms</code> JSON retrieve the list of available Algorithms <code>GET</code> <code>/algorithms/{algorithmId}</code> JSON retrieve the metadata of the specified algorithm."},{"location":"endpoints/algorithms/#description","title":"Description","text":""},{"location":"endpoints/algorithms/#list-algorithm","title":"List Algorithm","text":"<p><code>:endpoint:/algorithm</code> - Get the list of supported TileMatrixSet</p> <pre><code>$ curl https://myendpoint/algorithms | jq\n\n{\n  \"hillshade\": {\n    \"title\": \"Hillshade\",\n    \"description\": \"Create hillshade from DEM dataset.\",\n    \"inputs\": {\n      \"nbands\": 1\n    },\n    \"outputs\": {\n      \"nbands\": 1,\n      \"dtype\": \"uint8\",\n      \"min\": null,\n      \"max\": null\n    },\n    \"parameters\": {\n      \"azimuth\": {\n        \"default\": 90,\n        \"maximum\": 360,\n        \"minimum\": 0,\n        \"title\": \"Azimuth\",\n        \"type\": \"integer\"\n      },\n      \"angle_altitude\": {\n        \"default\": 90.0,\n        \"maximum\": 90.0,\n        \"minimum\": -90.0,\n        \"title\": \"Angle Altitude\",\n        \"type\": \"number\"\n      },\n      \"buffer\": {\n        \"default\": 3,\n        \"maximum\": 99,\n        \"minimum\": 0,\n        \"title\": \"Buffer\",\n        \"type\": \"integer\"\n      }\n    }\n  },\n  ...\n}\n</code></pre>"},{"location":"endpoints/algorithms/#get-algorithm-info","title":"Get Algorithm info","text":"<p><code>:endpoint:/algorithms/{algorithmId}</code> - Get the algorithm metadata</p> <ul> <li>PathParams:<ul> <li>algorithmId: algorithm name</li> </ul> </li> </ul> <pre><code>$ curl http://127.0.0.1:8000/algorithms/contours | jq\n\n{\n  \"title\": \"Contours\",\n  \"description\": \"Create contours from DEM dataset.\",\n  \"inputs\": {\n    \"nbands\": 1\n  },\n  \"outputs\": {\n    \"nbands\": 3,\n    \"dtype\": \"uint8\",\n    \"min\": null,\n    \"max\": null\n  },\n  \"parameters\": {\n    \"increment\": {\n      \"default\": 35,\n      \"maximum\": 999,\n      \"minimum\": 0,\n      \"title\": \"Increment\",\n      \"type\": \"integer\"\n    },\n    \"thickness\": {\n      \"default\": 1,\n      \"maximum\": 10,\n      \"minimum\": 0,\n      \"title\": \"Thickness\",\n      \"type\": \"integer\"\n    },\n    \"minz\": {\n      \"default\": -12000,\n      \"maximum\": 99999,\n      \"minimum\": -99999,\n      \"title\": \"Minz\",\n      \"type\": \"integer\"\n    },\n    \"maxz\": {\n      \"default\": 8000,\n      \"maximum\": 99999,\n      \"minimum\": -99999,\n      \"title\": \"Maxz\",\n      \"type\": \"integer\"\n    }\n  }\n}\n</code></pre>"},{"location":"endpoints/cog/","title":"/cog","text":"<p>The <code>titiler.application</code> package comes with a full FastAPI application with COG, STAC and MosaicJSON supports.</p>"},{"location":"endpoints/cog/#cloud-optimized-geotiff","title":"Cloud Optimized GeoTIFF","text":"<p>The <code>/cog</code> routes are based on <code>titiler.core.factory.TilerFactory</code> but with <code>cogValidateExtension</code> and <code>cogViewerExtension</code> extensions.</p>"},{"location":"endpoints/cog/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/cog/bounds</code> JSON return dataset's bounds <code>GET</code> <code>/cog/info</code> JSON return dataset's basic info <code>GET</code> <code>/cog/info.geojson</code> GeoJSON return dataset's basic info as a GeoJSON feature <code>GET</code> <code>/cog/statistics</code> JSON return dataset's statistics <code>POST</code> <code>/cog/statistics</code> GeoJSON return dataset's statistics for a GeoJSON <code>GET</code> <code>/cog/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from a dataset <code>GET</code> <code>/cog/{tileMatrixSetId}/tilejson.json</code> JSON return a Mapbox TileJSON document <code>GET</code> <code>/cog/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/cog/point/{lon},{lat}</code> JSON return pixel values from a dataset <code>GET</code> <code>/cog/preview[.{format}]</code> image/bin create a preview image from a dataset <code>GET</code> <code>/cog/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of a dataset <code>POST</code> <code>/cog/feature[/{width}x{height}][].{format}]</code> image/bin create an image from a GeoJSON feature <code>GET</code> <code>/cog/{tileMatrixSetId}/map</code> HTML simple map viewer <code>GET</code> <code>/cog/validate</code> JSON validate a COG and return dataset info (from <code>titiler.extensions.cogValidateExtension</code>) <code>GET</code> <code>/cog/viewer</code> HTML demo webpage (from <code>titiler.extensions.cogViewerExtension</code>) <code>GET</code> <code>/cog/stac</code> GeoJSON create STAC Items from a dataset (from <code>titiler.extensions.stacExtension</code>)"},{"location":"endpoints/cog/#description","title":"Description","text":""},{"location":"endpoints/cog/#tiles","title":"Tiles","text":"<p><code>:endpoint:/cog/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> <li>z (int): TMS tile's zoom level.</li> <li>x (int): TMS tile's column.</li> <li>y (int): TMS tile's row.</li> <li>scale (int): Tile size scale, default is set to 1 (256x256). Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/tiles/WebMercatorQuad/1/2/3?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/tiles/WebMercatorQuad/1/2/3.jpg?url=https://somewhere.com/mycog.tif&amp;bidx=3&amp;bidx=1&amp;bidx2</code></li> <li><code>https://myendpoint/cog/tiles/WorldCRS84Quad/1/2/3@2x.png?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/tiles/WorldCRS84Quad/1/2/3?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/cog/#preview","title":"Preview","text":"<p><code>:endpoint:/cog/preview[.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/preview?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/preview.jpg?url=https://somewhere.com/mycog.tif&amp;bidx=3&amp;bidx=1&amp;bidx2</code></li> <li><code>https://myendpoint/cog/preview?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/cog/#bboxfeature","title":"BBOX/Feature","text":"<p><code>:endpoint:/cog/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/cog/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>format (str): Output image format.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/bbox/0,0,10,10.png?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/bbox/0,0,10,10.png?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul> <p><code>:endpoint:/cog/feature[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>if height and width are provided max_size will be ignored.</p> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/feature?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/feature.png?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/feature/100x100.png?url=https://somewhere.com/mycog.tif&amp;bidx=1&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul> <p>Note: if <code>height</code> and <code>width</code> are provided <code>max_size</code> will be ignored.</p>"},{"location":"endpoints/cog/#point","title":"Point","text":"<p><code>:endpoint:/cog/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>lon,lat, (str): Comma (',') delimited point Longitude and Latitude WGS84.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/point/0,0?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/point/0,0?url=https://somewhere.com/mycog.tif&amp;bidx=1</code></li> </ul>"},{"location":"endpoints/cog/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/cog/{tileMatrixSetId}/tilejson.json</code> tileJSON document</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/WebMercatorQuad/tilejson.json?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/WebMercatorQuad/tilejson.json?url=https://somewhere.com/mycog.tif&amp;tile_format=png</code></li> <li><code>https://myendpoint/cog/WorldCRS84Quad/tilejson.json?url=https://somewhere.com/mycog.tif&amp;tile_scale=2&amp;bidx=1,2,3</code></li> </ul>"},{"location":"endpoints/cog/#map","title":"Map","text":"<p><code>:endpoint:/cog/{tileMatrixSetId}/map</code> Simple viewer</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/WebMercatorQuad/map?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/WebMercatorQuad/map?url=https://somewhere.com/mycog.tif&amp;tile_format=png</code></li> <li><code>https://myendpoint/cog/WorldCRS84Quad/map?url=https://somewhere.com/mycog.tif&amp;tile_scale=2&amp;bidx=1,2,3</code></li> </ul>"},{"location":"endpoints/cog/#bounds","title":"Bounds","text":"<p><code>:endpoint:/cog/bounds</code> general image bounds</p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/bounds?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#info","title":"Info","text":"<p><code>:endpoint:/cog/info</code> general raster info</p> <p><code>:endpoint:/cog/info.geojson</code> general raster info as a GeoJSON feature</p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/info?url=https://somewhere.com/mycog.tif</code></li> <li><code>https://myendpoint/cog/info.geojson?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#statistics","title":"Statistics","text":"<p>Advanced raster statistics</p> <p><code>:endpoint:/cog/statistics - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/statistics?url=https://somewhere.com/mycog.tif&amp;bidx=1,2,3&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/cog/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): Cloud Optimized GeoTIFF URL. Required</li> <li>bidx (array[int]): Dataset band indexes (e.g <code>bidx=1</code>, <code>bidx=1&amp;bidx=2&amp;bidx=3</code>).</li> <li>expression (str): rio-tiler's band math expression (e.g <code>expression=b1/b2</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/statistics?url=https://somewhere.com/mycog.tif&amp;bidx=1,2,3&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul>"},{"location":"endpoints/cog/#viewer","title":"Viewer","text":"<p><code>:endpoint:/cog/viewer</code> - COG Viewer</p> <ul> <li>QueryParams:<ul> <li>url: Cloud Optimized GeoTIFF URL. Required</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/viewer?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#validate","title":"Validate","text":"<p><code>:endpoint:/cog/validate</code> - COG Viewer</p> <ul> <li>QueryParams:<ul> <li>url: Cloud Optimized GeoTIFF URL. Required</li> <li>strict: Treat warnings as errors (bool, default is False).</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/validate?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/cog/#stac","title":"Stac","text":"<p><code>:endpoint:/cog/stac</code> - Create STAC Item</p> <ul> <li>QueryParams:<ul> <li>url: Cloud Optimized GeoTIFF URL. Required</li> <li>datetime (str): The date and time of the assets, in UTC (e.g 2020-01-01, 2020-01-01T01:01:01).</li> <li>extension (array[uri]): STAC extension URL the Item implements.</li> <li>collection (str): The Collection ID that this item belongs to.</li> <li>collection_url (uri): Link to the STAC Collection.</li> <li>id (str): Id to assign to the item (default to the source basename).</li> <li>asset_name (str): asset name for the source (default to 'data').</li> <li>asset_roles (array[str]): List of asset's roles.</li> <li>asset_media_type (str): Asset's media type.</li> <li>asset_href (uri): Asset's URI (default to source's path).</li> <li>with_proj (bool): Add the <code>projection</code> extension and properties.</li> <li>with_raster (bool): Add the <code>raster</code> extension and properties.</li> <li>with_eo (bool): Add the <code>eo</code> extension and properties.</li> <li>max_size (int): Limit array size from which to get the raster statistics.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/cog/stac?url=https://somewhere.com/mycog.tif</code></li> </ul>"},{"location":"endpoints/colormaps/","title":"/colormaps","text":"<p>In addition to the <code>/cog</code>, <code>/stac</code> and <code>/mosaicjson</code> endpoints, the <code>titiler.application</code> package FastAPI application commes with additional metadata endpoints.</p>"},{"location":"endpoints/colormaps/#algorithms","title":"Algorithms","text":""},{"location":"endpoints/colormaps/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/colorMaps</code> JSON retrieve the list of available colorMaps <code>GET</code> <code>/colorMaps/{colorMapId}</code> JSON retrieve the metadata or image of the specified colorMap."},{"location":"endpoints/colormaps/#description","title":"Description","text":""},{"location":"endpoints/colormaps/#list-colormaps","title":"List colormaps","text":"<p><code>:endpoint:/colorMaps</code> - Get the list of supported ColorMaps</p> <pre><code>$ curl https://myendpoint/colorMaps | jq\n\n{\n  \"colorMaps\": [\n    \"dense_r\",\n    \"delta\",\n    ...\n  ],\n  \"links\": [\n    {\n      \"href\": \"http://myendpoint/colorMaps\",\n      \"rel\": \"self\",\n      \"type\": \"application/json\",\n      \"title\": \"List of available colormaps\"\n    },\n    {\n      \"href\": \"http://myendpoint/colorMaps/{colorMapId}\",\n      \"rel\": \"data\",\n      \"type\": \"application/json\",\n      \"templated\": true,\n      \"title\": \"Retrieve colormap metadata\"\n    },\n    {\n      \"href\": \"http://myendpoint/colorMaps/{colorMapId}?format=png\",\n      \"rel\": \"data\",\n      \"type\": \"image/png\",\n      \"templated\": true,\n      \"title\": \"Retrieve colormap as image\"\n    }\n  ]\n}\n</code></pre>"},{"location":"endpoints/colormaps/#get-colormap-metadata-or-as-image","title":"Get ColorMap metadata or as image","text":"<p><code>:endpoint:/colorMaps/{colorMapId}</code> - Get the ColorMap metadata or image</p> <ul> <li> <p>PathParams:</p> <ul> <li>colorMapId: colormap name</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>format (str): output image format (PNG/JPEG...). Defaults to JSON output.</li> <li>orientation ([\"vertical\", \"horizontal\"]): image orientation. Defaults to <code>horizontal</code>.</li> <li>height (int): output image height. Default to 20px for horizontal or 256px for vertical.</li> <li>width (int): output image width. Defaults to 256px for horizontal or 20px for vertical.</li> </ul> </li> </ul> <pre><code>$ curl http://myendpoint/colorMaps/viridis | jq\n\n{\n  \"0\": [\n    68,\n    1,\n    84,\n    255\n  ],\n  ...\n  \"255\": [\n    253,\n    231,\n    36,\n    255\n  ]\n}\n</code></pre> <pre><code>curl http://myendpoint/colorMaps/viridis?format=png\n</code></pre> <pre><code>curl http://myendpoint/colorMaps/viridis?format=png&amp;orientation=vertical\n</code></pre> <pre><code>curl http://myendpoint/colorMaps/viridis?format=png&amp;orientation=vertical&amp;width=100&amp;height=1000\n</code></pre>"},{"location":"endpoints/mosaic/","title":"/mosaicjson","text":"<p>The <code>titiler.application</code> package comes with a full FastAPI application with COG, STAC and MosaicJSON supports.</p>"},{"location":"endpoints/mosaic/#mosaicjson","title":"MosaicJSON","text":"<p>Read Mosaic Info/Metadata and create Web map Tiles from a multiple COG. The <code>mosaic</code> router is built on top of <code>titiler.mosaic.factor.MosaicTilerFactory</code>.</p>"},{"location":"endpoints/mosaic/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/mosaicjson/</code> JSON return a MosaicJSON document <code>GET</code> <code>/mosaicjson/bounds</code> JSON return mosaic's bounds <code>GET</code> <code>/mosaicjson/info</code> JSON return mosaic's basic info <code>GET</code> <code>/mosaicjson/info.geojson</code> GeoJSON return mosaic's basic info as a GeoJSON feature <code>GET</code> <code>/mosaicjson/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from mosaic assets <code>GET</code> <code>/mosaicjson/{tileMatrixSetId}/tilejson.json</code> JSON return a Mapbox TileJSON document <code>GET</code> <code>/mosaicjson/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/mosaicjson/point/{lon},{lat}</code> JSON return pixel value from a mosaic assets <code>GET</code> <code>/mosaicjson/{z}/{x}/{y}/assets</code> JSON return list of assets intersecting a XYZ tile <code>GET</code> <code>/mosaicjson/{lon},{lat}/assets</code> JSON return list of assets intersecting a point <code>GET</code> <code>/mosaicjson/{minx},{miny},{maxx},{maxy}/assets</code> JSON return list of assets intersecting a bounding box <code>GET</code> <code>/mosaicjson/{tileMatrixSetId}/map</code> HTML simple map viewer"},{"location":"endpoints/mosaic/#description","title":"Description","text":"<p>[TODO]</p>"},{"location":"endpoints/stac/","title":"/stac","text":"<p>The <code>titiler.application</code> package comes with a full FastAPI application with COG, STAC and MosaicJSON supports.</p>"},{"location":"endpoints/stac/#spatiotemporal-asset-catalog","title":"SpatioTemporal Asset Catalog","text":"<p>The <code>/stac</code> routes are based on <code>titiler.core.factory.MultiBaseTilerFactory</code> but with <code>stacViewerExtension</code> extension.</p>"},{"location":"endpoints/stac/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/stac/assets</code> JSON return available assets within the STAC item <code>GET</code> <code>/stac/bounds</code> JSON return STAC item bounds <code>GET</code> <code>/stac/info</code> JSON return asset's basic info <code>GET</code> <code>/stac/info.geojson</code> GeoJSON return asset's basic info as a GeoJSON feature <code>GET</code> <code>/stac/asset_statistics</code> JSON return per asset statistics <code>GET</code> <code>/stac/statistics</code> JSON return asset's statistics <code>POST</code> <code>/stac/statistics</code> GeoJSON return asset's statistics for a GeoJSON <code>GET</code> <code>/stac/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code> image/bin create a web map tile image from assets <code>GET</code> <code>/stac/{tileMatrixSetId}/tilejson.json</code> JSON return a Mapbox TileJSON document <code>GET</code> <code>/stac/{tileMatrixSetId}/WMTSCapabilities.xml</code> XML return OGC WMTS Get Capabilities <code>GET</code> <code>/stac/point/{lon},{lat}</code> JSON return pixel value from assets <code>GET</code> <code>/stac/preview[.{format}]</code> image/bin create a preview image from assets <code>GET</code> <code>/stac/bbox/{minx},{miny},{maxx},{maxy}[/{width}x{height}].{format}</code> image/bin create an image from part of assets <code>POST</code> <code>/stac/feature[/{width}x{height}][].{format}]</code> image/bin create an image from a geojson covering the assets <code>GET</code> <code>/stac/{tileMatrixSetId}/map</code> HTML simple map viewer <code>GET</code> <code>/stac/viewer</code> HTML demo webpage (from <code>titiler.extensions.stacViewerExtension</code>)"},{"location":"endpoints/stac/#description","title":"Description","text":""},{"location":"endpoints/stac/#tiles","title":"Tiles","text":"<p><code>:endpoint:/stac/tiles/{tileMatrixSetId}/{z}/{x}/{y}[@{scale}x][.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> <li>z (int): TMS tile's zoom level.</li> <li>x (int): TMS tile's column.</li> <li>y (int): TMS tile's row.</li> <li>scale (int): Tile size scale, default is set to 1 (256x256). Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/tiles/WebMercatorQuad/1/2/3?url=https://somewhere.com/item.json&amp;assets=B01&amp;assets=B00</code></li> <li><code>https://myendpoint/stac/tiles/WebMercatorQuad/1/2/3.jpg?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/tiles/WorldCRS84Quad/1/2/3@2x.png?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/tiles/WorldCRS84Quad/1/2/3?url=https://somewhere.com/item.json&amp;expression=B01/B02&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/stac/#preview","title":"Preview","text":"<p><code>:endpoint:/stac/preview[.{format}]</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>format: Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>max_size (int): Max image size, default is 1024.</li> <li>height (int): Force output image height.</li> <li>width (int): Force output image width.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to dataset's CRS.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/preview?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/preview.jpg?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/preview?url=https://somewhere.com/item.json&amp;assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/stac/#bboxfeature","title":"BBOX/Feature","text":"<p><code>:endpoint:/stac/bbox/{minx},{miny},{maxx},{maxy}.{format}</code></p> <p><code>:endpoint:/stac/bbox/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>minx,miny,maxx,maxy (str): Comma (',') delimited bounding box in WGS84.</li> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/bbox/0,0,10,10.png?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/bbox/0,0,10,10.png?url=https://somewhere.com/item.json&amp;assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul> <p><code>:endpoint:/stac/feature[/{width}x{height}][].{format}] - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature (Polygon or MultiPolygon)</li> </ul> </li> <li> <p>PathParams:</p> <ul> <li>height (int): Force output image height. Optional</li> <li>width (int): Force output image width. Optional</li> <li>format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value. Optional</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <ul> <li> <p>assets OR expression is required</p> </li> <li> <p>if height and width are provided max_size will be ignored.</p> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/feature?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/feature.png?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/feature/100x100.png?url=https://somewhere.com/item.json&amp;assets=B01&amp;rescale=0,1000&amp;colormap_name=cfastie</code></li> </ul>"},{"location":"endpoints/stac/#point","title":"Point","text":"<p><code>:endpoint:/cog/point/{lon},{lat}</code></p> <ul> <li> <p>PathParams:</p> <ul> <li>lon,lat, (str): Comma (',') delimited point Longitude and Latitude WGS84.</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input coordinates. Default to <code>epsg:4326</code>.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/point/0,0?url=https://somewhere.com/item.json&amp;assets=B01</code></li> </ul>"},{"location":"endpoints/stac/#tilesjson","title":"TilesJSON","text":"<p><code>:endpoint:/stac/{tileMatrixSetId}/tilejson.json</code> tileJSON document</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/stac/WorldCRS84Quad/tilejson.json?url=https://somewhere.com/item.json&amp;tile_scale=2&amp;expression=B01/B02</code></li> </ul>"},{"location":"endpoints/stac/#map","title":"Map","text":"<p><code>:endpoint:/stac/{tileMatrixSetId}/map</code>  Simple viewer</p> <ul> <li> <p>PathParams:</p> <ul> <li>tileMatrixSetId (str): TileMatrixSet name (e.g <code>WebMercatorQuad</code>)</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>tile_format (str): Output image format, default is set to None and will be either JPEG or PNG depending on masked value.</li> <li>tile_scale (int): Tile size scale, default is set to 1 (256x256).</li> <li>minzoom (int): Overwrite default minzoom.</li> <li>maxzoom (int): Overwrite default maxzoom.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>rescale (array[str]): Comma (',') delimited Min,Max range (e.g <code>rescale=0,1000</code>, <code>rescale=0,1000&amp;rescale=0,3000&amp;rescale=0,2000</code>).</li> <li>color_formula (str): rio-color formula.</li> <li>colormap (str): JSON encoded custom Colormap.</li> <li>colormap_name (str): rio-tiler color map name.</li> <li>return_mask (bool): Add mask to the output data. Default is True.</li> <li>buffer (float): Buffer on each side of the given tile. It must be a multiple of <code>0.5</code>. Output tilesize will be expanded to <code>tilesize + 2 * buffer</code> (e.g 0.5 = 257x257, 1.0 = 258x258).</li> <li>padding (int): Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to <code>0</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> </ul> </li> </ul> <p>Important</p> <p>assets OR expression is required</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01</code></li> <li><code>https://myendpoint/stac/WebMercatorQuad/tilejson.json?url=https://somewhere.com/item.json&amp;assets=B01&amp;tile_format=png</code></li> <li><code>https://myendpoint/stac/WorldCRS84Quad/tilejson.json?url=https://somewhere.com/item.json&amp;tile_scale=2&amp;expression=B01/B02</code></li> </ul>"},{"location":"endpoints/stac/#bounds","title":"Bounds","text":"<p><code>:endpoint:/stac/bounds</code> - Return the bounds of the STAC item.</p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/bounds?url=https://somewhere.com/item.json</code></li> </ul>"},{"location":"endpoints/stac/#info","title":"Info","text":"<p><code>:endpoint:/stac/info</code> - Return basic info on STAC item's COG.</p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/info?url=https://somewhere.com/item.json&amp;assets=B01</code></li> </ul> <p><code>:endpoint:/stac/info.geojson</code> - Return basic info on STAC item's COG as a GeoJSON feature</p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/info.geojson?url=https://somewhere.com/item.json&amp;assets=B01</code></li> </ul> <p><code>:endpoint:/stac/assets</code> - Return the list of available assets</p> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/assets?url=https://somewhere.com/item.json</code></li> </ul>"},{"location":"endpoints/stac/#statistics","title":"Statistics","text":"<p><code>:endpoint:/stac/asset_statistics - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>asset_expression (array[str]): Per asset band math expression (e.g <code>Asset1|b1\\*b2</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/statistics?url=https://somewhere.com/item.json&amp;assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/stac/statistics - [GET]</code></p> <ul> <li>QueryParams:<ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>max_size (int): Max image size from which to calculate statistics, default is 1024.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/statistics?url=https://somewhere.com/item.json&amp;assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul> <p><code>:endpoint:/stac/statistics - [POST]</code></p> <ul> <li> <p>Body:</p> <ul> <li>feature (JSON): A valid GeoJSON feature or FeatureCollection</li> </ul> </li> <li> <p>QueryParams:</p> <ul> <li>url (str): STAC Item URL. Required</li> <li>assets (array[str]): asset names. Default to all available assets.</li> <li>expression (str): rio-tiler's math expression with asset names (e.g <code>Asset1_b1/Asset2_b1</code>).</li> <li>asset_as_band (bool): tell rio-tiler that each asset is a 1 band dataset, so expression <code>Asset1/Asset2</code> can be passed.</li> <li>asset_bidx (array[str]): Per asset band math expression (e.g <code>Asset1|1,2,3</code>).</li> <li>coord_crs (str): Coordinate Reference System of the input geometry coordinates. Default to <code>epsg:4326</code>.</li> <li>dst_crs (str): Output Coordinate Reference System. Default to <code>coord_crs</code>.</li> <li>max_size (int): Max image size from which to calculate statistics.</li> <li>height (int): Force image height from which to calculate statistics.</li> <li>width (int): Force image width from which to calculate statistics.</li> <li>nodata (str, int, float): Overwrite internal Nodata value.</li> <li>unscale (bool): Apply dataset internal Scale/Offset.</li> <li>resampling (str): RasterIO resampling algorithm. Defaults to <code>nearest</code>.</li> <li>reproject (str): WarpKernel resampling algorithm (only used when doing re-projection). Defaults to <code>nearest</code>.</li> <li>algorithm (str): Custom algorithm name (e.g <code>hillshade</code>).</li> <li>algorithm_params (str): JSON encoded algorithm parameters.</li> <li>categorical (bool): Return statistics for categorical dataset, default is false.</li> <li>c (array[float]): Pixels values for categories.</li> <li>p (array[int]): Percentile values.</li> <li>histogram_bins (str): Histogram bins.</li> <li>histogram_range (str): Comma (',') delimited Min,Max histogram bounds</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/statistics?url=https://somewhere.com/item.json&amp;assets=B01&amp;categorical=true&amp;c=1&amp;c=2&amp;c=3&amp;p=2&amp;p98</code></li> </ul>"},{"location":"endpoints/stac/#viewer","title":"Viewer","text":"<p><code>:endpoint:/stac/viewer</code> - STAC viewer</p> <ul> <li>QueryParams:<ul> <li>url: STAC Item URL. Optional</li> </ul> </li> </ul> <p>Example:</p> <ul> <li><code>https://myendpoint/stac/viewer?url=https://somewhere.com/item.json</code></li> </ul>"},{"location":"endpoints/tms/","title":"/tileMatrixSets","text":"<p>In addition to the <code>/cog</code>, <code>/stac</code> and <code>/mosaicjson</code> endpoints, the <code>titiler.application</code> package FastAPI application comes with additional metadata endpoints.</p>"},{"location":"endpoints/tms/#tilematrixsets","title":"TileMatrixSets","text":""},{"location":"endpoints/tms/#api","title":"API","text":"Method URL Output Description <code>GET</code> <code>/tileMatrixSets</code> JSON return the list of supported TileMatrixSet <code>GET</code> <code>/tileMatrixSets/{tileMatrixSetId}</code> JSON return the TileMatrixSet JSON document"},{"location":"endpoints/tms/#description","title":"Description","text":""},{"location":"endpoints/tms/#list-tms","title":"List TMS","text":"<p><code>:endpoint:/tileMatrixSets</code> - Get the list of supported TileMatrixSet</p> <pre><code>$ curl https://myendpoint/tileMatrixSets | jq\n\n{\n  \"tileMatrixSets\": [\n    {\n      \"id\": \"LINZAntarticaMapTilegrid\",\n      \"title\": \"LINZ Antarctic Map Tile Grid (Ross Sea Region)\",\n      \"links\": [\n        {\n          \"href\": \"https://myendpoint/tileMatrixSets/LINZAntarticaMapTilegrid\",\n          \"rel\": \"item\",\n          \"type\": \"application/json\"\n        }\n      ]\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"endpoints/tms/#get-tms-info","title":"Get TMS info","text":"<p><code>:endpoint:/tileMatrixSets/{tileMatrixSetId}</code> - Get the TileMatrixSet JSON document</p> <ul> <li>PathParams:<ul> <li>tileMatrixSetId: TileMatrixSet name</li> </ul> </li> </ul> <pre><code>$ curl http://127.0.0.1:8000/tileMatrixSets/WebMercatorQuad | jq\n\n{\n  \"type\": \"TileMatrixSetType\",\n  \"title\": \"Google Maps Compatible for the World\",\n  \"identifier\": \"WebMercatorQuad\",\n  \"supportedCRS\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n  \"wellKnownScaleSet\": \"http://www.opengis.net/def/wkss/OGC/1.0/GoogleMapsCompatible\",\n  \"boundingBox\": {\n    \"type\": \"BoundingBoxType\",\n    \"crs\": \"http://www.opengis.net/def/crs/EPSG/0/3857\",\n    \"lowerCorner\": [\n      -20037508.3427892,\n      -20037508.3427892\n    ],\n    \"upperCorner\": [\n      20037508.3427892,\n      20037508.3427892\n    ]\n  },\n  \"tileMatrix\": [\n    {\n      \"type\": \"TileMatrixType\",\n      \"identifier\": \"0\",\n      \"scaleDenominator\": 559082264.028717,\n      \"topLeftCorner\": [\n        -20037508.3427892,\n        20037508.3427892\n      ],\n      \"tileWidth\": 256,\n      \"tileHeight\": 256,\n      \"matrixWidth\": 1,\n      \"matrixHeight\": 1\n    },\n    ...\n</code></pre>"},{"location":"examples/code/create_gdal_wmts_extension/","title":"GDAL WMTS Extension","text":"<p>Goal: add a <code>/wmts.xml</code> endpoint to return a GDAL WMTS service description XML file</p> <p>requirements: titiler.extension &gt;=0.11</p> <p>1 - Create an extension</p> <pre><code># wmts.py\n\"\"\"gdal WMTS service Extension.\"\"\"\n\nimport xml.etree.ElementTree as ET\nfrom dataclasses import dataclass\nfrom typing import Literal\nfrom urllib.parse import urlencode\n\nfrom fastapi import Depends, Query\nfrom starlette.requests import Request\n\nfrom titiler.core.factory import BaseTilerFactory, FactoryExtension\nfrom titiler.core.resources.responses import XMLResponse\n\n\n@dataclass\nclass gdalwmtsExtension(FactoryExtension):\n    \"\"\"Add /wmts.xml endpoint to a TilerFactory.\"\"\"\n\n    def register(self, factory: BaseTilerFactory):  # noqa: C901\n        \"\"\"Register endpoint to the tiler factory.\"\"\"\n\n        @factory.router.get(\n            \"/{tileMatrixSetId}/wmts.xml\",\n            response_class=XMLResponse,\n            responses={\n                200: {\n                    \"description\": \"GDAL WMTS service description XML file\",\n                    \"content\": {\n                        \"application/xml\": {},\n                    },\n                },\n            },\n        )\n        def gdal_wmts(\n            request: Request,\n            tileMatrixSetId: Literal[tuple(factory.supported_tms.list())] = Path(  # type: ignore\n                description=\"TileMatrixSet Name\",\n            ),\n            url: str = Depends(factory.path_dependency),  # noqa\n            bandscount: int = Query(\n                ..., description=\"Number of band returned by the tiler\"\n            ),\n            datatype: str = Query(..., description=\"Datatype returned by the tiler\"),\n            maxconnections: int = Query(\n                None,\n                description=\"Maximum number of simultaneous connections (defaults to 2).\",\n            ),\n            timeout: int = Query(\n                None, description=\"Connection timeout in seconds (defaults to 30).\"\n            ),\n            cache: bool = Query(None, description=\"Allow local cache.\"),\n        ):\n            \"\"\"Return a GDAL WMTS Service description.\"\"\"\n            route_params = {\n                \"tileMatrixSetId\": tileMatrixSetId,\n            }\n            wmts_url = factory.url_for(request, \"wmts\", **route_params)\n\n            qs_key_to_remove = [\n                \"tilematrixsetid\",\n                \"bandscount\",\n                \"datatype\",\n                \"maxconnections\",\n                \"timeout\",\n            ]\n            qs = [\n                (key, value)\n                for (key, value) in request.query_params._list\n                if key.lower() not in qs_key_to_remove\n            ]\n            if qs:\n                wmts_url += f\"?{urlencode(qs)}\"\n\n            maxconnections = maxconnections or 2\n            timeout = timeout or 30\n\n            xml = ET.Element(\"GDAL_WMTS\")\n            cap = ET.SubElement(xml, \"GetCapabilitiesUrl\")\n            cap.text = wmts_url\n\n            bandel = ET.SubElement(xml, \"BandsCount\")\n            bandel.text = str(bandscount)\n            datael = ET.SubElement(xml, \"DataType\")\n            datael.text = datatype\n\n            if cache:\n                cacheel = ET.SubElement(xml, \"Cache\")\n\n            connel = ET.SubElement(xml, \"MaxConnections\")\n            connel.text = str(maxconnections)\n            timeel = ET.SubElement(xml, \"Timeout\")\n            timeel.text = str(timeout)\n            codeel = ET.SubElement(xml, \"ZeroBlockHttpCodes\")\n            codeel.text = \"404\"\n            excepel = ET.SubElement(xml, \"ZeroBlockOnServerException\")\n            excepel.text = \"true\"\n\n            return XMLResponse(ET.tostring(xml))\n</code></pre> <p>2 - Create app and register our extension</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\nfrom titiler.core.factory import TilerFactory\n\nfrom fastapi import FastAPI\n\nfrom .wmts import gdalwmtsExtension\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\n# Create  a set of endpoints using TilerFactory and add our extension\ntiler = TilerFactory(extensions=[gdalwmtsExtension()])\n\napp.include_router(tiler.router)\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre> <p>3 - Use it</p> <pre><code>from rio_tiler.io import Reader\n\nwith Reader(\"http://0.0.0.0/WebMercatorQuad/wmts.xml?url=file.tif&amp;bidx=1&amp;bandscount=1&amp;datatype=float32&amp;tile_format=tif\") as src:\n    im = src.preview()\n</code></pre> <p>Notes</p> <p>The <code>/wmts.xml</code> endpoint has no idea about the data itself and do not care about the <code>bidx</code> or <code>expression</code> which is why we need to set <code>bandscount</code> and <code>datatype</code> parameters.</p> <p>In the example above we use <code>tile_format=tif</code> so GDAL will fetch <code>tif</code> tiles and keep the datatype from the data (which we assume to be float32)</p>"},{"location":"examples/code/mini_cog_tiler/","title":"Minimal COG Tiler","text":"<p>Goal: Create a simple Raster tiler</p> <p>requirements: titiler.core</p> <pre><code>\"\"\"Minimal COG tiler.\"\"\"\n\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory()\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre>"},{"location":"examples/code/mosaic_from_urls/","title":"Mosaic from COG urls","text":"<p>Goal: Create a custom mosaic tiler which takes multiple URL as input</p> <p>requirements: titiler.core | titiler.mosaic</p> <p>1 - Create a custom Mosaic Backends</p> <pre><code>\"\"\"mosaic backends.\n\nThe goal is to build a minimalist Mosaic Backend which takes COG paths as input.\n\n&gt;&gt;&gt; with MultiFilesBackend([\"cog1.tif\", \"cog2.tif\"]) as mosaic:\n    img = mosaic.tile(1, 1, 1)\n\napp/backends.py\n\n\"\"\"\nfrom typing import Type, List, Tuple, Dict, Union\n\nimport attr\nfrom rio_tiler.io import BaseReader, COGReader, MultiBandReader, MultiBaseReader\nfrom rio_tiler.constants import WEB_MERCATOR_TMS, WGS84_CRS\nfrom rasterio.crs import CRS\nfrom morecantile import TileMatrixSet\n\nfrom cogeo_mosaic.backends.base import BaseBackend\nfrom cogeo_mosaic.mosaic import MosaicJSON\n\n\n@attr.s\nclass MultiFilesBackend(BaseBackend):\n\n    input: List[str] = attr.ib()\n\n    reader: Union[\n        Type[BaseReader],\n        Type[MultiBaseReader],\n        Type[MultiBandReader],\n    ] = attr.ib(default=COGReader)\n    reader_options: Dict = attr.ib(factory=dict)\n\n    geographic_crs: CRS = attr.ib(default=WGS84_CRS)\n\n    tms: TileMatrixSet = attr.ib(default=WEB_MERCATOR_TMS)\n    minzoom: int = attr.ib(default=0)\n    maxzoom: int = attr.ib(default=30)\n\n    # default values for bounds\n    bounds: Tuple[float, float, float, float] = attr.ib(\n        default=(-180, -90, 180, 90)\n    )\n    crs: CRS = attr.ib(init=False, default=WGS84_CRS)\n\n    # mosaic_def is outside the __init__ method\n    mosaic_def: MosaicJSON = attr.ib(init=False)\n\n    _backend_name = \"MultiFiles\"\n\n    def __attrs_post_init__(self):\n        \"\"\"Post Init.\"\"\"\n        # Construct a FAKE/Empty mosaicJSON\n        # mosaic_def has to be defined.\n        self.mosaic_def = MosaicJSON(\n            mosaicjson=\"0.0.2\",\n            name=\"it's fake but it's ok\",\n            minzoom=self.minzoom,\n            maxzoom=self.maxzoom,\n            tiles=[]  # we set `tiles` to an empty list.\n        )\n\n    def write(self, overwrite: bool = True):\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def update(self):\n        \"\"\"We overwrite the default method.\"\"\"\n        pass\n\n    def _read(self) -&gt; MosaicJSON:\n        \"\"\"This method is not used but is required by the abstract class.\"\"\"\n        pass\n\n    def assets_for_tile(self, x: int, y: int, z: int) -&gt; List[str]:\n        \"\"\"Retrieve assets for tile.\"\"\"\n        return self.get_assets()\n\n    def assets_for_point(self, lng: float, lat: float) -&gt; List[str]:\n        \"\"\"Retrieve assets for point.\"\"\"\n        return self.get_assets()\n\n    def get_assets(self) -&gt; List[str]:\n        \"\"\"assets are just files we give in path\"\"\"\n        return self.input\n\n    @property\n    def _quadkeys(self) -&gt; List[str]:\n        return []\n</code></pre> <p>2 - Create endpoints</p> <pre><code>\"\"\"routes.\n\napp/routers.py\n\n\"\"\"\n\nfrom dataclasses import dataclass\nfrom typing import List\n\nfrom titiler.mosaic.factory import MosaicTilerFactory\nfrom fastapi import Query\n\nfrom .backends import MultiFilesBackend\n\n@dataclass\nclass MosaicTiler(MosaicTilerFactory):\n    \"\"\"Custom MosaicTilerFactory.\n\n    Note this is a really simple MosaicTiler Factory with only few endpoints.\n    \"\"\"\n\n    def register_routes(self):\n        \"\"\"This Method register routes to the router. \"\"\"\n\n        self.tile()\n        self.tilejson()\n\n\ndef DatasetPathParams(url: str = Query(..., description=\"Dataset URL\")) -&gt; List[str]:\n    \"\"\"Create dataset path from args\"\"\"\n    return url.split(\",\")\n\n\nmosaic = MosaicTiler(reader=MultiFilesBackend, path_dependency=DatasetPathParams)\n</code></pre> <p>3 - Create app and register our custom endpoints</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\nfrom titiler.mosaic.errors import MOSAIC_STATUS_CODES\n\nfrom fastapi import FastAPI\n\nfrom .routers import mosaic\n\napp = FastAPI()\napp.include_router(mosaic.router)\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\nadd_exception_handlers(app, MOSAIC_STATUS_CODES)\n</code></pre> <ol> <li>Run and Use</li> </ol> <pre><code>$ uvicorn app:app --reload\n\n$ curl http://127.0.0.1:8000/tilejson.json?url=cog1.tif,cog2.tif\n</code></pre> <p>Gotcha</p> <ul> <li>bounds of the mosaic backend is set to <code>[-180, -90, 180, 90]</code></li> <li>minzoom is set to 0</li> <li>maxzoom is set to 30</li> </ul>"},{"location":"examples/code/tiler_for_sentinel2/","title":"Custom Sentinel 2 Tiler","text":"<p>Goal: Create a dynamic tiler for Sentinel-2 (using AWS Public Dataset)</p> <p>requirements: titiler.core, titiler.mosaic, rio-tiler-pds</p> <p>Note: See developmentseed/titiler-pds for a end-to-end implementation</p>"},{"location":"examples/code/tiler_for_sentinel2/#sentinel-2","title":"Sentinel 2","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG. More importantly, a STAC database and API has been set up.</p> <p>www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p> <p>The API is provided by @element84 and follows the latest specification: earth-search.aws.element84.com/v0</p> <pre><code>\"\"\"Sentinel 2 (COG) Tiler.\"\"\"\n\nfrom titiler.core.factory import MultiBandTilerFactory\nfrom titiler.core.dependencies import BandsExprParams\nfrom titiler.mosaic.factory import MosaicTilerFactory\n\nfrom rio_tiler_pds.sentinel.aws import S2COGReader\nfrom rio_tiler_pds.sentinel.utils import s2_sceneid_parser\n\nfrom fastapi import FastAPI, Query\n\n\ndef CustomPathParams(\n    sceneid: str = Query(..., description=\"Sentinel 2 Sceneid.\")\n):\n    \"\"\"Create dataset path from args\"\"\"\n    assert s2_sceneid_parser(sceneid)  # Makes sure the sceneid is valid\n    return sceneid\n\n\napp = FastAPI()\n\nscene_tiler = MultiBandTilerFactory(reader=S2COGReader, path_dependency=CustomPathParams, router_prefix=\"scenes\")\napp.include_router(scene_tiler.router, prefix=\"/scenes\", tags=[\"scenes\"])\n\nmosaic_tiler = MosaicTilerFactory(\n    router_prefix=\"mosaic\",\n    dataset_reader=S2COGReader,\n    layer_dependency=BandsExprParams,\n)\napp.include_router(mosaic_tiler.router, prefix=\"/mosaic\", tags=[\"mosaic\"])\n</code></pre>"},{"location":"examples/code/tiler_for_sentinel2/#how-to","title":"How to","text":"<ol> <li> <p>Search for Data <pre><code>import os\nimport json\nimport base64\nimport httpx\nimport datetime\nimport itertools\nimport urllib.parse\nimport pathlib\n\nfrom io import BytesIO\nfrom functools import partial\nfrom concurrent import futures\n\nfrom rasterio.plot import reshape_as_image\nfrom rasterio.features import bounds as featureBounds\n\n# Endpoint variables\ntitiler_endpoint = \"http://127.0.0.1:8000\"\nstac_endpoint = \"https://earth-search.aws.element84.com/v0/search\"\n\n# Make sure both are up\nassert httpx.get(f\"{titiler_endpoint}/docs\").status_code == 200\nassert httpx.get(stac_endpoint).status_code == 200\n\ngeojson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -2.83447265625,\n              4.12728532324537\n            ],\n            [\n              2.120361328125,\n              4.12728532324537\n            ],\n            [\n              2.120361328125,\n              8.254982704877875\n            ],\n            [\n              -2.83447265625,\n              8.254982704877875\n            ],\n            [\n              -2.83447265625,\n              4.12728532324537\n            ]\n          ]\n        ]\n      }\n    }\n  ]\n}\n\nbounds = featureBounds(geojson)\n\nstart = datetime.datetime.strptime(\"2019-01-01\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\")\nend = datetime.datetime.strptime(\"2019-12-11\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")\n\n# POST body\nquery = {\n    \"collections\": [\"sentinel-s2-l2a-cogs\"],\n    \"datetime\": f\"{start}/{end}\",\n    \"query\": {\n        \"eo:cloud_cover\": {\n            \"lt\": 3\n        },\n        \"sentinel:data_coverage\": {\n            \"gt\": 10\n        }\n    },\n    \"intersects\": geojson[\"features\"][0][\"geometry\"],\n    \"limit\": 1000,\n    \"fields\": {\n      'include': ['id', 'properties.datetime', 'properties.eo:cloud_cover'],  # This will limit the size of returned body\n      'exclude': ['assets', 'links']  # This will limit the size of returned body\n    },\n    \"sortby\": [\n        {\n            \"field\": \"properties.eo:cloud_cover\",\n            \"direction\": \"desc\"\n        },\n    ]\n}\n\n# POST Headers\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Accept-Encoding\": \"gzip\",\n    \"Accept\": \"application/geo+json\",\n}\n\ndata = httpx.post(stac_endpoint, headers=headers, json=query).json()\nprint(\"Results context:\")\nprint(data[\"context\"])\n\nsceneid = [f[\"id\"] for f in data[\"features\"]]\ncloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]]\ndates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]\n</code></pre></p> </li> <li> <p>Get TileJSON <pre><code># Fetch TileJSON\n# For this example we use the first `sceneid` returned from the STAC API\n# and we sent the Bands to B04,B03,B02 which are red,green,blue\ndata = httpx.get(f\"{titiler_endpoint}/scenes/WebMercatorQuad/tilejson.json?sceneid={sceneid[4]}&amp;bands=B04&amp;bands=B03&amp;bands=B02&amp;rescale=0,2000\").json()\nprint(data)\n</code></pre></p> </li> <li> <p>Mosaic</p> </li> </ol> <pre><code>from cogeo_mosaic.backends import MosaicBackend\nfrom typing import Dict, List, Sequence, Optional\nfrom pygeos import polygons\nimport mercantile\n\n# Simple Mosaic\ndef custom_accessor(feature):\n    \"\"\"Return feature identifier.\"\"\"\n    return feature[\"id\"]\n\nwith MosaicBackend(\n    \"stac+https://earth-search.aws.element84.com/v0/search\",\n    query,\n    minzoom=8,\n    maxzoom=15,\n    mosaic_options={\"accessor\": custom_accessor},\n) as mosaic:\n    print(mosaic.metadata)\n    mosaic_doc = mosaic.mosaic_def.dict(exclude_none=True)\n\n# Optimized Mosaic\ndef optimized_filter(\n    tile: mercantile.Tile,  # noqa\n    dataset: Sequence[Dict],\n    geoms: Sequence[polygons],\n    minimum_tile_cover=None,  # noqa\n    tile_cover_sort=False,  # noqa\n    maximum_items_per_tile: Optional[int] = None,\n) -&gt; List:\n    \"\"\"Optimized filter that keeps only one item per grid ID.\"\"\"\n    gridid: List[str] = []\n    selected_dataset: List[Dict] = []\n\n    for item in dataset:\n        grid = item[\"id\"].split(\"_\")[1]\n        if grid not in gridid:\n            gridid.append(grid)\n            selected_dataset.append(item)\n\n    dataset = selected_dataset\n\n    indices = list(range(len(dataset)))\n    if maximum_items_per_tile:\n        indices = indices[:maximum_items_per_tile]\n\n    return [dataset[ind] for ind in indices]\n\n\nwith MosaicBackend(\n    \"stac+https://earth-search.aws.element84.com/v0/search\",\n    query,\n    minzoom=8,\n    maxzoom=14,\n    mosaic_options={\"accessor\": custom_accessor, \"asset_filter\": optimized_filter},\n) as mosaic:\n    print(mosaic.metadata)\n    mosaic_doc = mosa\n\n# Write the mosaic\nmosaic_file = \"mymosaic.json.gz\"\nwith MosaicBackend(mosaic_file, mosaic_def=mosaic_doc) as mosaic:\n    mosaic.write(overwrite=True)\n</code></pre> <p>Use the mosaic in titiler <pre><code>mosaic = str(pathlib.Path(mosaic_file).absolute())\ndata = httpx.get(f\"{titiler_endpoint}/mosaic/WebMercatorQuad/tilejson.json?url=file:///{mosaic}&amp;bands=B01&amp;rescale=0,1000\").json()\nprint(data)\n</code></pre></p>"},{"location":"examples/code/tiler_with_auth/","title":"Tiler with Auth","text":"<p>Goal: Add simple token auth</p> <p>requirements: titiler.core, python-jose[cryptography]</p> <p>Learn more about security over FastAPI documentation</p> <p>1 - Security settings (secret key)</p> <pre><code>\"\"\"Security Settings.\n\napp/settings.py\n\n\"\"\"\n\nfrom pydantic import BaseSettings\n\n\nclass AuthSettings(BaseSettings):\n    \"\"\"Application settings\"\"\"\n\n    # Create secret key using `openssl rand -hex 32`\n    # example: \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\"\n    secret: str\n    expires: int = 3600\n    algorithm: str = \"HS256\"\n\n    class Config:\n        \"\"\"model config\"\"\"\n\n        env_prefix = \"SECURITY_\"\n\n\nauth_config = AuthSettings()\n</code></pre> <p>2 - Create a Token <code>Model</code></p> <pre><code>\"\"\"Models.\n\napp/models.py\n\n\"\"\"\n\nfrom datetime import datetime, timedelta\nfrom typing import List, Optional\n\nfrom jose import jwt\nfrom pydantic import BaseModel, Field, validator\n\nfrom .settings import auth_config\n\n# We add scopes - because we are fancy\navailables_scopes = [\"tiles:read\"]\n\n\nclass AccessToken(BaseModel):\n    \"\"\"API Token info.\"\"\"\n\n    sub: str = Field(..., alias=\"username\", regex=\"^[a-zA-Z0-9-_]{1,32}$\")\n    scope: List = [\"tiles:read\"]\n    iat: Optional[datetime] = None\n    exp: Optional[datetime] = None\n    groups: Optional[List[str]]\n\n    @validator(\"iat\", pre=True, always=True)\n    def set_creation_time(cls, v) -&gt; datetime:\n        \"\"\"Set token creation time (iat).\"\"\"\n        return datetime.utcnow()\n\n    @validator(\"exp\", always=True)\n    def set_expiration_time(cls, v, values) -&gt; datetime:\n        \"\"\"Set token expiration time (iat).\"\"\"\n        return values[\"iat\"] + timedelta(seconds=auth_config.expires)\n\n    @validator(\"scope\", each_item=True)\n    def valid_scopes(cls, v, values):\n        \"\"\"Validate Scopes.\"\"\"\n        v = v.lower()\n        if v not in availables_scopes:\n            raise ValueError(f\"Invalid scope: {v}\")\n        return v.lower()\n\n    class Config:\n        \"\"\"Access Token Model config.\"\"\"\n\n        extra = \"forbid\"\n\n    @property\n    def username(self) -&gt; str:\n        \"\"\"Return Username.\"\"\"\n        return self.sub\n\n    def __str__(self):\n        \"\"\"Create jwt token string.\"\"\"\n        return jwt.encode(\n            self.dict(exclude_none=True),\n            auth_config.secret,\n            algorithm=auth_config.algorithm,\n        )\n\n    @classmethod\n    def from_string(cls, token: str):\n        \"\"\"Parse jwt token string.\"\"\"\n        res = jwt.decode(token, auth_config.secret, algorithms=[auth_config.algorithm])\n        user = res.pop(\"sub\")\n        res[\"username\"] = user\n        return cls(**res)\n</code></pre> <p>3 - Create a custom <code>path dependency</code></p> <p>The <code>DatasetPathParams</code> will add 2 querystring parameter to our application: - <code>url</code>: the dataset url (like in the regular titiler app) - <code>access_token</code>: our <code>token</code> parameter</p> <pre><code>\"\"\"Dependencies.\n\napp/dependencies.py\n\n\"\"\"\n\nfrom jose import JWTError\n\nfrom fastapi import HTTPException, Query, Security\nfrom fastapi.security.api_key import APIKeyQuery\n\nfrom .models import AccessToken\n\napi_key_query = APIKeyQuery(name=\"access_token\", auto_error=False)\n\n\n# Custom Dataset Path dependency\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n    api_key_query: str = Security(api_key_query)\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n\n    if not api_key_query:\n        raise HTTPException(status_code=401, detail=\"Missing `access_token`\")\n\n    try:\n        AccessToken.from_string(api_key_query)\n    except JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid `access_token`\")\n\n    return url\n</code></pre> <p>3b - Create a Token creation/read endpoint (Optional)</p> <pre><code>\"\"\"Tokens App.\n\napp/tokens.py\n\n\"\"\"\n\nfrom typing import Any, Dict\n\nfrom .models import AccessToken\n\nfrom fastapi import APIRouter, Query\n\nrouter = APIRouter()\n\n\n@router.post(r\"/create\", responses={200: {\"description\": \"Create a token\"}})\ndef create_token(body: AccessToken):\n    \"\"\"create token.\"\"\"\n    return {\"token\": str(body)}\n\n\n@router.get(r\"/create\", responses={200: {\"description\": \"Create a token\"}})\ndef get_token(\n    username: str = Query(..., description=\"Username\"),\n    scope: str = Query(None, description=\"Coma (,) delimited token scopes\"),\n):\n    \"\"\"create token.\"\"\"\n    params: Dict[str, Any] = {\"username\": username}\n    if scope:\n        params[\"scope\"] = scope.split(\",\")\n    token = AccessToken(**params)\n    return {\"token\": str(token)}\n</code></pre> <p>4 - Create the Tiler app with our custom <code>DatasetPathParams</code></p> <pre><code>\"\"\"app\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\nfrom .dependencies import DatasetPathParams\n\napp = FastAPI(title=\"My simple app with auth\")\n\n# here we create a custom Tiler with out custom DatasetPathParams function\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\n# optional\nfrom . import tokens\napp.include_router(tokens.router)\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/tiler_with_cache/","title":"Tiler with Cache","text":"<p>Goal: Add a cache layer on top of the tiler</p> <p>requirements: titiler.core, aiocache[redis]</p> <p>Note: Use aioredis 1.3 because aiocache doesnt work with aioredis version 2.0</p> <p>1 - Cache settings</p> <pre><code>\"\"\"settings.\n\napp/settings.py\n\n\"\"\"\n\nfrom pydantic import BaseSettings\nfrom typing import Optional\n\n\nclass CacheSettings(BaseSettings):\n    \"\"\"Cache settings\"\"\"\n\n    endpoint: Optional[str] = None\n    ttl: int = 3600\n    namespace: str = \"\"\n\n    class Config:\n        \"\"\"model config\"\"\"\n\n        env_file = \".env\"\n        env_prefix = \"CACHE_\"\n\n\ncache_setting = CacheSettings()\n</code></pre> <p>Env file example with redis URI</p> <pre><code>CACHE_ENDPOINT=redis://127.0.0.1:6379/0\n</code></pre> <p>2 - Cache plugin</p> <p>Because <code>aiocache.cached</code> doesn't support non-async method we have to create a custom <code>cached</code> class</p> <pre><code>\"\"\"Cache Plugin.\n\napp/cache.py\n\n\"\"\"\n\nimport asyncio\nimport urllib\nfrom typing import Any, Dict\n\nimport aiocache\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.responses import Response\n\nfrom fastapi.dependencies.utils import is_coroutine_callable\n\nfrom .settings import cache_setting\n\n\nclass cached(aiocache.cached):\n    \"\"\"Custom Cached Decorator.\"\"\"\n\n    async def get_from_cache(self, key):\n        try:\n            value = await self.cache.get(key)\n            if isinstance(value, Response):\n                value.headers[\"X-Cache\"] = \"HIT\"\n            return value\n        except Exception:\n            aiocache.logger.exception(\n                \"Couldn't retrieve %s, unexpected error\", key\n            )\n\n    async def decorator(\n        self,\n        f,\n        *args,\n        cache_read=True,\n        cache_write=True,\n        aiocache_wait_for_write=True,\n        **kwargs,\n    ):\n        key = self.get_cache_key(f, args, kwargs)\n\n        if cache_read:\n            value = await self.get_from_cache(key)\n            if value is not None:\n                return value\n\n        # CUSTOM, we add support for non-async method\n        if is_coroutine_callable(f):\n            result = await f(*args, **kwargs)\n        else:\n            result = await run_in_threadpool(f, *args, **kwargs)\n\n        if cache_write:\n            if aiocache_wait_for_write:\n                await self.set_in_cache(key, result)\n            else:\n                asyncio.ensure_future(self.set_in_cache(key, result))\n\n        return result\n\n\ndef setup_cache():\n    \"\"\"Setup aiocache.\"\"\"\n    config: Dict[str, Any] = {\n        'cache': \"aiocache.SimpleMemoryCache\",\n        'serializer': {\n            'class': \"aiocache.serializers.PickleSerializer\"\n        }\n    }\n    if cache_setting.ttl is not None:\n        config[\"ttl\"] = cache_setting.ttl\n\n    if cache_setting.endpoint:\n        url = urllib.parse.urlparse(cache_setting.endpoint)\n        ulr_config = dict(urllib.parse.parse_qsl(url.query))\n        config.update(ulr_config)\n\n        cache_class = aiocache.Cache.get_scheme_class(url.scheme)\n        config.update(cache_class.parse_uri_path(url.path))\n        config[\"endpoint\"] = url.hostname\n        config[\"port\"] = str(url.port)\n\n        # Add other configuration into config here, Example for namespace:\n        \"\"\"\n        if cache_setting.namespace != \"\":\n            config[\"namespace\"] = cache_setting.namespace\n        \"\"\"\n\n        if url.password:\n            config[\"password\"] = url.password\n\n        if cache_class == aiocache.Cache.REDIS:\n            config[\"cache\"] = \"aiocache.RedisCache\"\n        elif cache_class == aiocache.Cache.MEMCACHED:\n            config[\"cache\"] = \"aiocache.MemcachedCache\"\n\n    aiocache.caches.set_config({\"default\": config})\n</code></pre> <p>3 - Write a custom minimal Tiler with Cache</p> <pre><code>\"\"\"routes.\n\napp/routes.py\n\"\"\"\nfrom dataclasses import dataclass\nfrom typing import Callable, Dict, Type, Literal, List, Tuple, Optional\nfrom urllib.parse import urlencode\n\nfrom fastapi import Depends, Path, Query\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom morecantile import TileMatrixSet\nfrom rio_tiler.io import BaseReader, Reader\n\nfrom titiler.core.factory import img_endpoint_params\nfrom titiler.core.factory import TilerFactory as TiTilerFactory\nfrom titiler.core.dependencies import RescalingParams\nfrom titiler.core.models.mapbox import TileJSON\nfrom titiler.core.resources.enums import ImageType\n\nfrom .cache import cached\n\n\n@dataclass\nclass TilerFactory(TiTilerFactory):\n\n    reader: Type[BaseReader] = Reader\n\n    def register_routes(self):\n        \"\"\"This Method register routes to the router.\"\"\"\n\n        @self.router.get(r\"/tiles/{z}/{x}/{y}\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{z}/{x}/{y}.{format}\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{z}/{x}/{y}@{scale}x\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{z}/{x}/{y}@{scale}x.{format}\", **img_endpoint_params)\n        @self.router.get(r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}\", **img_endpoint_params)\n        @self.router.get(\n            r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}\", **img_endpoint_params\n        )\n        @self.router.get(\n            r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x\", **img_endpoint_params\n        )\n        @self.router.get(\n            r\"/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x.{format}\",\n            **img_endpoint_params,\n        )\n        # Add default cache config dictionary into cached alias.\n        # Note: if alias is used, other arguments in cached will be ignored. Add other arguments into default dicttionary in setup_cache function.\n        @cached(alias=\"default\")\n        def tile(\n            z: int = Path(..., ge=0, le=30, description=\"TMS tiles's zoom level\"),\n            x: int = Path(..., description=\"TMS tiles's column\"),\n            y: int = Path(..., description=\"TMS tiles's row\"),\n            tileMatrixSetId: Literal[tuple(self.supported_tms.list())] = Query(\n                self.default_tms,\n                description=f\"TileMatrixSet Name (default: '{self.default_tms}')\",\n            ),\n            scale: int = Query(\n                1, gt=0, lt=4, description=\"Tile size scale. 1=256x256, 2=512x512...\"\n            ),\n            format: ImageType = Query(\n                None, description=\"Output image type. Default is auto.\"\n            ),\n            src_path=Depends(self.path_dependency),\n            layer_params=Depends(self.layer_dependency),\n            dataset_params=Depends(self.dataset_dependency),\n            buffer: Optional[float] = Query(\n                None,\n                gt=0,\n                title=\"Tile buffer.\",\n                description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n            ),\n            post_process=Depends(self.process_dependency),\n            rescale: Optional[List[Tuple[float, ...]]] = Depends(RescalingParams),\n            color_formula: Optional[str] = Query(\n                None,\n                title=\"Color Formula\",\n                description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n            ),\n            colormap=Depends(self.colormap_dependency),\n            render_params=Depends(self.render_dependency),\n            reader_params=Depends(self.reader_dependency),\n        ):\n            \"\"\"Create map tile from a dataset.\"\"\"\n            tms = self.supported_tms.get(tileMatrixSetId)\n\n            with self.reader(src_path, tms=tms, **reader_params) as src_dst:\n                image = src_dst.tile(\n                    x,\n                    y,\n                    z,\n                    tilesize=scale * 256,\n                    buffer=buffer,\n                    **layer_params,\n                    **dataset_params,\n                )\n                dst_colormap = getattr(src_dst, \"colormap\", None)\n\n\n            if post_process:\n                image = post_process(image)\n\n            if rescale:\n                image.rescale(rescale)\n\n            if color_formula:\n                image.apply_color_formula(color_formula)\n\n            if cmap := colormap or dst_colormap:\n                image = image.apply_colormap(cmap)\n\n            if not format:\n                format = ImageType.jpeg if image.mask.all() else ImageType.png\n\n            content = image.render(\n                img_format=format.driver,\n                **format.profile,\n                **render_params,\n            )\n\n            return Response(content, media_type=format.mediatype)\n\n        @self.router.get(\n            \"/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        @self.router.get(\n            \"/{tileMatrixSetId}/tilejson.json\",\n            response_model=TileJSON,\n            responses={200: {\"description\": \"Return a tilejson\"}},\n            response_model_exclude_none=True,\n        )\n        @cached(alias=\"default\")\n        def tilejson(\n            request: Request,\n            tileMatrixSetId: Literal[tuple(self.supported_tms.list())] = Query(\n                self.default_tms,\n                description=f\"TileMatrixSet Name (default: '{self.default_tms}')\",\n            ),\n            src_path=Depends(self.path_dependency),\n            tile_format: Optional[ImageType] = Query(\n                None, description=\"Output image type. Default is auto.\"\n            ),\n            tile_scale: int = Query(\n                1, gt=0, lt=4, description=\"Tile size scale. 1=256x256, 2=512x512...\"\n            ),\n            minzoom: Optional[int] = Query(\n                None, description=\"Overwrite default minzoom.\"\n            ),\n            maxzoom: Optional[int] = Query(\n                None, description=\"Overwrite default maxzoom.\"\n            ),\n            layer_params=Depends(self.layer_dependency),  # noqa\n            dataset_params=Depends(self.dataset_dependency),  # noqa\n            buffer: Optional[float] = Query(  # noqa\n                None,\n                gt=0,\n                title=\"Tile buffer.\",\n                description=\"Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).\",\n            ),\n            post_process=Depends(self.process_dependency),  # noqa\n            rescale: Optional[List[Tuple[float, ...]]] = Depends(\n                RescalingParams\n            ),  # noqa\n            color_formula: Optional[str] = Query(  # noqa\n                None,\n                title=\"Color Formula\",\n                description=\"rio-color formula (info: https://github.com/mapbox/rio-color)\",\n            ),\n            colormap=Depends(self.colormap_dependency),  # noqa\n            render_params=Depends(self.render_dependency),  # noqa\n            reader_params=Depends(self.reader_dependency),\n        ):\n            \"\"\"Return TileJSON document for a dataset.\"\"\"\n            route_params = {\n                \"z\": \"{z}\",\n                \"x\": \"{x}\",\n                \"y\": \"{y}\",\n                \"scale\": tile_scale,\n                \"tileMatrixSetId\": tileMatrixSetId,\n            }\n            if tile_format:\n                route_params[\"format\"] = tile_format.value\n\n            tiles_url = self.url_for(request, \"tile\", **route_params)\n\n            qs_key_to_remove = [\n                \"tilematrixsetid\",\n                \"tile_format\",\n                \"tile_scale\",\n                \"minzoom\",\n                \"maxzoom\",\n            ]\n            qs = [\n                (key, value)\n                for (key, value) in request.query_params._list\n                if key.lower() not in qs_key_to_remove\n            ]\n            if qs:\n                tiles_url += f\"?{urlencode(qs)}\"\n\n            tms = self.supported_tms.get(tileMatrixSetId)\n            with self.reader(src_path, tms=tms, **reader_params) as src_dst:\n                return {\n                    \"bounds\": src_dst.geographic_bounds,\n                    \"minzoom\": minzoom if minzoom is not None else src_dst.minzoom,\n                    \"maxzoom\": maxzoom if maxzoom is not None else src_dst.maxzoom,\n                    \"tiles\": [tiles_url],\n                }\n\n        # Register Map viewer\n        self.map_viewer()\n\ncog = TilerFactory()\n</code></pre> <p>4 - Create the Tiler app with our custom <code>DatasetPathParams</code></p> <pre><code>\"\"\"app\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\nfrom .cache import setup_cache\nfrom .routes import cog\n\napp = FastAPI(title=\"My simple app with cache\")\n\n# Setup Cache on Startup\napp.add_event_handler(\"startup\", setup_cache)\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n</code></pre>"},{"location":"examples/code/tiler_with_custom_algorithm/","title":"Add custom algorithms","text":"<p>Goal: add custom Algorithm to a tiler</p> <p>requirements: titiler.core</p> <p>1 - Create a custom algorithm and register it to the list of available algorithms</p> <pre><code>\"\"\"algos.\n\napp/algorithms.py\n\n\"\"\"\nfrom titiler.core.algorithm import BaseAlgorithm\nfrom titiler.core.algorithm import algorithms as default_algorithms\n\nfrom rio_tiler.models import ImageData\n\n\nclass Multiply(BaseAlgorithm):\n\n    # Parameters\n    factor: int # There is no default, which means calls to this algorithm without any parameter will fail\n\n    # We don't set any metadata for this Algorithm\n\n    def __call__(self, img: ImageData) -&gt; ImageData:\n        # Multiply image data bcy factor\n        data = img.data * self.factor\n\n        # Create output ImageData\n        return ImageData(\n            data,\n            assets=img.assets,\n            crs=img.crs,\n            bounds=img.bounds,\n        )\n\n# default_algorithms is a `titiler.core.algorithm.Algorithms` Object\nalgorithms = default_algorithms.register(\n    {\n        \"multiply\": Multiply,\n    }\n)\n</code></pre> <p>2 - Create application and register endpoints</p> <pre><code>\"\"\"application.\n\napp/app.py\n\n\"\"\"\nfrom fastapi import FastAPI\nfrom titiler.core.factory import TilerFactory\n\nfrom .algorithms import algorithms\n\n\napp = FastAPI(title=\"My simple app with custom Algorithm\")\n\n# The Algorithms class (titiler.core.algorithm.algorithms) as a `dependency` property which return a process_dependency.\ntiler = TilerFactory(process_dependency=algorithms.dependency)\napp.include_router(tiler.router)\n</code></pre>"},{"location":"examples/code/tiler_with_custom_colormap/","title":"Tiler with custom Colormap dependency","text":"<p>Goal: Add a custom colormap dependency to allow user pass linear <code>colormap</code> definition.</p> <pre><code># https://colorbrewer2.org/#type=sequential&amp;scheme=BuGn&amp;n=3\ncmap = urlencode(\n    {\n        \"colormap\": json.dumps(\n            {\n                \"0\": \"#e5f5f9\",\n                \"10\": \"#99d8c9\",\n                \"255\": \"#2ca25f\",\n            }\n        )\n    }\n)\nresponse = requests.get(\n    f\"http://127.0.0.1:8000/cog/tiles/WebMercatorQuad/8/53/50.png?url=https://myurl.com/cog.tif&amp;bidx=1&amp;rescale=0,10000&amp;{cmap}\"\n)\n</code></pre> <p>requirements: titiler.core matplotlib</p> <p>1 - Create a custom <code>ColorMapParams</code> dependency</p> <pre><code>\"\"\"dependencies.\n\napp/dependencies.py\n\n\"\"\"\n\nimport json\n\nfrom typing import Dict, Optional, Literal\nfrom typing_extensions import Annotated\n\nimport numpy\nimport matplotlib\nfrom rio_tiler.colormap import parse_color\nfrom rio_tiler.colormap import cmap as default_cmap\nfrom fastapi import HTTPException, Query\n\n\ndef ColorMapParams(\n    colormap_name: Annotated[  # type: ignore\n        Literal[tuple(default_cmap.list())],\n        Query(description=\"Colormap name\"),\n    ] = None,\n    colormap: Annotated[\n        str,\n        Query(description=\"JSON encoded custom Colormap\"),\n    ] = None,\n    colormap_type: Annotated[\n        Literal[\"explicit\", \"linear\"],\n        Query(description=\"User input colormap type.\"),\n    ] = \"explicit\",\n) -&gt; Optional[Dict]:\n    \"\"\"Colormap Dependency.\"\"\"\n    if colormap_name:\n        return default_cmap.get(colormap_name)\n\n    if colormap:\n        try:\n            cm = json.loads(\n                colormap,\n                object_hook=lambda x: {int(k): parse_color(v) for k, v in x.items()},\n            )\n        except json.JSONDecodeError:\n            raise HTTPException(\n                status_code=400, detail=\"Could not parse the colormap value.\"\n            )\n\n        if colormap_type == \"linear\":\n            # input colormap has to start from 0 to 255 ?\n            cm = matplotlib.colors.LinearSegmentedColormap.from_list(\n                'custom',\n                [\n                    (k / 255, matplotlib.colors.to_hex([v / 255 for v in rgba]))\n                    for (k, rgba) in cm.items()\n                ],\n                256,\n            )\n            x = numpy.linspace(0, 1, 256)\n            cmap_vals = cm(x)[:, :]\n            cmap_uint8 = (cmap_vals * 255).astype('uint8')\n            cm = {idx: value.tolist() for idx, value in enumerate(cmap_uint8)}\n\n        return cm\n\n    return None\n</code></pre> <p>2 - Create app and register our custom endpoints</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\nfrom titiler.core.factory import TilerFactory\n\nfrom fastapi import FastAPI\n\nfrom .dependencies import ColorMapParams\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\ncog = TilerFactory(colormap_dependency=ColorMapParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/tiler_with_custom_stac_validation/","title":"STAC endpoints with custom `/validate`","text":"<p>Goal: Create a custom STAC endpoints with validation</p> <p>requirements: <code>titiler.core</code> &amp;&amp; <code>jsonschema</code></p> <pre><code>\"\"\"FastAPI application.\"\"\"\n\nfrom fastapi import FastAPI\n\nfrom rio_tiler.io import STACReader\n\nfrom titiler.core.dependencies import DatasetPathParams\nfrom titiler.core.factory import MultiBaseTilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\n\n# STAC uses MultiBaseReader so we use MultiBaseTilerFactory to built the default endpoints\nstac = MultiBaseTilerFactory(reader=STACReader, router_prefix=\"stac\")\n\n\n# We add `/validate` to the router\n@stac.router.get(\"/validate\")\ndef stac_validate_get(src_path=Depends(DatasetPathParams)):\n    \"\"\"STAC validation.\"\"\"\n    with STACReader(src_path) as stac_src:\n       return stac_src.item.validate()\n\n\n# Create FastAPI application\napp = FastAPI(title=\"My simple app with custom STAC endpoint\")\napp.include_router(stac.router, tags=[\"STAC\"])\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/tiler_with_custom_tms/","title":"Tiler with custom TMS","text":"<p>Goal: add custom TMS to a tiler</p> <p>requirements: titiler.core</p> <p>1 - Create custom TMS and custom endpoints</p> <pre><code>\"\"\"routes.\n\napp/routes.py\n\n\"\"\"\n\nfrom titiler.core.factory import TilerFactory, TMSFactory\nfrom morecantile import tms, TileMatrixSet\nfrom pyproj import CRS\n\n# 1. Create Custom TMS\nEPSG6933 = TileMatrixSet.custom(\n    (-17357881.81713629, -7324184.56362408, 17357881.81713629, 7324184.56362408),\n    CRS.from_epsg(6933),\n    id=\"EPSG6933\",\n    matrix_scale=[1, 1],\n)\n# 2. Register TMS\ntms = tms.register({EPSG6933.id:EPSG6933})\n\ntms_factory = TMSFactory(supported_tms=tms)\ncog_factory = TilerFactory(supported_tms=tms)\n</code></pre> <p>2 - Create app and register our custom endpoints</p> <pre><code>\"\"\"app.\n\napp/main.py\n\n\"\"\"\n\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\nfrom .routes import cog_factory, tms_factory\n\napp = FastAPI(title=\"My simple app with custom TMS\")\n\napp.include_router(cog_factory.router, tags=[\"Cloud Optimized GeoTIFF\"])\napp.include_router(tms_factory.router, tags=[\"Tiling Schemes\"])\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n</code></pre>"},{"location":"examples/code/working_with_signed_urls/","title":"Loading data with signed URLs","text":"<p>ref: developmentseed/titiler?331</p> <p>Goal: allow users to pass signed url or url containing query parameters (delimited with <code>&amp;</code>)</p> <p>requirements: titiler.core</p>"},{"location":"examples/code/working_with_signed_urls/#what-why-how","title":"What / Why / How","text":"<p>Passing a signed URL or a complex URL for a dataset is not supported by default in TiTiler because the parameters (delimited with <code>&amp;</code>) from the signed url conflict with the query parameters from the application itself. In order to allow signed url in the application there are two solutions:</p>"},{"location":"examples/code/working_with_signed_urls/#1-url-encoding","title":"1. URL Encoding","text":""},{"location":"examples/code/working_with_signed_urls/#11-full-url","title":"1.1 Full URL","text":"<p>The easiest way (from the application's point of view) to allow complex URLs is to allow an encoded url as an input parameter.</p> <pre><code>import base64\nurl = \"http://my.dataset.com/cog.tif?p=aaa&amp;c&amp;1234&amp;t=4321\"\n\n# base64.b64encode(url.encode())\n&gt;&gt;&gt; \"aHR0cDovL215LmRhdGFzZXQuY29tL2NvZy50aWY/cD1hYWEmYyYxMjM0JnQ9NDMyMQ==\"\n</code></pre> <p>When base64 encoded, the url is just a regular string and thus will be valid in the application.</p> <pre><code>\"\"\"Minimal COG tiler with Signed URL support.\"\"\"\n\nimport base64\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\n# Custom Path dependency which can `decode` a base64 url\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n    base64_encoded: bool = Query(None)\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    if base64_encoded:\n        url = base64.b64decode(url).decode()\n    return url\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre> <pre><code>import base64\nfrom my_provider import signed_url\n\nmy_url = \"https://dataset.com/....\"\n\n# Get signed URL\nmy_signed_url = signed_url(my_url)\n\n# Encode the signed url using base64\nurl = base64.b64encode(my_signed_url.encode())\n\ninfo = request.get(f\"{titiler_endpoint}/info\", params={\"url\": url, signed_url: True})\n</code></pre>"},{"location":"examples/code/working_with_signed_urls/#12-encode-only-the-url-params","title":"1.2 Encode only the url params","text":"<pre><code>\"\"\"Minimal COG tiler with Signed URL support.\"\"\"\n\nimport base64\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\n# Another solution is to pass only the query parameters encoded in base64\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n    url_params: str = Query(\n        None, description=\"Base64 encoded Query parameters to add to the dataset URL.\"\n    ),\n) -&gt; str:\n    \"\"\"DatasetPath Params.\"\"\"\n    if url_params:\n        url += f\"?{b64decode(url_params).decode()}\"\n    return url\n\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre> <pre><code>import base64\nfrom urllib.parse import urlparse\nfrom my_provider import signed_url\n\nmy_url = \"https://dataset.com/....\"\n\n# Get signed URL\nmy_signed_url = signed_url(my_url)\n\n# Extract the url parameters\nsigned_params = urlparse(my_signed_url).query\n\n# Encode the parameters using base64\nencoded_params = base64.b64encode(signed_params.encode())\n\ninfo = request.get(f\"{titiler_endpoint}/info\", params={\"url\": url, url_params: encoded_params})\n</code></pre>"},{"location":"examples/code/working_with_signed_urls/#2-signing-url-in-the-application","title":"2. Signing URL in the application","text":"<p>Another solution is to sign the URL directly in TiTiler.</p> <pre><code>\"\"\"Minimal COG tiler with Signed URL support.\"\"\"\n\nimport my_provider  # e.g AWS, Google, ...\n\nfrom titiler.core.factory import TilerFactory\nfrom titiler.core.errors import DEFAULT_STATUS_CODES, add_exception_handlers\n\nfrom fastapi import FastAPI\n\n\n# Custom Path dependency which will sign url\n# !!! You may want to add caching here to avoid to many call to the signing provider !!!\ndef DatasetPathParams(\n    url: str = Query(..., description=\"Dataset URL\"),\n) -&gt; str:\n    \"\"\"Create dataset path from args\"\"\"\n    # Use your provider library to sign the URL\n    return my_provider.sign(url)\n\n\napp = FastAPI(title=\"My simple app\")\n\ncog = TilerFactory(path_dependency=DatasetPathParams)\napp.include_router(cog.router, tags=[\"Cloud Optimized GeoTIFF\"])\n\nadd_exception_handlers(app, DEFAULT_STATUS_CODES)\n\n\n@app.get(\"/healthz\", description=\"Health Check\", tags=[\"Health Check\"])\ndef ping():\n    \"\"\"Health check.\"\"\"\n    return {\"ping\": \"pong!\"}\n</code></pre> <pre><code>import base64\nfrom my_provider import signed_url\n\nmy_url = \"https://dataset.com/....\"\n\ninfo = request.get(f\"{titiler_endpoint}/info\", params={\"url\": my_url})\n</code></pre>"},{"location":"examples/notebooks/Working_with_Algorithm/","title":"Working With Algorithms","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport httpx\n\nfrom folium import Map, TileLayer\n</pre> import json import httpx  from folium import Map, TileLayer In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n</pre> titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. In\u00a0[\u00a0]: Copied! <pre>url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"\n</pre> url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\" In\u00a0[\u00a0]: Copied! <pre># Fetch dataset Metadata\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nprint(r)\n</pre> # Fetch dataset Metadata r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params = {         \"url\": url,     } ).json()  print(r) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"]\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\"\n).add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] )  TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\" ).add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n        # rio-tiler cannot rescale automatically the data when using a colormap\n        \"rescale\": \"1615.812,2015.09448\",\n        \"colormap_name\": \"terrain\",\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"]\n)\n\naod_layer = TileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\"\n)\naod_layer.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,         # rio-tiler cannot rescale automatically the data when using a colormap         \"rescale\": \"1615.812,2015.09448\",         \"colormap_name\": \"terrain\",     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] )  aod_layer = TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Office f\u00e9d\u00e9ral de topographie swisstopo\" ) aod_layer.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Fetch algorithms\nprint(\"Available algorithm\")\nprint(list(httpx.get(f\"{titiler_endpoint}/algorithms\").json()))\nprint()\nprint(\"Metadata from `Hillshade` algorithm\")\nmeta = httpx.get(f\"{titiler_endpoint}/algorithms/hillshade\").json()\nprint(\"Inputs\")\nprint(meta[\"inputs\"])\nprint(\"Outputs\")\nprint(meta[\"outputs\"])\nprint(\"Parameters\")\nprint(meta[\"parameters\"])\n</pre> # Fetch algorithms print(\"Available algorithm\") print(list(httpx.get(f\"{titiler_endpoint}/algorithms\").json())) print() print(\"Metadata from `Hillshade` algorithm\") meta = httpx.get(f\"{titiler_endpoint}/algorithms/hillshade\").json() print(\"Inputs\") print(meta[\"inputs\"]) print(\"Outputs\") print(meta[\"outputs\"]) print(\"Parameters\") print(meta[\"parameters\"]) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n        \"algorithm\": \"hillshade\",\n        # Hillshade algorithm use a 3pixel buffer so we need\n        # to tell the tiler to apply a 3 pixel buffer around each tile\n        \"buffer\": 3,\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"]\n)\n\naod_layer = TileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Yo!!\"\n)\naod_layer.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,         \"algorithm\": \"hillshade\",         # Hillshade algorithm use a 3pixel buffer so we need         # to tell the tiler to apply a 3 pixel buffer around each tile         \"buffer\": 3,     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] )  aod_layer = TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Yo!!\" ) aod_layer.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n        \"algorithm\": \"contours\",\n        \"algorithm_params\": json.dumps(\n            {\n                \"increment\": 20, # contour line every 20 meters\n                \"thickness\": 2, # 2m thickness\n                \"minz\": 1600,\n                \"maxz\": 2000\n            }\n        ),\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"]\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Yo!!\"\n).add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,         \"algorithm\": \"contours\",         \"algorithm_params\": json.dumps(             {                 \"increment\": 20, # contour line every 20 meters                 \"thickness\": 2, # 2m thickness                 \"minz\": 1600,                 \"maxz\": 2000             }         ),     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] )  TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Yo!!\" ).add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n        \"algorithm\": \"contours\",\n        \"algorithm_params\": json.dumps(\n            {\n                \"increment\": 5, # contour line every 5 meters\n                \"thickness\": 1, # 1m thickness\n                \"minz\": 1600,\n                \"maxz\": 2000\n            }\n        ),\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"]\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Yo!!\"\n).add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,         \"algorithm\": \"contours\",         \"algorithm_params\": json.dumps(             {                 \"increment\": 5, # contour line every 5 meters                 \"thickness\": 1, # 1m thickness                 \"minz\": 1600,                 \"maxz\": 2000             }         ),     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] )  TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Yo!!\" ).add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_Algorithm/#working-with-algorithms","title":"Working With Algorithms\u00b6","text":"<p>For this demo we will use some elevation data from https://www.swisstopo.admin.ch/fr/geodata/height/alti3d.html  dataset</p>"},{"location":"examples/notebooks/Working_with_Algorithm/#requirements","title":"Requirements\u00b6","text":"<ul> <li>folium</li> <li>httpx</li> </ul> <p><code>!pip install folium httpx</code></p>"},{"location":"examples/notebooks/Working_with_Algorithm/#get-cog-info","title":"Get COG Info\u00b6","text":""},{"location":"examples/notebooks/Working_with_Algorithm/#display-tiles","title":"Display Tiles\u00b6","text":"<p>By default, the tiles will be rescaled from min/max from dataset statistics (1615.812 / 2015.09448)</p>"},{"location":"examples/notebooks/Working_with_Algorithm/#show-available-algorithms","title":"Show Available Algorithms\u00b6","text":""},{"location":"examples/notebooks/Working_with_Algorithm/#display-hillshade-tiles","title":"Display Hillshade Tiles\u00b6","text":""},{"location":"examples/notebooks/Working_with_Algorithm/#pass-parameters-to-the-algorithm","title":"Pass parameters to the algorithm\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/","title":"Working With COG - At Scale","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install rasterio boto3 folium requests tqdm\n</pre> # Uncomment this line if you need to install the dependencies # !pip install rasterio boto3 folium requests tqdm In\u00a0[\u00a0]: Copied! <pre>import os\nimport datetime\nimport json\nimport urllib.parse\nfrom io import BytesIO\nfrom functools import partial\nfrom concurrent import futures\n\nimport httpx\nimport numpy\nfrom boto3.session import Session as boto3_session\n\nfrom rasterio.plot import reshape_as_image\nfrom rasterio.features import bounds as featureBounds\n\nfrom tqdm.notebook import tqdm\n\nfrom folium import Map, TileLayer, GeoJson\n\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n</pre> import os import datetime import json import urllib.parse from io import BytesIO from functools import partial from concurrent import futures  import httpx import numpy from boto3.session import Session as boto3_session  from rasterio.plot import reshape_as_image from rasterio.features import bounds as featureBounds  from tqdm.notebook import tqdm  from folium import Map, TileLayer, GeoJson  import matplotlib.pyplot as plt import matplotlib.dates as mdates In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n</pre> titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. In\u00a0[\u00a0]: Copied! <pre># use geojson.io\ngeojson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -74.1796875,\n              45.18978009667531\n            ],\n            [\n              -73.092041015625,\n              45.18978009667531\n            ],\n            [\n              -73.092041015625,\n              46.00459325574482\n            ],\n            [\n              -74.1796875,\n              46.00459325574482\n            ],\n            [\n              -74.1796875,\n              45.18978009667531\n            ]\n          ]\n        ]\n      }\n    }\n  ]\n}\n\nbounds = featureBounds(geojson)\n</pre> # use geojson.io geojson = {   \"type\": \"FeatureCollection\",   \"features\": [     {       \"type\": \"Feature\",       \"properties\": {},       \"geometry\": {         \"type\": \"Polygon\",         \"coordinates\": [           [             [               -74.1796875,               45.18978009667531             ],             [               -73.092041015625,               45.18978009667531             ],             [               -73.092041015625,               46.00459325574482             ],             [               -74.1796875,               46.00459325574482             ],             [               -74.1796875,               45.18978009667531             ]           ]         ]       }     }   ] }  bounds = featureBounds(geojson) In\u00a0[\u00a0]: Copied! <pre>m = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=6\n)\n\nGeoJson(geojson).add_to(m)\nm\n</pre> m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=6 )  GeoJson(geojson).add_to(m) m In\u00a0[\u00a0]: Copied! <pre># To Be able to run this notebook you'll need to have AWS credential available in the environment\n\n# import os\n# os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\"\n# os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\"\n</pre> # To Be able to run this notebook you'll need to have AWS credential available in the environment  # import os # os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\" # os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\" In\u00a0[\u00a0]: Copied! <pre>session = boto3_session(region_name=\"us-west-2\")\nclient = session.client(\"s3\")\n\nbucket = \"omi-no2-nasa\"  #https://registry.opendata.aws/omi-no2-nasa/\n\n\ndef list_objects(bucket, prefix):\n    \"\"\"AWS s3 list objects.\"\"\"\n\n    paginator = client.get_paginator('list_objects_v2')\n\n    files = []\n    for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):\n        files.extend(subset.get(\"Contents\", []))\n\n    return files\n\nlist_files = list_objects(bucket, \"OMI-Aura_L3\")\n\nprint(\"Archive Size\")\nfiles = [r[\"Key\"] for r in list_files]\nprint(f\"Found {len(files)} OMI-NO2 files\")\n\nsize = sum([r[\"Size\"]/1000000. for r in list_files])\nprint(f\"Size of the archive: {size} Mo ({size / 1000} Go)\")\n</pre> session = boto3_session(region_name=\"us-west-2\") client = session.client(\"s3\")  bucket = \"omi-no2-nasa\"  #https://registry.opendata.aws/omi-no2-nasa/   def list_objects(bucket, prefix):     \"\"\"AWS s3 list objects.\"\"\"      paginator = client.get_paginator('list_objects_v2')      files = []     for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):         files.extend(subset.get(\"Contents\", []))      return files  list_files = list_objects(bucket, \"OMI-Aura_L3\")  print(\"Archive Size\") files = [r[\"Key\"] for r in list_files] print(f\"Found {len(files)} OMI-NO2 files\")  size = sum([r[\"Size\"]/1000000. for r in list_files]) print(f\"Size of the archive: {size} Mo ({size / 1000} Go)\") In\u00a0[\u00a0]: Copied! <pre>print(files[0:10])\n</pre> print(files[0:10]) <p>file name structure is <code>\"OMI-Aura_L3-OMNO2d_{YEAR}m{MONTH:02}{DAY:02}...\"</code></p> <p>We can then easily filter e.g</p> In\u00a0[\u00a0]: Copied! <pre>files_2019 = list(filter(lambda x: x.split(\"_\")[2][0:4] == \"2019\", files))\nprint(len(files_2019))\n</pre> files_2019 = list(filter(lambda x: x.split(\"_\")[2][0:4] == \"2019\", files)) print(len(files_2019)) In\u00a0[\u00a0]: Copied! <pre>files_Oct5 = list(filter(lambda x: (x.split(\"_\")[2][5:7] == \"10\") &amp; (x.split(\"_\")[2][7:9] == \"05\"), files))\nprint(len(files_Oct5))\nprint(files_Oct5)\n</pre> files_Oct5 = list(filter(lambda x: (x.split(\"_\")[2][5:7] == \"10\") &amp; (x.split(\"_\")[2][7:9] == \"05\"), files)) print(len(files_Oct5)) print(files_Oct5) In\u00a0[\u00a0]: Copied! <pre>def _url(src_path):\n    return f\"s3://omi-no2-nasa/{src_path}\"\n</pre> def _url(src_path):     return f\"s3://omi-no2-nasa/{src_path}\" In\u00a0[\u00a0]: Copied! <pre># Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\n\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params = {\n        \"url\": _url(files[0])\n    }\n).json()\n\nprint(json.dumps(r, indent=4))\n</pre> # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)  r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params = {         \"url\": _url(files[0])     } ).json()  print(json.dumps(r, indent=4)) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": _url(files[2]),\n        \"rescale\": \"0,3000000000000000\",\n        \"colormap_name\": \"viridis\",\n    }\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=6\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"NASA\"\n).add_to(m)\n\nGeoJson(geojson, style_function=lambda feature: {\"fill\": False, \"color\": \"red\"}).add_to(m)\n\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": _url(files[2]),         \"rescale\": \"0,3000000000000000\",         \"colormap_name\": \"viridis\",     } ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=6 )  TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"NASA\" ).add_to(m)  GeoJson(geojson, style_function=lambda feature: {\"fill\": False, \"color\": \"red\"}).add_to(m)  m In\u00a0[\u00a0]: Copied! <pre>def _stats(data, mask):\n    arr = numpy.ma.array(data)\n    arr.mask = mask == 0\n    return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item()\n\n\nxmin, ymin, xmax, ymax = bounds\n\ndef fetch_bbox(file):\n    url = f\"{titiler_endpoint}/cog/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"\n    params = {\n        \"url\": _url(file),\n        \"bidx\": \"1\",\n        \"max_size\": 128,\n    }\n    r = httpx.get(url, params=params)\n    data = numpy.load(BytesIO(r.content))\n    s = _stats(data[0:-1], data[-1])\n    return (\n        _stats(data[0:-1], data[-1]),\n        datetime.datetime.strptime(file.split(\"_\")[2].replace(\"m\", \"\"), \"%Y%m%d\"),\n    )\n\n# small tool to filter invalid response from the API\ndef _filter_futures(tasks):\n    for future in tasks:\n        try:\n            yield future.result()\n        except Exception:\n            pass\n</pre> def _stats(data, mask):     arr = numpy.ma.array(data)     arr.mask = mask == 0     return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item()   xmin, ymin, xmax, ymax = bounds  def fetch_bbox(file):     url = f\"{titiler_endpoint}/cog/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"     params = {         \"url\": _url(file),         \"bidx\": \"1\",         \"max_size\": 128,     }     r = httpx.get(url, params=params)     data = numpy.load(BytesIO(r.content))     s = _stats(data[0:-1], data[-1])     return (         _stats(data[0:-1], data[-1]),         datetime.datetime.strptime(file.split(\"_\")[2].replace(\"m\", \"\"), \"%Y%m%d\"),     )  # small tool to filter invalid response from the API def _filter_futures(tasks):     for future in tasks:         try:             yield future.result()         except Exception:             pass In\u00a0[\u00a0]: Copied! <pre># Every 15 of each month for all the years\nfiles_15 = list(filter(lambda x: (x.split(\"_\")[2][7:9] == \"15\"), files))\n</pre> # Every 15 of each month for all the years files_15 = list(filter(lambda x: (x.split(\"_\")[2][7:9] == \"15\"), files)) In\u00a0[\u00a0]: Copied! <pre>with futures.ThreadPoolExecutor(max_workers=10) as executor:\n    future_work = [\n        executor.submit(fetch_bbox, file) for file in files_15\n    ]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nvalues, dates  = zip(*list(_filter_futures(future_work)))\n\nmax_values = [\n    v[1]\n    for v in values\n]\n\nfig, ax1 = plt.subplots(dpi=300)\nfig.autofmt_xdate()\n\nax1.plot(dates, max_values, label=\"No2\")\nax1.xaxis.set_major_locator(mdates.YearLocator(1,7))\n\nax1.set_xlabel(\"Dates\")\nax1.set_ylabel(\"No2\")\n\nax1.legend()\n</pre> with futures.ThreadPoolExecutor(max_workers=10) as executor:     future_work = [         executor.submit(fetch_bbox, file) for file in files_15     ]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  values, dates  = zip(*list(_filter_futures(future_work)))  max_values = [     v[1]     for v in values ]  fig, ax1 = plt.subplots(dpi=300) fig.autofmt_xdate()  ax1.plot(dates, max_values, label=\"No2\") ax1.xaxis.set_major_locator(mdates.YearLocator(1,7))  ax1.set_xlabel(\"Dates\") ax1.set_ylabel(\"No2\")  ax1.legend() In\u00a0[\u00a0]: Copied! <pre>with futures.ThreadPoolExecutor(max_workers=50) as executor:\n    future_work = [\n        executor.submit(fetch_bbox, file) for file in files\n    ]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nvalues, dates  = zip(*list(_filter_futures(future_work)))\n\nmax_values = [\n    v[1]\n    for v in values\n]\n\nfig, ax1 = plt.subplots(dpi=150)\nfig.autofmt_xdate()\n\nax1.plot(dates, max_values, label=\"No2\")\nax1.xaxis.set_major_locator(mdates.YearLocator())\n\nax1.set_xlabel(\"Dates\")\nax1.set_ylabel(\"No2\")\n\nax1.legend()\n</pre> with futures.ThreadPoolExecutor(max_workers=50) as executor:     future_work = [         executor.submit(fetch_bbox, file) for file in files     ]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  values, dates  = zip(*list(_filter_futures(future_work)))  max_values = [     v[1]     for v in values ]  fig, ax1 = plt.subplots(dpi=150) fig.autofmt_xdate()  ax1.plot(dates, max_values, label=\"No2\") ax1.xaxis.set_major_locator(mdates.YearLocator())  ax1.set_xlabel(\"Dates\") ax1.set_ylabel(\"No2\")  ax1.legend() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#working-with-cog-at-scale","title":"Working With COG - At Scale\u00b6","text":"<p>For this demo we will use the new <code>Ozone Monitoring Instrument (OMI) / Aura NO2 Tropospheric Column Density</code> dataset hosted on AWS PDS: https://registry.opendata.aws/omi-no2-nasa/</p> <p>Requirement: AWS credentials</p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#requirements","title":"Requirements\u00b6","text":"<ul> <li>AWS credentials</li> <li>rasterio</li> <li>folium</li> <li>httpx</li> <li>tqdm</li> </ul> <p><code>!pip install rasterio boto3 folium httpx tqdm</code></p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#define-your-area-of-interest-aoi","title":"Define your area of interest (AOI)\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#list-available-files-on-aws-s3","title":"List available files on AWS S3\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#data-endpoint","title":"DATA Endpoint\u00b6","text":"<p><code>{endpoint}/cog/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}?url={cog}&amp;{otherquery params}</code></p> <p><code>{endpoint}/cog/bbox/{minx},{miny},{maxx},{maxy}.{format}?url={cog}&amp;{otherquery params}</code></p> <p><code>{endpoint}/cog/point/{minx},{miny}?url={cog}&amp;{otherquery params}</code></p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#visualize-one-item","title":"Visualize One Item\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#create-time-series-of-no2","title":"Create time series of NO2\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#get-no2-max-for-day-15th-of-each-month","title":"Get NO2 Max for day 15th of each month\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF/#same-but-for-all-the-days-for-the-last-16-years","title":"Same but for all the days for the last 16 years\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/","title":"Working With COG","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install folium httpx\n</pre> # Uncomment this line if you need to install the dependencies # !pip install folium httpx In\u00a0[\u00a0]: Copied! <pre>import json\n\nimport httpx\n\nfrom folium import Map, TileLayer\n\n%matplotlib inline\n</pre> import json  import httpx  from folium import Map, TileLayer  %matplotlib inline In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n</pre> titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\" In\u00a0[\u00a0]: Copied! <pre># Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nbounds = r[\"bounds\"]\nprint(r)\n</pre> # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32) r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params = {         \"url\": url,     } ).json()  bounds = r[\"bounds\"] print(r) In\u00a0[\u00a0]: Copied! <pre># Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nprint(json.dumps(r, indent=4))\n</pre> # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32) r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params = {         \"url\": url,     } ).json()  print(json.dumps(r, indent=4)) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=13\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"DigitalGlobe OpenData\"\n).add_to(m)\n\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,     } ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=13 )  TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"DigitalGlobe OpenData\" ).add_to(m)  m In\u00a0[\u00a0]: Copied! <pre>url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"\n\n# Fetch File Metadata to get min/max rescaling values (because the file is stored as float32)\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nprint(r)\nprint(\"Data is of type:\", r[\"dtype\"])\n\n# This dataset has statistics metadata\nminv, maxv = r[\"band_metadata\"][0][1][\"STATISTICS_MINIMUM\"], r[\"band_metadata\"][0][1][\"STATISTICS_MAXIMUM\"]\nprint(\"With values from \", minv, \"to \", maxv)\n</pre>  url = \"https://data.geo.admin.ch/ch.swisstopo.swissalti3d/swissalti3d_2019_2573-1085/swissalti3d_2019_2573-1085_0.5_2056_5728.tif\"  # Fetch File Metadata to get min/max rescaling values (because the file is stored as float32) r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params = {         \"url\": url,     } ).json()  print(r) print(\"Data is of type:\", r[\"dtype\"])  # This dataset has statistics metadata minv, maxv = r[\"band_metadata\"][0][1][\"STATISTICS_MINIMUM\"], r[\"band_metadata\"][0][1][\"STATISTICS_MAXIMUM\"] print(\"With values from \", minv, \"to \", maxv)   In\u00a0[\u00a0]: Copied! <pre># We could get the min/max values using the statistics endpoint\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nprint(json.dumps(r[\"b1\"], indent=4))\n</pre> # We could get the min/max values using the statistics endpoint r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params = {         \"url\": url,     } ).json()  print(json.dumps(r[\"b1\"], indent=4)) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"] + 1\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Swisstopo\"\n).add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] + 1 )  TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Swisstopo\" ).add_to(m) m <p>Apply ColorMap</p> <p>Now that the data is rescaled to byte values (0 -&gt; 255) we can apply a colormap</p> In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n        \"rescale\": f\"{minv},{maxv}\",\n        \"colormap_name\": \"terrain\"\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"] + 1\n)\n\nTileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Swisstopo\"\n).add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,         \"rescale\": f\"{minv},{maxv}\",         \"colormap_name\": \"terrain\"     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] + 1 )  TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Swisstopo\" ).add_to(m) m <p>Apply non-linear colormap (intervals)</p> <p>see https://cogeotiff.github.io/rio-tiler/colormap/#intervals-colormaps</p> In\u00a0[\u00a0]: Copied! <pre>import json\n\ncmap = json.dumps(\n    [\n        # ([min, max], [r, g, b, a])\n        ([0, 1500], [255,255,204, 255]),\n        ([1500, 1700], [161,218,180, 255]),\n        ([1700, 1900], [65,182,196, 255]),\n        ([1900, 2000], [44,127,184, 255]),\n        ([2000, 3000], [37,52,148, 255]),\n    ]\n)\n# https://colorbrewer2.org/#type=sequential&amp;scheme=YlGnBu&amp;n=5\n\nr = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url,\n        \"colormap\": cmap\n    }\n).json()\n\nbounds = r[\"bounds\"]\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=r[\"minzoom\"] + 1\n)\n\naod_layer = TileLayer(\n    tiles=r[\"tiles\"][0],\n    opacity=1,\n    attr=\"Swisstopo\"\n)\naod_layer.add_to(m)\nm\n</pre> import json  cmap = json.dumps(     [         # ([min, max], [r, g, b, a])         ([0, 1500], [255,255,204, 255]),         ([1500, 1700], [161,218,180, 255]),         ([1700, 1900], [65,182,196, 255]),         ([1900, 2000], [44,127,184, 255]),         ([2000, 3000], [37,52,148, 255]),     ] ) # https://colorbrewer2.org/#type=sequential&amp;scheme=YlGnBu&amp;n=5  r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url,         \"colormap\": cmap     } ).json()  bounds = r[\"bounds\"] m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=r[\"minzoom\"] + 1 )  aod_layer = TileLayer(     tiles=r[\"tiles\"][0],     opacity=1,     attr=\"Swisstopo\" ) aod_layer.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#working-with-cog","title":"Working With COG\u00b6","text":"<p>For this demo we will use the new <code>DigitalGlobe OpenData</code> dataset https://www.digitalglobe.com/ecosystem/open-data</p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#requirements","title":"Requirements\u00b6","text":"<ul> <li>folium</li> <li>httpx</li> </ul> <p><code>pip install folium httpx</code></p>"},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#get-cog-info","title":"Get COG Info\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#get-cog-metadata","title":"Get COG Metadata\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#display-tiles","title":"Display Tiles\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#work-with-non-byte-data","title":"Work with non-byte data\u00b6","text":""},{"location":"examples/notebooks/Working_with_CloudOptimizedGeoTIFF_simple/#display-tiles","title":"Display Tiles\u00b6","text":"<p>Note: By default if the metadata has <code>min/max</code> statistics, titiler will use those to rescale the data</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/","title":"Working With MosaicJSON","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n#!pip install rasterio folium tqdm httpx rio-tiler geojson_pydantic cogeo-mosaic\n</pre> # Uncomment this line if you need to install the dependencies #!pip install rasterio folium tqdm httpx rio-tiler geojson_pydantic cogeo-mosaic In\u00a0[\u00a0]: Copied! <pre>import os\nimport json\nimport rasterio\nimport httpx\nfrom boto3.session import Session as boto3_session\n\nfrom concurrent import futures\nfrom rio_tiler.io import COGReader\nfrom rasterio.features import bounds as featureBounds\n\nfrom folium import Map, TileLayer, GeoJson\n</pre> import os import json import rasterio import httpx from boto3.session import Session as boto3_session  from concurrent import futures from rio_tiler.io import COGReader from rasterio.features import bounds as featureBounds  from folium import Map, TileLayer, GeoJson In\u00a0[\u00a0]: Copied! <pre># To Be able to run this notebook you'll need to have AWS credential available in the environment\n\n# import os\n# os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\"\n# os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\"\n</pre> # To Be able to run this notebook you'll need to have AWS credential available in the environment  # import os # os.environ[\"AWS_ACCESS_KEY_ID\"] = \"YOUR AWS ACCESS ID HERE\" # os.environ[\"AWS_SECRET_ACCESS_KEY\"] = \"YOUR AWS ACCESS KEY HERE\" In\u00a0[\u00a0]: Copied! <pre>session = boto3_session(region_name=\"us-west-2\")\nclient = session.client(\"s3\")\n\nbucket = \"noaa-eri-pds\"  #https://registry.opendata.aws/omi-no2-nasa/\n\n\ndef list_objects(bucket, prefix):\n    \"\"\"AWS s3 list objects.\"\"\"\n\n    paginator = client.get_paginator('list_objects_v2')\n\n    files = []\n    for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):\n        files.extend(subset.get(\"Contents\", []))\n\n    return [r[\"Key\"] for r in files]\n\nfiles = list_objects(bucket, \"2020_Nashville_Tornado/20200307a_RGB\")\nfiles = [f\"s3://{bucket}/{f}\" for f in files if f.endswith(\".tif\")]\n\nprint(f\"Number of GeoTIFF: {len(files)}\")\n</pre> session = boto3_session(region_name=\"us-west-2\") client = session.client(\"s3\")  bucket = \"noaa-eri-pds\"  #https://registry.opendata.aws/omi-no2-nasa/   def list_objects(bucket, prefix):     \"\"\"AWS s3 list objects.\"\"\"      paginator = client.get_paginator('list_objects_v2')      files = []     for subset in paginator.paginate(Bucket=bucket, Prefix=prefix):         files.extend(subset.get(\"Contents\", []))      return [r[\"Key\"] for r in files]  files = list_objects(bucket, \"2020_Nashville_Tornado/20200307a_RGB\") files = [f\"s3://{bucket}/{f}\" for f in files if f.endswith(\".tif\")]  print(f\"Number of GeoTIFF: {len(files)}\") In\u00a0[\u00a0]: Copied! <pre>print(files)\n</pre> print(files) In\u00a0[\u00a0]: Copied! <pre># We can derive the `bbox` from the filename\n# s3://noaa-eri-pds/2020_Nashville_Tornado/20200307a_RGB/20200307aC0870130w361200n.tif\n# -&gt; 20200307aC0870130w361200n.tif\n# -&gt; 20200307aC \"0870130w\" \"361200n\" .tif\n# -&gt; 0870130w -&gt; 87.025 (West)\n# -&gt; 361200n -&gt; 36.2 (Top)\n# We also know each files cover ~0.025x~0.025 degrees\n\nimport re\nfrom geojson_pydantic.features import Feature\nfrom geojson_pydantic.geometries import Polygon\n\ndef dms_to_degree(v: str) -&gt; float:\n    \"\"\"convert degree minute second to decimal degrees.\n\n    '0870130w' -&gt; 87.025\n    \"\"\"\n    deg = int(v[0:3])\n    minutes = int(v[3:5])\n    seconds = int(v[5:7])\n    direction = v[-1].upper()\n    return (float(deg) + float(minutes)/60 + float(seconds)/(60*60)) * (-1 if direction in ['W', 'S'] else 1)\n\ndef fname_to_feature(src_path: str) -&gt; Feature:\n    bname = os.path.basename(src_path)\n    lon_dms = bname[10:18]\n    lat_dms = bname[18:25]\n\n    lon = dms_to_degree(lon_dms)\n    lat = dms_to_degree(\"0\" + lat_dms)\n\n    return Feature(\n        geometry=Polygon.from_bounds(\n            lon, lat - 0.025, lon + 0.025, lat\n        ),\n        properties={\n            \"path\": src_path,\n        }\n    )\nfeatures = [\n   fname_to_feature(f).dict(exclude_none=True) for f in files\n]\n\n# OR We could use Rasterio/rio-tiler\n\n# def worker(src_path: str) -&gt; Feature:\n#     try:\n#         with COGReader(src_path) as cog:\n#             wgs_bounds = cog.geographic_bounds\n#     except:\n#         return {}\n#\n#     return Feature(\n#         geometry=Polygon.from_bounds(*wgs_bounds),\n#         properties={\n#             \"path\": src_path,\n#         }\n#     )\n#\n# with futures.ThreadPoolExecutor(max_workers=20) as executor:\n#     features = [r.dict(exclude_none=True) for r in executor.map(worker, files) if r]\n</pre> # We can derive the `bbox` from the filename # s3://noaa-eri-pds/2020_Nashville_Tornado/20200307a_RGB/20200307aC0870130w361200n.tif # -&gt; 20200307aC0870130w361200n.tif # -&gt; 20200307aC \"0870130w\" \"361200n\" .tif # -&gt; 0870130w -&gt; 87.025 (West) # -&gt; 361200n -&gt; 36.2 (Top) # We also know each files cover ~0.025x~0.025 degrees  import re from geojson_pydantic.features import Feature from geojson_pydantic.geometries import Polygon  def dms_to_degree(v: str) -&gt; float:     \"\"\"convert degree minute second to decimal degrees.      '0870130w' -&gt; 87.025     \"\"\"     deg = int(v[0:3])     minutes = int(v[3:5])     seconds = int(v[5:7])     direction = v[-1].upper()     return (float(deg) + float(minutes)/60 + float(seconds)/(60*60)) * (-1 if direction in ['W', 'S'] else 1)  def fname_to_feature(src_path: str) -&gt; Feature:     bname = os.path.basename(src_path)     lon_dms = bname[10:18]     lat_dms = bname[18:25]      lon = dms_to_degree(lon_dms)     lat = dms_to_degree(\"0\" + lat_dms)      return Feature(         geometry=Polygon.from_bounds(             lon, lat - 0.025, lon + 0.025, lat         ),         properties={             \"path\": src_path,         }     ) features = [    fname_to_feature(f).dict(exclude_none=True) for f in files ]  # OR We could use Rasterio/rio-tiler  # def worker(src_path: str) -&gt; Feature: #     try: #         with COGReader(src_path) as cog: #             wgs_bounds = cog.geographic_bounds #     except: #         return {} # #     return Feature( #         geometry=Polygon.from_bounds(*wgs_bounds), #         properties={ #             \"path\": src_path, #         } #     ) # # with futures.ThreadPoolExecutor(max_workers=20) as executor: #     features = [r.dict(exclude_none=True) for r in executor.map(worker, files) if r] In\u00a0[\u00a0]: Copied! <pre>geojson = {'type': 'FeatureCollection', 'features': features}\n\nbounds = featureBounds(geojson)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=6\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\nm\n</pre> geojson = {'type': 'FeatureCollection', 'features': features}  bounds = featureBounds(geojson)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=6 )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>from rio_tiler.io import COGReader\nfrom cogeo_mosaic.mosaic import MosaicJSON\nfrom cogeo_mosaic.backends import MosaicBackend\n\nwith COGReader(files[0]) as cog:\n    info = cog.info()\n    print(info.minzoom)\n    print(info.maxzoom)\n</pre> from rio_tiler.io import COGReader from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend  with COGReader(files[0]) as cog:     info = cog.info()     print(info.minzoom)     print(info.maxzoom) In\u00a0[\u00a0]: Copied! <pre># We are creating the mosaicJSON using the features we created earlier\n# by default MosaicJSON.from_feature will look in feature.properties.path to get the path of the dataset\nmosaicdata = MosaicJSON.from_features(features, minzoom=info.minzoom, maxzoom=info.maxzoom)\nwith MosaicBackend(\"NOAA_Nashville_Tornado.json.gz\", mosaic_def=mosaicdata) as mosaic:\n    mosaic.write(overwrite=True)\n    print(mosaic.info())\n</pre>  # We are creating the mosaicJSON using the features we created earlier # by default MosaicJSON.from_feature will look in feature.properties.path to get the path of the dataset mosaicdata = MosaicJSON.from_features(features, minzoom=info.minzoom, maxzoom=info.maxzoom) with MosaicBackend(\"NOAA_Nashville_Tornado.json.gz\", mosaic_def=mosaicdata) as mosaic:     mosaic.write(overwrite=True)     print(mosaic.info()) In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\n\nr = httpx.get(\n    f\"{titiler_endpoint}/mosaicjson/WebMercatorQuad/tilejson.json\",\n    params={\n        # For this demo we are use the same mosaic but stored on the web\n        \"url\": \"https://gist.githubusercontent.com/vincentsarago/c6ace3ccd29a82a4a5531693bbcd61fc/raw/e0d0174a64a9acd2fb820f2c65b1830aab80f52b/NOAA_Nashville_Tornado.json\"\n    }\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=13\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"NOAA\"\n)\n\ngeo_json = GeoJson(\n    data=geojson,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ntiles.add_to(m)\ngeo_json.add_to(m)\nm\n</pre> titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.  r = httpx.get(     f\"{titiler_endpoint}/mosaicjson/WebMercatorQuad/tilejson.json\",     params={         # For this demo we are use the same mosaic but stored on the web         \"url\": \"https://gist.githubusercontent.com/vincentsarago/c6ace3ccd29a82a4a5531693bbcd61fc/raw/e0d0174a64a9acd2fb820f2c65b1830aab80f52b/NOAA_Nashville_Tornado.json\"     } ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=13 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"NOAA\" )  geo_json = GeoJson(     data=geojson,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) tiles.add_to(m) geo_json.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#working-with-mosaicjson","title":"Working With MosaicJSON\u00b6","text":""},{"location":"examples/notebooks/Working_with_MosaicJSON/#mosaicjson","title":"MosaicJSON\u00b6","text":"<p>MosaicJSON is a specification created by DevelopmentSeed which aims to be an open standard for representing metadata about a mosaic of Cloud-Optimized GeoTIFF (COG) files.</p> <p>MosaicJSON can be seen as a Virtual raster (see GDAL's VRT) enabling spatial and temporal processing for a list of Cloud-Optimized GeoTIFF.</p> <p>Ref:https://github.com/developmentseed/mosaicjson-spec</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#data","title":"Data\u00b6","text":"<p>For this demo, we are going to use CloudOptimized GeoTIFF from NOAA/Emergency Response Imagery: https://registry.opendata.aws/noaa-eri/</p> <p>Requirement: AWS credentials</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#endpoint","title":"Endpoint\u00b6","text":"<p>By default, TiTiler has <code>mosaicjson</code> endpoints.</p> <p>Docs: https://titiler.xyz/api.html#/MosaicJSON</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rasterio</li> <li>folium</li> <li>httpx</li> <li>tqdm</li> <li>rio-tiler</li> <li>cogeo-mosaic</li> <li>boto3</li> <li>geojson_pydantic</li> </ul> <p><code>pip install rasterio folium tqdm httpx rio-tiler geojson_pydantic cogeo-mosaic</code></p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#get-the-data","title":"Get the Data\u00b6","text":""},{"location":"examples/notebooks/Working_with_MosaicJSON/#1-fetch-and-parse-page","title":"1. Fetch and parse page\u00b6","text":""},{"location":"examples/notebooks/Working_with_MosaicJSON/#2-create-features-and-viz-optional","title":"2. Create Features and Viz (Optional)\u00b6","text":"<p>Read each file geo metadata</p>"},{"location":"examples/notebooks/Working_with_MosaicJSON/#5-create-mosaic","title":"5. Create Mosaic\u00b6","text":""},{"location":"examples/notebooks/Working_with_NumpyTile/","title":"NumpyTile","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install numpy mercantile\n</pre> # Uncomment this line if you need to install the dependencies # !pip install numpy mercantile In\u00a0[\u00a0]: Copied! <pre>import httpx\nimport mercantile\nfrom io import BytesIO\nimport numpy\n\n%pylab inline\n</pre> import httpx import mercantile from io import BytesIO import numpy  %pylab inline In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\nurl = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n</pre> titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\" In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json?url={url}\").json()\nprint(r)\n</pre> r = httpx.get(f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json?url={url}\").json() print(r) In\u00a0[\u00a0]: Copied! <pre># Get a list of tiles for minzoom + 2\n\ntiles = list(mercantile.tiles(*r[\"bounds\"], r[\"minzoom\"] + 2))\n</pre> # Get a list of tiles for minzoom + 2  tiles = list(mercantile.tiles(*r[\"bounds\"], r[\"minzoom\"] + 2)) In\u00a0[\u00a0]: Copied! <pre># Call TiTiler endpoint using the first tile\n\ntile = tiles[0]\nr = httpx.get(f\"{titiler_endpoint}/cog/tiles/WebMercatorQuad/{tile.z}/{tile.x}/{tile.y}.npy?url={url}\")\n</pre> # Call TiTiler endpoint using the first tile  tile = tiles[0] r = httpx.get(f\"{titiler_endpoint}/cog/tiles/WebMercatorQuad/{tile.z}/{tile.x}/{tile.y}.npy?url={url}\") In\u00a0[\u00a0]: Copied! <pre># Load result using numpy.load\n\narr = numpy.load(BytesIO(r.content))\nprint(type(arr))\nprint(arr.shape)\n</pre> # Load result using numpy.load  arr = numpy.load(BytesIO(r.content)) print(type(arr)) print(arr.shape) In\u00a0[\u00a0]: Copied! <pre># By default we put the data and the mask in the same array\ntile, mask = arr[0:-1], arr[-1]\n</pre> # By default we put the data and the mask in the same array tile, mask = arr[0:-1], arr[-1] In\u00a0[\u00a0]: Copied! <pre>print(tile.shape)\n</pre> print(tile.shape) In\u00a0[\u00a0]: Copied! <pre>print(mask.shape)\n</pre> print(mask.shape) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_NumpyTile/#numpytile","title":"NumpyTile\u00b6","text":"<p>Specification: https://github.com/planetlabs/numpytiles-spec</p>"},{"location":"examples/notebooks/Working_with_NumpyTile/#requirements","title":"Requirements\u00b6","text":"<ul> <li>mercantile</li> <li>numpy</li> </ul> <p><code>!pip install numpy mercantile</code></p>"},{"location":"examples/notebooks/Working_with_STAC/","title":"Working With STAC - At Scale","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip rasterio folium httpx tqdm\n</pre> # Uncomment this line if you need to install the dependencies # !pip rasterio folium httpx tqdm In\u00a0[\u00a0]: Copied! <pre>import os\nimport json\nimport base64\nimport httpx\nimport datetime\nimport itertools\nimport urllib.parse\n\nfrom io import BytesIO\nfrom functools import partial\nfrom concurrent import futures\n\nfrom tqdm.notebook import tqdm\n\nfrom rasterio.plot import reshape_as_image\nfrom rasterio.features import bounds as featureBounds\n\nfrom folium import Map, TileLayer, GeoJson\n\n%pylab inline\n</pre> import os import json import base64 import httpx import datetime import itertools import urllib.parse  from io import BytesIO from functools import partial from concurrent import futures  from tqdm.notebook import tqdm  from rasterio.plot import reshape_as_image from rasterio.features import bounds as featureBounds  from folium import Map, TileLayer, GeoJson  %pylab inline In\u00a0[\u00a0]: Copied! <pre># Endpoint variables\ntitiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\nstac_endpoint = \"https://earth-search.aws.element84.com/v0/search\"\n</pre> # Endpoint variables titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. stac_endpoint = \"https://earth-search.aws.element84.com/v0/search\" In\u00a0[\u00a0]: Copied! <pre>geojson = {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              30.810813903808594,\n              29.454247067148533\n            ],\n            [\n              30.88600158691406,\n              29.454247067148533\n            ],\n            [\n              30.88600158691406,\n              29.51879923863822\n            ],\n            [\n              30.810813903808594,\n              29.51879923863822\n            ],\n            [\n              30.810813903808594,\n              29.454247067148533\n            ]\n          ]\n        ]\n      }\n    }\n  ]\n}\n\nbounds = featureBounds(geojson)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=11\n)\n\ngeo_json = GeoJson(data=geojson)\ngeo_json.add_to(m)\nm\n</pre> geojson = {   \"type\": \"FeatureCollection\",   \"features\": [     {       \"type\": \"Feature\",       \"properties\": {},       \"geometry\": {         \"type\": \"Polygon\",         \"coordinates\": [           [             [               30.810813903808594,               29.454247067148533             ],             [               30.88600158691406,               29.454247067148533             ],             [               30.88600158691406,               29.51879923863822             ],             [               30.810813903808594,               29.51879923863822             ],             [               30.810813903808594,               29.454247067148533             ]           ]         ]       }     }   ] }  bounds = featureBounds(geojson)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=11 )  geo_json = GeoJson(data=geojson) geo_json.add_to(m) m <ol> <li>Define dates and other filters</li> </ol> In\u00a0[\u00a0]: Copied! <pre>start = datetime.datetime.strptime(\"2019-01-01\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\")\nend = datetime.datetime.strptime(\"2019-12-11\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")\n\n# POST body\nquery = {\n    \"collections\": [\"sentinel-s2-l2a-cogs\"],\n    \"datetime\": f\"{start}/{end}\",\n    \"query\": {\n        \"eo:cloud_cover\": {\n            \"lt\": 5\n        },\n    },\n    \"intersects\": geojson[\"features\"][0][\"geometry\"],\n    \"limit\": 100,\n    \"fields\": {\n      'include': ['id', 'properties.datetime', 'properties.eo:cloud_cover'],  # This will limit the size of returned body\n      'exclude': ['assets', 'links']  # This will limit the size of returned body\n    }\n}\n\n# POST Headers\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Accept-Encoding\": \"gzip\",\n    \"Accept\": \"application/geo+json\",\n}\n\ndata = httpx.post(stac_endpoint, headers=headers, json=query).json()\nprint(\"Results context:\")\nprint(data[\"context\"])\nprint()\nprint(\"Example of item:\")\nprint(json.dumps(data[\"features\"][0], indent=4))\n\nsceneid = [f[\"id\"] for f in data[\"features\"]]\ncloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]]\ndates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]]\n</pre> start = datetime.datetime.strptime(\"2019-01-01\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT00:00:00Z\") end = datetime.datetime.strptime(\"2019-12-11\", \"%Y-%m-%d\").strftime(\"%Y-%m-%dT23:59:59Z\")  # POST body query = {     \"collections\": [\"sentinel-s2-l2a-cogs\"],     \"datetime\": f\"{start}/{end}\",     \"query\": {         \"eo:cloud_cover\": {             \"lt\": 5         },     },     \"intersects\": geojson[\"features\"][0][\"geometry\"],     \"limit\": 100,     \"fields\": {       'include': ['id', 'properties.datetime', 'properties.eo:cloud_cover'],  # This will limit the size of returned body       'exclude': ['assets', 'links']  # This will limit the size of returned body     } }  # POST Headers headers = {     \"Content-Type\": \"application/json\",     \"Accept-Encoding\": \"gzip\",     \"Accept\": \"application/geo+json\", }  data = httpx.post(stac_endpoint, headers=headers, json=query).json() print(\"Results context:\") print(data[\"context\"]) print() print(\"Example of item:\") print(json.dumps(data[\"features\"][0], indent=4))  sceneid = [f[\"id\"] for f in data[\"features\"]] cloudcover = [f[\"properties\"][\"eo:cloud_cover\"] for f in data[\"features\"]] dates = [f[\"properties\"][\"datetime\"][0:10] for f in data[\"features\"]] In\u00a0[\u00a0]: Copied! <pre>m = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=8\n)\n\ngeo_json = GeoJson(\n    data=data,\n    style_function=lambda x: {\n        'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1\n    },\n)\ngeo_json.add_to(m)\nm\n</pre> m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=8 )  geo_json = GeoJson(     data=data,     style_function=lambda x: {         'opacity': 1, 'dashArray': '1', 'fillOpacity': 0, 'weight': 1     }, ) geo_json.add_to(m) m <p>Plot Date / Cloud Cover</p> In\u00a0[\u00a0]: Copied! <pre>fig = plt.figure(dpi=100)\nfig.autofmt_xdate()\nax = fig.add_subplot(1, 1, 1)\nax.plot(dates, cloudcover, label=\"Cloud Cover\", color=\"tab:red\", linewidth=0.4, linestyle=\"-.\")\n\nax.legend()\n</pre> fig = plt.figure(dpi=100) fig.autofmt_xdate() ax = fig.add_subplot(1, 1, 1) ax.plot(dates, cloudcover, label=\"Cloud Cover\", color=\"tab:red\", linewidth=0.4, linestyle=\"-.\")  ax.legend() In\u00a0[\u00a0]: Copied! <pre>url_template = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{id}\"\n</pre> url_template = \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{id}\" In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nitem =  url_template.format(id=sceneid[-1])\nprint(item)\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = (\n        (\"url\", item),\n        # Simple RGB combination (True Color)\n        (\"assets\", \"B04\"),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\"assets\", \"B03\"),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\"assets\", \"B02\"),  # blue, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\"color_formula\", \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"),  # We use a rio-color formula to make the tiles look nice\n        (\"minzoom\", 8),  # By default titiler will use 0\n        (\"maxzoom\", 14), # By default titiler will use 24\n    )\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"Digital Earth Africa\"\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL item =  url_template.format(id=sceneid[-1]) print(item) r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = (         (\"url\", item),         # Simple RGB combination (True Color)         (\"assets\", \"B04\"),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (\"assets\", \"B03\"),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (\"assets\", \"B02\"),  # blue, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (\"color_formula\", \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"),  # We use a rio-color formula to make the tiles look nice         (\"minzoom\", 8),  # By default titiler will use 0         (\"maxzoom\", 14), # By default titiler will use 24     ) ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"Digital Earth Africa\" ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = (\n        (\"url\", url_template.format(id=sceneid[0])),\n        # False Color Infrared\n        (\"assets\", \"B08\"),  # nir, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\"assets\", \"B04\"),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\"assets\", \"B03\"),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        (\"color_formula\", \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"),  # We use a rio-color formula to make the tiles look nice\n        (\"minzoom\", 8),  # By default titiler will use 0\n        (\"maxzoom\", 14), # By default titiler will use 24\n    )\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"Digital Earth Africa\"\n)\ntiles.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = (         (\"url\", url_template.format(id=sceneid[0])),         # False Color Infrared         (\"assets\", \"B08\"),  # nir, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (\"assets\", \"B04\"),  # red, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (\"assets\", \"B03\"),  # green, in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         (\"color_formula\", \"Gamma RGB 3.5 Saturation 1.7 Sigmoidal RGB 15 0.35\"),  # We use a rio-color formula to make the tiles look nice         (\"minzoom\", 8),  # By default titiler will use 0         (\"maxzoom\", 14), # By default titiler will use 24     ) ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"Digital Earth Africa\" ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": url_template.format(id=sceneid[0]),\n        \"expression\": \"(B08-B04)/(B08+B04)\",  # NDVI (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n        # We need to tell rio-tiler that each asset is a Band\n        # (so it will select the first band within each asset automatically)\n        \"asset_as_band\": True,\n        \"rescale\": \"-1,1\",\n        \"minzoom\": 8,  # By default titiler will use 0\n        \"maxzoom\": 14, # By default titiler will use 24\n        \"colormap_name\": \"viridis\",\n    }\n).json()\nprint(r)\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"Digital Earth Africa\"\n)\ntiles.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = {         \"url\": url_template.format(id=sceneid[0]),         \"expression\": \"(B08-B04)/(B08+B04)\",  # NDVI (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)         # We need to tell rio-tiler that each asset is a Band         # (so it will select the first band within each asset automatically)         \"asset_as_band\": True,         \"rescale\": \"-1,1\",         \"minzoom\": 8,  # By default titiler will use 0         \"maxzoom\": 14, # By default titiler will use 24         \"colormap_name\": \"viridis\",     } ).json() print(r)  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"Digital Earth Africa\" ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>def fetch_bbox_array(sceneid, bbox, assets = None, expression = None, **kwargs):\n    \"\"\"Helper function to fetch and decode Numpy array using Titiler endpoint.\"\"\"\n    # STAC ITEM URL\n    stac_item = f\"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\"\n\n    xmin, ymin, xmax, ymax = bbox\n\n    # TiTiler required URL + asset or expression parameters\n    params = ((\"url\", stac_item), (\"max_size\", 1024))\n    if assets:\n        for asset in assets:\n            params += ((\"assets\", asset), )\n    elif expression:\n        params += ((\"expression\", expression), (\"asset_as_band\", True),)\n    else:\n        raise Exception(\"Missing band or expression input\")\n\n    params += tuple(kwargs.items())\n\n    # TITILER ENDPOINT\n    url = f\"{titiler_endpoint}/stac/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"\n    r = httpx.get(url, params=params)\n    data = numpy.load(BytesIO(r.content))\n\n    return sceneid, data[0:-1], data[-1]\n\ndef _filter_futures(tasks):\n    for future in tasks:\n        try:\n            yield future.result()\n        except Exception:\n            pass\n\ndef _stats(data, mask):\n    arr = numpy.ma.array(data)\n    arr.mask = mask == 0\n    return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item()\n</pre> def fetch_bbox_array(sceneid, bbox, assets = None, expression = None, **kwargs):     \"\"\"Helper function to fetch and decode Numpy array using Titiler endpoint.\"\"\"     # STAC ITEM URL     stac_item = f\"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/{sceneid}\"      xmin, ymin, xmax, ymax = bbox      # TiTiler required URL + asset or expression parameters     params = ((\"url\", stac_item), (\"max_size\", 1024))     if assets:         for asset in assets:             params += ((\"assets\", asset), )     elif expression:         params += ((\"expression\", expression), (\"asset_as_band\", True),)     else:         raise Exception(\"Missing band or expression input\")      params += tuple(kwargs.items())      # TITILER ENDPOINT     url = f\"{titiler_endpoint}/stac/bbox/{xmin},{ymin},{xmax},{ymax}.npy\"     r = httpx.get(url, params=params)     data = numpy.load(BytesIO(r.content))      return sceneid, data[0:-1], data[-1]  def _filter_futures(tasks):     for future in tasks:         try:             yield future.result()         except Exception:             pass  def _stats(data, mask):     arr = numpy.ma.array(data)     arr.mask = mask == 0     return arr.min().item(), arr.max().item(), arr.mean().item(), arr.std().item() In\u00a0[\u00a0]: Copied! <pre># Fetch one data\n_, data, mask = fetch_bbox_array(sceneid[0], bounds, assets=[\"B02\"], width=128, height=128)\n\nprint(data.shape)\nprint(mask.shape)\n\nimshow(data[0])\n</pre> # Fetch one data _, data, mask = fetch_bbox_array(sceneid[0], bounds, assets=[\"B02\"], width=128, height=128)  print(data.shape) print(mask.shape)  imshow(data[0]) In\u00a0[\u00a0]: Copied! <pre># Let's fetch the data over our AOI for all our Items\n# Here we use `futures.ThreadPoolExecutor` to run the requests in parallel\n# Note: it takes more time for the notebook to display the results than to fetch the data\n\nbbox_worker = partial(\n    fetch_bbox_array,\n    bbox=bounds,\n    assets=(\"B04\", \"B03\", \"B02\"),  #(\"red\", \"green\", \"blue\"), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n    color_formula=\"gamma RGB 3.5, saturation 1.7, sigmoidal RGB 15 0.35\",\n    width=64,\n    height=64,\n)\n\nwith futures.ThreadPoolExecutor(max_workers=10) as executor:\n    future_work = [\n        executor.submit(bbox_worker, scene) for scene in sceneid\n    ]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nresults_rgb  = list(_filter_futures(future_work))\n\nprint(\"diplay all results\")\n\nfig = plt.figure(figsize=(10,20))\ncol = 5\nrow = math.ceil(len(dates) / col)\nfor i in range(1, len(results_rgb) + 1):\n    fig.add_subplot(row, col, i)\n    plt.imshow(reshape_as_image(results_rgb[i-1][1]))\n</pre> # Let's fetch the data over our AOI for all our Items # Here we use `futures.ThreadPoolExecutor` to run the requests in parallel # Note: it takes more time for the notebook to display the results than to fetch the data  bbox_worker = partial(     fetch_bbox_array,     bbox=bounds,     assets=(\"B04\", \"B03\", \"B02\"),  #(\"red\", \"green\", \"blue\"), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)     color_formula=\"gamma RGB 3.5, saturation 1.7, sigmoidal RGB 15 0.35\",     width=64,     height=64, )  with futures.ThreadPoolExecutor(max_workers=10) as executor:     future_work = [         executor.submit(bbox_worker, scene) for scene in sceneid     ]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  results_rgb  = list(_filter_futures(future_work))  print(\"diplay all results\")  fig = plt.figure(figsize=(10,20)) col = 5 row = math.ceil(len(dates) / col) for i in range(1, len(results_rgb) + 1):     fig.add_subplot(row, col, i)     plt.imshow(reshape_as_image(results_rgb[i-1][1])) In\u00a0[\u00a0]: Copied! <pre>## Fetch NDVI\n\nbbox_worker = partial(\n    fetch_bbox_array,\n    bbox=bounds,\n    expression=\"(B08-B04)/(B08+B04)\",  # (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)\n    width=64,\n    height=64,\n)\n\nwith futures.ThreadPoolExecutor(max_workers=10) as executor:\n    future_work = [\n        executor.submit(bbox_worker, scene) for scene in sceneid\n    ]\n\n    for f in tqdm(futures.as_completed(future_work), total=len(future_work)):\n        pass\n\nresults_ndvi  = list(_filter_futures(future_work))\n\nfig = plt.figure(figsize=(10,20))\ncol = 5\nrow = math.ceil(len(dates) / col)\nfor i in range(1, len(results_rgb) + 1):\n    fig.add_subplot(row, col, i)\n    plt.imshow(results_ndvi[i-1][1][0])\n</pre> ## Fetch NDVI  bbox_worker = partial(     fetch_bbox_array,     bbox=bounds,     expression=\"(B08-B04)/(B08+B04)\",  # (nir-red)/(nir+red), in next STAC item version (see https://github.com/cogeotiff/rio-tiler-pds/issues/63)     width=64,     height=64, )  with futures.ThreadPoolExecutor(max_workers=10) as executor:     future_work = [         executor.submit(bbox_worker, scene) for scene in sceneid     ]      for f in tqdm(futures.as_completed(future_work), total=len(future_work)):         pass  results_ndvi  = list(_filter_futures(future_work))  fig = plt.figure(figsize=(10,20)) col = 5 row = math.ceil(len(dates) / col) for i in range(1, len(results_rgb) + 1):     fig.add_subplot(row, col, i)     plt.imshow(results_ndvi[i-1][1][0]) In\u00a0[\u00a0]: Copied! <pre>stats = [_stats(data, mask) for _, data, mask in results_ndvi]\n\nfig, ax1 = plt.subplots(dpi=150)\nfig.autofmt_xdate()\n\nax1.plot(dates, [s[0] for s in stats], label=\"Min\")\nax1.plot(dates, [s[1] for s in stats], label=\"Max\")\nax1.plot(dates, [s[2] for s in stats], label=\"Mean\")\nax1.set_xlabel(\"Dates\")\nax1.set_ylabel(\"Normalized Difference Vegetation Index\")\n\nax1.legend()\n</pre> stats = [_stats(data, mask) for _, data, mask in results_ndvi]  fig, ax1 = plt.subplots(dpi=150) fig.autofmt_xdate()  ax1.plot(dates, [s[0] for s in stats], label=\"Min\") ax1.plot(dates, [s[1] for s in stats], label=\"Max\") ax1.plot(dates, [s[2] for s in stats], label=\"Mean\") ax1.set_xlabel(\"Dates\") ax1.set_ylabel(\"Normalized Difference Vegetation Index\")  ax1.legend() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_STAC/#working-with-stac-at-scale","title":"Working With STAC - At Scale\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC/#stac-spatiotemporal-asset-catalog","title":"STAC: SpatioTemporal Asset Catalog\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification aims to standardize the way geospatial assets are exposed online and queried. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc.</p> <p>Ref: https://github.com/radiantearth/stac-spechttps://github.com/radiantearth/stac-spec</p> <p>Using STAC makes data indexation and discovery really easy. In addition to the Collection/Item/Asset (data) specifications, data providers are also encouraged to follow a STAC API specification:  https://github.com/radiantearth/stac-api-spec</p> <p>The API is compliant with the OGC API - Features standard (formerly known as OGC Web Feature Service 3), in that it defines many of the endpoints that STAC uses. A STAC API should be compatible and usable with any OGC API - Features clients. The STAC API can be thought of as a specialized Features API to search STAC Catalogs, where the features returned are STAC Items, that have common properties, links to their assets and geometries that represent the footprints of the geospatial assets.</p>"},{"location":"examples/notebooks/Working_with_STAC/#sentinel-2","title":"Sentinel 2\u00b6","text":"<p>Thanks to Digital Earth Africa and in collaboration with Sinergise, Element 84, Amazon Web Services (AWS) and the Committee on Earth Observation Satellites (CEOS), Sentinel 2 (Level 2) data over Africa, usually stored as JPEG2000, has been translated to COG more important a STAC database and API has been setup.</p> <p>https://www.digitalearthafrica.org/news/operational-and-ready-use-satellite-data-now-available-across-africa</p> <p>The API is provided by @element84 and follows the latest specification: https://earth-search.aws.element84.com/v0</p>"},{"location":"examples/notebooks/Working_with_STAC/#titiler-stac-cog","title":"TiTiler: STAC + COG\u00b6","text":"<p>Docs: https://github.com/developmentseed/titiler/blob/main/docs/endpoints/stac.md</p> <p>TiTiler was first designed to work with single COG by passing the file URL to the tiler. e.g : <code>https://myendpoint/cog/tiles/1/2/3?url=https://somewhere.com/mycog.tif</code></p> <p>With STAC is a bit different because we first have to read the STAC items and then know which assets to read.</p> <p>Example of STAC Item</p> <pre><code>{\n    \"type\": \"Feature\",\n    \"id\": \"S2A_34SGA_20200318_0_L2A\",\n\n    \"geometry\": {...},\n    \"properties\": {\n        \"datetime\": \"2020-03-18T09:11:33Z\",\n        ...\n    },\n    \"collection\": \"sentinel-s2-l2a-cogs\",\n    \"assets\": {\n        \"thumbnail\": {\n            \"title\": \"Thumbnail\",\n            \"type\": \"image/png\",\n            \"href\": \"https://myurl.com/preview.jpg\"\n        },\n        ...\n        \"B03\": {\n            \"title\": \"Band 3 (green)\",\n            \"type\": \"image/tiff; application=geotiff; profile=cloud-optimized\",\n            \"href\": \"https://myurl.com/B03.tif\",\n            \"proj:shape\": [\n                10980,\n                10980\n            ],\n            \"proj:transform\": [\n                10,\n                0,\n                699960,\n                0,\n                -10,\n                3600000,\n                0,-*\n                0,\n                1\n            ]\n        },\n        ...\n    },\n    \"links\": [...]\n}\n</code></pre> <p>To be able to create Web Map tile from the <code>B03</code> asset you'll need to pass the STAC Item url and the asset name:</p> <p><code>https://myendpoint/stac/tiles/1/2/3?url=https://somewhere.com/item.json&amp;assets=B03</code></p>"},{"location":"examples/notebooks/Working_with_STAC/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>rasterio</li> <li>folium</li> <li>httpx</li> <li>tqdm</li> </ul> <p><code>!pip install rasterio folium httpx tqdm</code></p>"},{"location":"examples/notebooks/Working_with_STAC/#search-for-stac-items","title":"Search for STAC Items\u00b6","text":"<p>See https://github.com/radiantearth/stac-api-spec for more documentation about the stac API</p> <ol> <li>AOI</li> </ol> <p>You can use geojson.io to define your search AOI</p>"},{"location":"examples/notebooks/Working_with_STAC/#use-titiler-endpoint","title":"Use Titiler endpoint\u00b6","text":"<p>https://titiler.xyz/api.html#/SpatioTemporal%20Asset%20Catalog</p> <p><code>{endpoint}/stac/tiles/{tileMatrixSetId}/{z}/{x}/{y}.{format}?url={stac_item}&amp;{otherquery params}</code></p> <p><code>{endpoint}/stac/bbox/{minx},{miny},{maxx},{maxy}.{format}?url={stac_item}&amp;{otherquery params}</code></p> <p><code>{endpoint}/stac/point/{minx},{miny}?url={stac_item}&amp;{otherquery params}</code></p>"},{"location":"examples/notebooks/Working_with_STAC/#visualize-one-item","title":"Visualize One Item\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC/#more","title":"More\u00b6","text":"<p>titiler doesn't return only png or jpeg but can also return Numpy array directly</p>"},{"location":"examples/notebooks/Working_with_STAC_simple/","title":"Working With STAC","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment this line if you need to install the dependencies\n# !pip install folium requests rasterio\n</pre> # Uncomment this line if you need to install the dependencies # !pip install folium requests rasterio In\u00a0[\u00a0]: Copied! <pre>import httpx\n\nfrom rasterio.features import bounds as featureBounds\n\nfrom folium import Map, TileLayer, GeoJson\n\n%pylab inline\n</pre> import httpx  from rasterio.features import bounds as featureBounds  from folium import Map, TileLayer, GeoJson  %pylab inline In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\nstac_item = \"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_30TVT_20221112_0_L2A\"\n</pre> titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. stac_item = \"https://earth-search.aws.element84.com/v1/collections/sentinel-2-l2a/items/S2A_30TVT_20221112_0_L2A\" In\u00a0[\u00a0]: Copied! <pre>item = httpx.get(stac_item).json()\nprint(item)\n</pre> item = httpx.get(stac_item).json() print(item) In\u00a0[\u00a0]: Copied! <pre>for it, asset in item[\"assets\"].items():\n    print(\"Name:\", it, \"| Format:\", asset[\"type\"])\n</pre> for it, asset in item[\"assets\"].items():     print(\"Name:\", it, \"| Format:\", asset[\"type\"]) In\u00a0[\u00a0]: Copied! <pre>bounds = featureBounds(item)\n\nm = Map(\n    tiles=\"OpenStreetMap\",\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=8\n)\n\ngeo_json = GeoJson(data=item)\ngeo_json.add_to(m)\nm\n</pre> bounds = featureBounds(item)  m = Map(     tiles=\"OpenStreetMap\",     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=8 )  geo_json = GeoJson(data=item) geo_json.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/info\",\n    params = (\n        (\"url\", stac_item),\n        # Get info for multiple assets\n        (\"assets\",\"visual\"), (\"assets\",\"red\"), (\"assets\",\"blue\"), (\"assets\",\"green\"),\n    )\n).json()\nprint(r)\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/info\",     params = (         (\"url\", stac_item),         # Get info for multiple assets         (\"assets\",\"visual\"), (\"assets\",\"red\"), (\"assets\",\"blue\"), (\"assets\",\"green\"),     ) ).json() print(r) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": stac_item,\n        \"assets\": \"visual\",\n        \"minzoom\": 8,  # By default titiler will use 0\n        \"maxzoom\": 14, # By default titiler will use 24\n    }\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\"\n)\ntiles.add_to(m)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = {         \"url\": stac_item,         \"assets\": \"visual\",         \"minzoom\": 8,  # By default titiler will use 0         \"maxzoom\": 14, # By default titiler will use 24     } ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\" ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = {\n        \"url\": stac_item,\n        \"assets\": \"visual\",\n        \"asset_bidx\": \"visual|3,1,2\",\n        \"minzoom\": 8,  # By default titiler will use 0\n        \"maxzoom\": 14, # By default titiler will use 24\n    }\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=12\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\"\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = {         \"url\": stac_item,         \"assets\": \"visual\",         \"asset_bidx\": \"visual|3,1,2\",         \"minzoom\": 8,  # By default titiler will use 0         \"maxzoom\": 14, # By default titiler will use 24     } ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=12 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\" ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = (\n        (\"url\", stac_item),\n        (\"assets\", \"red\"),\n        (\"assets\", \"green\"),\n        (\"assets\", \"blue\"),\n        # Most of the Sentinel L2A Assets have only one band\n        # So we don't have to pass the bidx\n        # (\"assets_bidx\", \"red|1\"),\n        # (\"assets_bidx\", \"green|1\"),\n        # (\"assets_bidx\", \"blue|\"),\n        (\"minzoom\", 8),\n        (\"maxzoom\", 14),\n        (\"rescale\", \"0,2000\"),\n    )\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=11\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\"\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = (         (\"url\", stac_item),         (\"assets\", \"red\"),         (\"assets\", \"green\"),         (\"assets\", \"blue\"),         # Most of the Sentinel L2A Assets have only one band         # So we don't have to pass the bidx         # (\"assets_bidx\", \"red|1\"),         # (\"assets_bidx\", \"green|1\"),         # (\"assets_bidx\", \"blue|\"),         (\"minzoom\", 8),         (\"maxzoom\", 14),         (\"rescale\", \"0,2000\"),     ) ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=11 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\" ) tiles.add_to(m) m <p>Use an expression to calculate a band index (NDVI) based on information contained in multiple assets.</p> In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = (\n        (\"url\", stac_item),\n        (\"expression\", \"(nir-red)/(nir+red)\"),  # NDVI\n        # We need to tell rio-tiler that each asset is a Band\n        # (so it will select the first band within each asset automatically)\n        (\"asset_as_band\", True),\n        (\"rescale\", \"-1,1\"),\n        (\"minzoom\", 8),\n        (\"maxzoom\", 14),\n        (\"colormap_name\", \"viridis\"),\n    )\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\"\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = (         (\"url\", stac_item),         (\"expression\", \"(nir-red)/(nir+red)\"),  # NDVI         # We need to tell rio-tiler that each asset is a Band         # (so it will select the first band within each asset automatically)         (\"asset_as_band\", True),         (\"rescale\", \"-1,1\"),         (\"minzoom\", 8),         (\"maxzoom\", 14),         (\"colormap_name\", \"viridis\"),     ) ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\" ) tiles.add_to(m) m <p>If you don't use the  <code>asset_as_band=True</code> option, you need to append the band to the asset name within the expression. For example, <code>nir</code> becomes <code>nir_b1</code>.</p> In\u00a0[\u00a0]: Copied! <pre># Get Tile URL\nr = httpx.get(\n    f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",\n    params = (\n        (\"url\", stac_item),\n        (\"expression\", \"(nir_b1-red_b1)/(nir_b1+red_b1)\"),  # NDVI\n        (\"rescale\", \"-1,1\"),\n        (\"minzoom\", 8),\n        (\"maxzoom\", 14),\n        (\"colormap_name\", \"viridis\"),\n    )\n).json()\n\nm = Map(\n    location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),\n    zoom_start=10\n)\n\ntiles = TileLayer(\n    tiles=r[\"tiles\"][0],\n    min_zoom=r[\"minzoom\"],\n    max_zoom=r[\"maxzoom\"],\n    opacity=1,\n    attr=\"ESA\"\n)\ntiles.add_to(m)\nm\n</pre> # Get Tile URL r = httpx.get(     f\"{titiler_endpoint}/stac/WebMercatorQuad/tilejson.json\",     params = (         (\"url\", stac_item),         (\"expression\", \"(nir_b1-red_b1)/(nir_b1+red_b1)\"),  # NDVI         (\"rescale\", \"-1,1\"),         (\"minzoom\", 8),         (\"maxzoom\", 14),         (\"colormap_name\", \"viridis\"),     ) ).json()  m = Map(     location=((bounds[1] + bounds[3]) / 2,(bounds[0] + bounds[2]) / 2),     zoom_start=10 )  tiles = TileLayer(     tiles=r[\"tiles\"][0],     min_zoom=r[\"minzoom\"],     max_zoom=r[\"maxzoom\"],     opacity=1,     attr=\"ESA\" ) tiles.add_to(m) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_STAC_simple/#working-with-stac","title":"Working With STAC\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC_simple/#stac-spatiotemporal-asset-catalog","title":"STAC: SpatioTemporal Asset Catalog\u00b6","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification aims to standardize the way geospatial assets are exposed online and queried. A 'spatiotemporal asset' is any file that represents information about the earth captured in a certain space and time. The initial focus is primarily remotely-sensed imagery (from satellites, but also planes, drones, balloons, etc), but the core is designed to be extensible to SAR, full motion video, point clouds, hyperspectral, LiDAR and derived data like NDVI, Digital Elevation Models, mosaics, etc.</p> <p>Ref: https://github.com/radiantearth/stac-spechttps://github.com/radiantearth/stac-spec</p> <p>Using STAC makes data indexation and discovery really easy. In addition to the Collection/Item/Asset (data) specifications, data providers are also encouraged to follow a STAC API specification:  https://github.com/radiantearth/stac-api-spec</p> <p>The API is compliant with the OGC API - Features standard (formerly known as OGC Web Feature Service 3), in that it defines many of the endpoints that STAC uses. A STAC API should be compatible and usable with any OGC API - Features clients. The STAC API can be thought of as a specialized Features API to search STAC Catalogs, where the features returned are STAC Items, that have common properties, links to their assets and geometries that represent the footprints of the geospatial assets.</p>"},{"location":"examples/notebooks/Working_with_STAC_simple/#requirements","title":"Requirements\u00b6","text":"<p>To be able to run this notebook you'll need the following requirements:</p> <ul> <li>folium</li> <li>httpx</li> <li>rasterio</li> </ul> <p><code>!pip install folium httpx rasterio</code></p>"},{"location":"examples/notebooks/Working_with_STAC_simple/#display-one-asset","title":"Display one asset\u00b6","text":""},{"location":"examples/notebooks/Working_with_STAC_simple/#select-indexes-for-assets","title":"Select Indexes for assets\u00b6","text":""},{"location":"examples/notebooks/Working_with_Statistics/","title":"Working with Statistics","text":"In\u00a0[9]: Copied! <pre># setup\nimport httpx\nimport json\n\ntitiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\ncog_url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\"\n</pre> # setup import httpx import json  titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. cog_url = \"https://opendata.digitalglobe.com/events/mauritius-oil-spill/post-event/2020-08-12/105001001F1B5B00/105001001F1B5B00.tif\" In\u00a0[10]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/bounds\",\n    params = {\n        \"url\": cog_url,\n    }\n).json()\n\nbounds = r[\"bounds\"]\nprint(r)\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/bounds\",     params = {         \"url\": cog_url,     } ).json()  bounds = r[\"bounds\"] print(r) <pre>{'bounds': [57.664053823239804, -20.55473177712791, 57.84021477996238, -20.25261582755764]}\n</pre> <p>For a bit more information, you can get summary statistics from the <code>/info</code> endpoint. This includes info such as:</p> <ul> <li>Bounds (identical to the <code>/bounds</code> endpoint)</li> <li>Min and max zoom</li> <li>Band metadata, such as names of the bands and their descriptions</li> <li>Number of bands in the image</li> <li>Overview levels</li> <li>Image width and height</li> </ul> <p>These are statistics available in the metadata of the image, so should be fast to read.</p> In\u00a0[11]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/info\",\n    params = {\n        \"url\": cog_url,\n    }\n).json()\n\nprint(json.dumps(r))\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/info\",     params = {         \"url\": cog_url,     } ).json()  print(json.dumps(r)) <pre>{\"bounds\": [57.664053823239804, -20.55473177712791, 57.84021477996238, -20.25261582755764], \"minzoom\": 10, \"maxzoom\": 18, \"band_metadata\": [[\"b1\", {}], [\"b2\", {}], [\"b3\", {}]], \"band_descriptions\": [[\"b1\", \"\"], [\"b2\", \"\"], [\"b3\", \"\"]], \"dtype\": \"uint8\", \"nodata_type\": \"Mask\", \"colorinterp\": [\"red\", \"green\", \"blue\"], \"count\": 3, \"width\": 38628, \"driver\": \"GTiff\", \"overviews\": [2, 4, 8, 16, 32, 64, 128], \"height\": 66247}\n</pre> In\u00a0[12]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params = {\n        \"url\": cog_url,\n    }\n).json()\n\nprint(json.dumps(r))\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params = {         \"url\": cog_url,     } ).json()  print(json.dumps(r)) <pre>{\"b1\": {\"min\": 0.0, \"max\": 255.0, \"mean\": 36.94901407469342, \"count\": 574080.0, \"sum\": 21211690.0, \"std\": 48.282133573955264, \"median\": 3.0, \"majority\": 1.0, \"minority\": 246.0, \"unique\": 256.0, \"histogram\": [[330584.0, 54820.0, 67683.0, 57434.0, 30305.0, 14648.0, 9606.0, 5653.0, 2296.0, 1051.0], [0.0, 25.5, 51.0, 76.5, 102.0, 127.5, 153.0, 178.5, 204.0, 229.5, 255.0]], \"valid_percent\": 93.75, \"masked_pixels\": 38272.0, \"valid_pixels\": 574080.0, \"percentile_2\": 0.0, \"percentile_98\": 171.0}, \"b2\": {\"min\": 0.0, \"max\": 255.0, \"mean\": 57.1494356187291, \"count\": 574080.0, \"sum\": 32808348.0, \"std\": 56.300819175100656, \"median\": 37.0, \"majority\": 5.0, \"minority\": 0.0, \"unique\": 256.0, \"histogram\": [[271018.0, 34938.0, 54030.0, 69429.0, 70260.0, 32107.0, 29375.0, 9697.0, 2001.0, 1225.0], [0.0, 25.5, 51.0, 76.5, 102.0, 127.5, 153.0, 178.5, 204.0, 229.5, 255.0]], \"valid_percent\": 93.75, \"masked_pixels\": 38272.0, \"valid_pixels\": 574080.0, \"percentile_2\": 5.0, \"percentile_98\": 180.0}, \"b3\": {\"min\": 0.0, \"max\": 255.0, \"mean\": 51.251764562430324, \"count\": 574080.0, \"sum\": 29422613.0, \"std\": 39.65505035854822, \"median\": 36.0, \"majority\": 16.0, \"minority\": 252.0, \"unique\": 254.0, \"histogram\": [[203263.0, 150865.0, 104882.0, 42645.0, 30652.0, 25382.0, 12434.0, 2397.0, 1097.0, 463.0], [0.0, 25.5, 51.0, 76.5, 102.0, 127.5, 153.0, 178.5, 204.0, 229.5, 255.0]], \"valid_percent\": 93.75, \"masked_pixels\": 38272.0, \"valid_pixels\": 574080.0, \"percentile_2\": 14.0, \"percentile_98\": 158.0}}\n</pre> <p>This endpoint is far more configurable than <code>/bounds</code> and <code>info</code>. You can specify which bands to analyse, how to generate the histogram, and pre-process the image.</p> <p>For example, if you wanted to get the statistics of the VARI of the image you can use the <code>expression</code> parameter to conduct simple band math:</p> In\u00a0[13]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/statistics\",\n    params = {\n        \"url\": cog_url,\n        \"expression\": \"(b2-b1)/(b1+b2-b3)\", # expression for the VARI\n        \"histogram_range\": \"-1,1\"\n    }\n).json()\n\nprint(json.dumps(r))\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/statistics\",     params = {         \"url\": cog_url,         \"expression\": \"(b2-b1)/(b1+b2-b3)\", # expression for the VARI         \"histogram_range\": \"-1,1\"     } ).json()  print(json.dumps(r)) <pre>{\"(b2-b1)/(b1+b2-b3)\": {\"min\": -1.7976931348623157e+308, \"max\": 1.7976931348623157e+308, \"mean\": null, \"count\": 574080.0, \"sum\": null, \"std\": null, \"median\": -0.15384615384615385, \"majority\": -0.4, \"minority\": -149.0, \"unique\": 18718.0, \"histogram\": [[5646.0, 10176.0, 130905.0, 97746.0, 50184.0, 95842.0, 60322.0, 21478.0, 13552.0, 12204.0], [-1.0, -0.8, -0.6, -0.3999999999999999, -0.19999999999999996, 0.0, 0.20000000000000018, 0.40000000000000013, 0.6000000000000001, 0.8, 1.0]], \"valid_percent\": 93.75, \"masked_pixels\": 38272.0, \"valid_pixels\": 574080.0, \"percentile_2\": -3.5, \"percentile_98\": 3.3870967741935485}}\n</pre> <p>Alternatively, if you would like to get statistics for only a certain area, you can specify an area via a feature or a feature collection.</p> <p>(Note: this endpoint is not available in the mosaicjson endpoint, only <code>/cog</code> and <code>/stac</code>)</p> In\u00a0[14]: Copied! <pre>mahebourg = \"\"\"\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"properties\": {},\n      \"geometry\": {\n        \"coordinates\": [\n          [\n            [\n              57.70358910197049,\n              -20.384114558699935\n            ],\n            [\n              57.68564920588395,\n              -20.384114558699935\n            ],\n            [\n              57.68209507552771,\n              -20.39855066753664\n            ],\n            [\n              57.68666467170024,\n              -20.421074640746554\n            ],\n            [\n              57.70341985766697,\n              -20.434397129770545\n            ],\n            [\n              57.72999121319131,\n              -20.42392955694521\n            ],\n            [\n              57.70358910197049,\n              -20.384114558699935\n            ]\n          ]\n        ],\n        \"type\": \"Polygon\"\n      }\n    }\n  ]\n}\n\"\"\"\n</pre> mahebourg = \"\"\" {   \"type\": \"FeatureCollection\",   \"features\": [     {       \"type\": \"Feature\",       \"properties\": {},       \"geometry\": {         \"coordinates\": [           [             [               57.70358910197049,               -20.384114558699935             ],             [               57.68564920588395,               -20.384114558699935             ],             [               57.68209507552771,               -20.39855066753664             ],             [               57.68666467170024,               -20.421074640746554             ],             [               57.70341985766697,               -20.434397129770545             ],             [               57.72999121319131,               -20.42392955694521             ],             [               57.70358910197049,               -20.384114558699935             ]           ]         ],         \"type\": \"Polygon\"       }     }   ] } \"\"\" In\u00a0[15]: Copied! <pre># NOTE: This is a POST request, unlike all other requests in this example\nr = httpx.post(\n    f\"{titiler_endpoint}/cog/statistics\",\n    data=mahebourg,\n    params = {\n        \"url\": cog_url,\n    }\n).json()\n\nprint(json.dumps(r))\n</pre> # NOTE: This is a POST request, unlike all other requests in this example r = httpx.post(     f\"{titiler_endpoint}/cog/statistics\",     data=mahebourg,     params = {         \"url\": cog_url,     } ).json()  print(json.dumps(r))  <pre>{\"type\": \"FeatureCollection\", \"features\": [{\"type\": \"Feature\", \"geometry\": {\"type\": \"Polygon\", \"coordinates\": [[[57.70358910197049, -20.384114558699935], [57.68564920588395, -20.384114558699935], [57.68209507552771, -20.39855066753664], [57.68666467170024, -20.421074640746554], [57.70341985766697, -20.434397129770545], [57.72999121319131, -20.42392955694521], [57.70358910197049, -20.384114558699935]]]}, \"properties\": {\"statistics\": {\"b1\": {\"min\": 0.0, \"max\": 255.0, \"mean\": 88.5634794986129, \"count\": 619641.0, \"sum\": 54877563.0, \"std\": 55.18714964714274, \"median\": 77.0, \"majority\": 52.0, \"minority\": 253.0, \"unique\": 256.0, \"histogram\": [[67233.0, 110049.0, 129122.0, 90849.0, 77108.0, 44091.0, 44606.0, 37790.0, 18033.0, 760.0], [0.0, 25.5, 51.0, 76.5, 102.0, 127.5, 153.0, 178.5, 204.0, 229.5, 255.0]], \"valid_percent\": 62.0, \"masked_pixels\": 379783.0, \"valid_pixels\": 619641.0, \"percentile_2\": 4.0, \"percentile_98\": 208.0}, \"b2\": {\"min\": 0.0, \"max\": 255.0, \"mean\": 112.07155594933195, \"count\": 619641.0, \"sum\": 69444131.0, \"std\": 42.64508357271268, \"median\": 107.0, \"majority\": 103.0, \"minority\": 1.0, \"unique\": 256.0, \"histogram\": [[6004.0, 31108.0, 107187.0, 126848.0, 130731.0, 73650.0, 107827.0, 33264.0, 2403.0, 619.0], [0.0, 25.5, 51.0, 76.5, 102.0, 127.5, 153.0, 178.5, 204.0, 229.5, 255.0]], \"valid_percent\": 62.0, \"masked_pixels\": 379783.0, \"valid_pixels\": 619641.0, \"percentile_2\": 34.0, \"percentile_98\": 189.0}, \"b3\": {\"min\": 0.0, \"max\": 255.0, \"mean\": 84.54690377170006, \"count\": 619641.0, \"sum\": 52388728.0, \"std\": 44.64862735915829, \"median\": 77.0, \"majority\": 53.0, \"minority\": 254.0, \"unique\": 256.0, \"histogram\": [[40704.0, 130299.0, 138014.0, 85866.0, 86381.0, 91182.0, 41872.0, 4116.0, 993.0, 214.0], [0.0, 25.5, 51.0, 76.5, 102.0, 127.5, 153.0, 178.5, 204.0, 229.5, 255.0]], \"valid_percent\": 62.0, \"masked_pixels\": 379783.0, \"valid_pixels\": 619641.0, \"percentile_2\": 11.0, \"percentile_98\": 170.0}}}}]}\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_Statistics/#working-with-statistics","title":"Working with Statistics\u00b6","text":""},{"location":"examples/notebooks/Working_with_Statistics/#intro","title":"Intro\u00b6","text":"<p>Titiler allows you to get statistics and summaries of your data without having to load the entire dataset yourself. These statistics can be summaries of entire COG files, STAC items, or individual parts of the file, specified using GeoJSON.</p> <p>Below, we will go over some of the statistical endpoints in Titiler - <code>/bounds</code>, <code>/info</code>, and <code>/statistics</code>.</p> <p>(Note: these examples will be using the <code>/cog</code> endpoint, but everything is also available for <code>/stac</code> and <code>/mosaicjson</code> unless otherwise noted)</p>"},{"location":"examples/notebooks/Working_with_Statistics/#bounds","title":"Bounds\u00b6","text":"<p>The <code>/bounds</code> endpoint returns the bounding box of the image/asset. These bounds are returned in the projection EPSG:4326 (WGS84), in the format <code>(minx, miny, maxx, maxy)</code>.</p>"},{"location":"examples/notebooks/Working_with_Statistics/#statistics","title":"Statistics\u00b6","text":"<p>For even more statistics of the image, you can use the <code>/statistics</code> endpoint. This includes even more info, including:</p> <ul> <li>Summary statistics about overall pixel values, such min, max, mean, and count</li> <li>Histogram of the pixel values</li> <li>Percentiles</li> </ul> <p>Statistics are generated both for the image as a whole and for each band individually.</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/","title":"Working With TileMatrixSets (other than WebMercator)","text":"<p>This Notebook shows how to use and display tiles with non-webmercator TileMatrixSet</p> In\u00a0[\u00a0]: Copied! <pre># Uncomment if you need to install those module within the notebook\n# !pip install ipyleaflet httpx\n</pre> # Uncomment if you need to install those module within the notebook # !pip install ipyleaflet httpx In\u00a0[\u00a0]: Copied! <pre>import json\n\nimport httpx\n\nfrom ipyleaflet import (\n    Map,\n    basemaps,\n    basemap_to_tiles,\n    TileLayer,\n    WMSLayer,\n    GeoJSON,\n    projections\n)\n</pre> import json  import httpx  from ipyleaflet import (     Map,     basemaps,     basemap_to_tiles,     TileLayer,     WMSLayer,     GeoJSON,     projections ) In\u00a0[\u00a0]: Copied! <pre>titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind.\nurl = \"https://s3.amazonaws.com/opendata.remotepixel.ca/cogs/natural_earth/world.tif\" # Natural Earth WORLD tif\n</pre> titiler_endpoint = \"https://titiler.xyz\"  # Developmentseed Demo endpoint. Please be kind. url = \"https://s3.amazonaws.com/opendata.remotepixel.ca/cogs/natural_earth/world.tif\" # Natural Earth WORLD tif In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(f\"{titiler_endpoint}/tileMatrixSets\").json()\n\nprint(\"Supported TMS:\")\nfor tms in r[\"tileMatrixSets\"]:\n    print(\"-\", tms[\"id\"])\n</pre> r = httpx.get(f\"{titiler_endpoint}/tileMatrixSets\").json()  print(\"Supported TMS:\") for tms in r[\"tileMatrixSets\"]:     print(\"-\", tms[\"id\"]) In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\", params = {\"url\": url}\n).json()\n\nm = Map(center=(0, 0), zoom=2, basemap={}, crs=projections.EPSG3857)\n\nlayer = TileLayer(url=r[\"tiles\"][0], opacity=1)\nm.add_layer(layer)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WebMercatorQuad/tilejson.json\", params = {\"url\": url} ).json()  m = Map(center=(0, 0), zoom=2, basemap={}, crs=projections.EPSG3857)  layer = TileLayer(url=r[\"tiles\"][0], opacity=1) m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/WorldCRS84Quad/tilejson.json\", params = {\"url\": url}\n).json()\n\nm = Map(center=(0, 0), zoom=1, basemap={}, crs=projections.EPSG4326)\n\nlayer = TileLayer(url=r[\"tiles\"][0], opacity=1)\nm.add_layer(layer)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/WorldCRS84Quad/tilejson.json\", params = {\"url\": url} ).json()  m = Map(center=(0, 0), zoom=1, basemap={}, crs=projections.EPSG4326)  layer = TileLayer(url=r[\"tiles\"][0], opacity=1) m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>r = httpx.get(\n    f\"{titiler_endpoint}/cog/EuropeanETRS89_LAEAQuad/tilejson.json\", params = {\"url\": url}\n).json()\n\nmy_projection = {\n    'name': 'EPSG:3035',\n    'custom': True, #This is important, it tells ipyleaflet that this projection is not on the predefined ones.\n    'proj4def': '+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',\n    'origin': [6500000.0, 5500000.0],\n    'resolutions': [\n        8192.0,\n        4096.0,\n        2048.0,\n        1024.0,\n        512.0,\n        256.0\n    ]\n}\n\nm = Map(center=(50, 65), zoom=0, basemap={}, crs=my_projection)\n\nlayer = TileLayer(url=r[\"tiles\"][0], opacity=1)\nm.add_layer(layer)\nm\n</pre> r = httpx.get(     f\"{titiler_endpoint}/cog/EuropeanETRS89_LAEAQuad/tilejson.json\", params = {\"url\": url} ).json()  my_projection = {     'name': 'EPSG:3035',     'custom': True, #This is important, it tells ipyleaflet that this projection is not on the predefined ones.     'proj4def': '+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',     'origin': [6500000.0, 5500000.0],     'resolutions': [         8192.0,         4096.0,         2048.0,         1024.0,         512.0,         256.0     ] }  m = Map(center=(50, 65), zoom=0, basemap={}, crs=my_projection)  layer = TileLayer(url=r[\"tiles\"][0], opacity=1) m.add_layer(layer) m In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#working-with-tilematrixsets-other-than-webmercator","title":"Working With TileMatrixSets (other than WebMercator)\u00b6","text":"<p>TiTiler has builtin support for serving tiles in multiple Projections by using rio-tiler and morecantile.</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#requirements","title":"Requirements\u00b6","text":"<ul> <li>ipyleaflet</li> <li>httpx</li> </ul>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#list-supported-tilematrixsets","title":"List Supported TileMatrixSets\u00b6","text":""},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#webmercator-epsg3857","title":"WebMercator - EPSG:3857\u00b6","text":"<p>https://epsg.io/3857</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#wgs-84-wgs84-world-geodetic-system-1984-epsg4326","title":"WGS 84 -- WGS84 - World Geodetic System 1984 - EPSG:4326\u00b6","text":"<p>https://epsg.io/4326</p>"},{"location":"examples/notebooks/Working_with_nonWebMercatorTMS/#etrs89-extended-laea-europe-epsg3035","title":"ETRS89-extended / LAEA Europe - EPSG:3035\u00b6","text":"<p>https://epsg.io/3035</p>"}]}